alloc_class int
alloc_class uint
alloc_class byte
alloc_class ubyte
alloc_class short
alloc_class ushort
alloc_class long
alloc_class ulong
alloc_class float
alloc_class double
alloc_class pointer
alloc_class char
alloc_class bool
alloc_class lambda
alloc_class regex
alloc_class Null
alloc_class Anonymous
alloc_class Self
alloc_class GenericsParametorClass0
alloc_class GenericsParametorClass1
alloc_class GenericsParametorClass2
alloc_class GenericsParametorClass3
alloc_class GenericsParametorClass4
alloc_class GenericsParametorClass5
alloc_class GenericsParametorClass6
alloc_class GenericsParametorClass7
alloc_class GenericsParametorClass8
alloc_class GenericsParametorClass9
alloc_class GenericsParametorClass10
alloc_class GenericsParametorClass11
alloc_class GenericsParametorClass12
alloc_class GenericsParametorClass13
alloc_class GenericsParametorClass14
alloc_class GenericsParametorClass15
alloc_class GenericsParametorClass16
alloc_class GenericsParametorClass17
alloc_class GenericsParametorClass18
alloc_class GenericsParametorClass19
alloc_class GenericsParametorClass20
alloc_class GenericsParametorClass21
alloc_class GenericsParametorClass22
alloc_class GenericsParametorClass23
alloc_class GenericsParametorClass24
alloc_class GenericsParametorClass25
alloc_class GenericsParametorClass26
alloc_class GenericsParametorClass27
alloc_class GenericsParametorClass28
alloc_class GenericsParametorClass29
alloc_class GenericsParametorClass30
alloc_class GenericsParametorClass31
alloc_class MethodGenericsParametorClass0
alloc_class MethodGenericsParametorClass1
alloc_class MethodGenericsParametorClass2
alloc_class MethodGenericsParametorClass3
alloc_class MethodGenericsParametorClass4
alloc_class MethodGenericsParametorClass5
alloc_class MethodGenericsParametorClass6
alloc_class MethodGenericsParametorClass7
alloc_class MethodGenericsParametorClass8
alloc_class MethodGenericsParametorClass9
alloc_class MethodGenericsParametorClass10
alloc_class MethodGenericsParametorClass11
alloc_class MethodGenericsParametorClass12
alloc_class System
alloc_class Global
alloc_class String
alloc_class Exception
alloc_class Object
alloc_class Clover
alloc_class Byte
alloc_class UByte
alloc_class Short
alloc_class UShort
alloc_class Integer
alloc_class UInteger
alloc_class Long
alloc_class ULong
alloc_class Float
alloc_class Double
alloc_class Pointer
alloc_class Char
alloc_class Bool
alloc_class IEqualable
alloc_class ISortable
alloc_class IHashKey
alloc_class Array
alloc_class EqualableArray
alloc_class SortableArray
alloc_class ListItem
alloc_class List
alloc_class EqualableList
alloc_class HashItem
alloc_class Hash
alloc_class Tuple1
alloc_class Tuple2
alloc_class Tuple3
alloc_class Tuple4
alloc_class Tuple5
alloc_class Tuple6
alloc_class Tuple7
alloc_class Tuple8
alloc_class Tuple9
alloc_class Tuple10
alloc_class PcreOVec
alloc_class Buffer
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MWrapperClassBase (
    def toByte(): Byte {
        return self.value.toByte;
    }

    def toUByte(): UByte {
        return self.value.toUByte;
    }

    def toShort(): Short {
        return self.value.toShort;
    }

    def toUShort(): UShort {
        return self.value.toUShort;
    }

    def toInteger(): Integer {
        return self.value.toInteger;
    }

    def toUInteger(): UInteger {
        return self.value.toUInteger;
    }

    def toLong(): Long {
        return self.value.toLong;
    }

    def toULong(): ULong {
        return self.value.toULong;
    }

    def toChar(): Char {
        return self.value.toChar;
    }

    def toBool(): Bool {
        return self.value.toBool;
    }

    def toString(): String {
        return self.value.toString;
    }

    def equals(right:SELF): bool {
        return self.value == right.value;
    }

    def compare(right:SELF):  int {
        if(self.value < right.value) {
            return -1;
        }
        elif(self.value == right.value) {
            return 0;
        }
        else {
            return 1;
        }
    }
)
body MArrayImplement (
    items:T[]?;

    def initialize() {
        self.items = null;
    }

    def initialize(items:T[]) {
        self.items = items;
    }

    def length():int {
        return self.items.length;
    }

    def items(index:int):T throws Exception {
        if(index < 0) {
            index += self.items.length;
        }

        return self.items[index];
    }

    def each(block_:lambda(T)) {
        for(i:int = 0; i<self.items.length; i++) {
            block_(self.items[i]);
        }
    }
)
body MArrayImplement (
    items:T[]?;

    def initialize() {
        self.items = null;
    }

    def initialize(items:T[]) {
        self.items = items;
    }

    def length():int {
        return self.items.length;
    }

    def items(index:int):T throws Exception {
        if(index < 0) {
            index += self.items.length;
        }

        return self.items[index];
    }

    def each(block_:lambda(T)) {
        for(i:int = 0; i<self.items.length; i++) {
            block_(self.items[i]);
        }
    }
)
body MEqualableArrayImplement (
    def toString():String {
        if(self.items.length == 0) {
            return "earray {}";
        }

        result:String = "earray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }

    def equals(right:T[]): bool {
        return self.equals(right.toArray);
    }

    def equals(right:Array<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }

    def equals(right:EqualableArray<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }
)
body MArrayImplement (
    items:T[]?;

    def initialize() {
        self.items = null;
    }

    def initialize(items:T[]) {
        self.items = items;
    }

    def length():int {
        return self.items.length;
    }

    def items(index:int):T throws Exception {
        if(index < 0) {
            index += self.items.length;
        }

        return self.items[index];
    }

    def each(block_:lambda(T)) {
        for(i:int = 0; i<self.items.length; i++) {
            block_(self.items[i]);
        }
    }
)
body MEqualableArrayImplement (
    def toString():String {
        if(self.items.length == 0) {
            return "earray {}";
        }

        result:String = "earray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }

    def equals(right:T[]): bool {
        return self.equals(right.toArray);
    }

    def equals(right:Array<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }

    def equals(right:EqualableArray<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }
)
body MList (
    head: ListItem<T>?;
    tail: ListItem<T>?;
    number: int;

    def initialize() {
        self.head = null;
        self.tail = null;
        self.number = 0;
    }

    def initialize(items:T[], num_elements:uint) {
        self.head = null;
        self.tail = null;
        self.number = 0;

        for(i:int = 0; i<num_elements; i++) {
            self.add(items[i]);
        }
    }

    def setValue(list:SELF<T>) {
        self.head = list.head;
        self.tail = list.tail;
        self.number = list.number;
    }

    def length():int {
        return self.number;
    }

    def toString(): String {
        if(self.head.identifyWith(null)) {
            return "Null list";
        }
        else {
            result:String = "";
            result.append(self.number.toString);
            result.append(" length list of ");
            result.append(self.head.item.className());
            return result;
        }
    }

    def items(index:int):T? {
        if(index < 0) {
            index += self.number;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                return it.item
            }
            count++;

            it = it.next;
        }

        return null;
    }
    
    def clear(): SELF<T> {
        self.head = null;
        self.tail = null;
        self.number = 0;

        return self;
    }

    def add(item:T):SELF<T> {
        if(self.head.identifyWith(null)) {
            self.head = new ListItem<T>(item, null, null);
            self.tail = self.head;
        }
        else {
            new_item:ListItem<T> = new ListItem<T>(item, self.tail, null);

            self.tail.next = new_item;
            self.tail = new_item;
        }

        self.number++;

        return self;
    }

    def push(item:T):SELF<T> {
        return self.add(item);
    }

    def pop():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_tail :ListItem<T>? = self.tail.prev;
            item :T = self.tail.item;

            if(new_tail.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_tail.next = null;
                self.tail = new_tail;

                self.number--;

                return item;
            }
        }
    }

    def shift():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_head :ListItem<T>? = self.head.next;
            item :T = self.head.item;

            if(new_head.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_head.prev = null;
                self.head = new_head;

                self.number--;

                return item;
            }
        }
    }

    def insert(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number + 1;
        }
        if(index < 0) {
            index = 0;
        }
        if(index > self.number) {
            index = self.number;
        }

        if(self.number == 0 || index == self.number) {
            self.add(item);
            return self;
        }

        if(index == 0) {
            new_item:ListItem<T> = new ListItem<T>(item, null, self.head);
            self.head.prev = new_item;
            self.head = new_item;

            self.number++;
        }
        else {
            it:ListItem<T>? = self.head;

            i:int= 0;

            while(!it.identifyWith(null)) {
                if(i == index-1) {
                    new_item:ListItem<T> = new ListItem<T>(item, it, it.next);
                    if(!it.next.identifyWith(null)) {
                        it.next.prev = new_item;
                    }
                    it.next = new_item;

                    self.number++;
                    break;
                }

                it = it.next;
                i++;
            }
        }

        return self;
    }

    def deleteAt(index:int):SELF<T> {
        it:ListItem<T>? = self.head;
        it2:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }

            count++;
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def each(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.next;
        }

        return self;
    }

    def eachReverse(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.prev;
        }

        return self;
    }

    def replace(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number;
        }
        if(index < 0) {
            index = 0;
        }
        if(index >= self.number) {
            index = self.number-1;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                it.item = item;
                break;
            }
            count++;

            it = it.next;
        }

        return self;
    }
    def sample():T {
        return self.items(System.rand() % self.number);
    }

    def append(list:SELF<T>):SELF<T> {
        list.each(closure(item:T) {
            self.add(item);
        });

        return self;
    }

    def multiply(n:int):SELF<T> {
        result:SELF<T> = new SELF<T>();

        for(i:int = 0; i<n; i++) {
            result.append(self);
        }

        return result;
    }

    def select(block_:lambda(T):bool):SELF<T> {
        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(block_(it.item)) {
                new_list.add(it.item);
            }
            it = it.next;
        }

        return new_list;
    }

    def clone():SELF<T> {
        result:SELF<T> = new SELF<T>();
        it :ListItem<T>? = self.head;
        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.next;
        }
        return result;
    }

    def subList(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count >= start && count < end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def deleteWithRange(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def fill(start:int, end:int, item:T):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            else {
                new_list.add(item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }
    def fill(item:T):SELF<T> {
        return self.fill(0,-1,item);
    }

    def reverse():SELF<T> {
        result:SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.prev;
        }

        return result;
    }

    def shuffle():SELF<T> {
        result:SELF<T> = self.clone();

        for(i:int =0; i<50; i++) {
            n :int = System.rand() % self.number;
            m :int = System.rand() % self.number;

            item :T = result.items(n);
            item2 :T = result.items(m);

            result.replace(m, item);
            result.replace(n, item2);
        }

        return result;
    }
)
body MList (
    head: ListItem<T>?;
    tail: ListItem<T>?;
    number: int;

    def initialize() {
        self.head = null;
        self.tail = null;
        self.number = 0;
    }

    def initialize(items:T[], num_elements:uint) {
        self.head = null;
        self.tail = null;
        self.number = 0;

        for(i:int = 0; i<num_elements; i++) {
            self.add(items[i]);
        }
    }

    def setValue(list:SELF<T>) {
        self.head = list.head;
        self.tail = list.tail;
        self.number = list.number;
    }

    def length():int {
        return self.number;
    }

    def toString(): String {
        if(self.head.identifyWith(null)) {
            return "Null list";
        }
        else {
            result:String = "";
            result.append(self.number.toString);
            result.append(" length list of ");
            result.append(self.head.item.className());
            return result;
        }
    }

    def items(index:int):T? {
        if(index < 0) {
            index += self.number;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                return it.item
            }
            count++;

            it = it.next;
        }

        return null;
    }
    
    def clear(): SELF<T> {
        self.head = null;
        self.tail = null;
        self.number = 0;

        return self;
    }

    def add(item:T):SELF<T> {
        if(self.head.identifyWith(null)) {
            self.head = new ListItem<T>(item, null, null);
            self.tail = self.head;
        }
        else {
            new_item:ListItem<T> = new ListItem<T>(item, self.tail, null);

            self.tail.next = new_item;
            self.tail = new_item;
        }

        self.number++;

        return self;
    }

    def push(item:T):SELF<T> {
        return self.add(item);
    }

    def pop():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_tail :ListItem<T>? = self.tail.prev;
            item :T = self.tail.item;

            if(new_tail.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_tail.next = null;
                self.tail = new_tail;

                self.number--;

                return item;
            }
        }
    }

    def shift():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_head :ListItem<T>? = self.head.next;
            item :T = self.head.item;

            if(new_head.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_head.prev = null;
                self.head = new_head;

                self.number--;

                return item;
            }
        }
    }

    def insert(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number + 1;
        }
        if(index < 0) {
            index = 0;
        }
        if(index > self.number) {
            index = self.number;
        }

        if(self.number == 0 || index == self.number) {
            self.add(item);
            return self;
        }

        if(index == 0) {
            new_item:ListItem<T> = new ListItem<T>(item, null, self.head);
            self.head.prev = new_item;
            self.head = new_item;

            self.number++;
        }
        else {
            it:ListItem<T>? = self.head;

            i:int= 0;

            while(!it.identifyWith(null)) {
                if(i == index-1) {
                    new_item:ListItem<T> = new ListItem<T>(item, it, it.next);
                    if(!it.next.identifyWith(null)) {
                        it.next.prev = new_item;
                    }
                    it.next = new_item;

                    self.number++;
                    break;
                }

                it = it.next;
                i++;
            }
        }

        return self;
    }

    def deleteAt(index:int):SELF<T> {
        it:ListItem<T>? = self.head;
        it2:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }

            count++;
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def each(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.next;
        }

        return self;
    }

    def eachReverse(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.prev;
        }

        return self;
    }

    def replace(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number;
        }
        if(index < 0) {
            index = 0;
        }
        if(index >= self.number) {
            index = self.number-1;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                it.item = item;
                break;
            }
            count++;

            it = it.next;
        }

        return self;
    }
    def sample():T {
        return self.items(System.rand() % self.number);
    }

    def append(list:SELF<T>):SELF<T> {
        list.each(closure(item:T) {
            self.add(item);
        });

        return self;
    }

    def multiply(n:int):SELF<T> {
        result:SELF<T> = new SELF<T>();

        for(i:int = 0; i<n; i++) {
            result.append(self);
        }

        return result;
    }

    def select(block_:lambda(T):bool):SELF<T> {
        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(block_(it.item)) {
                new_list.add(it.item);
            }
            it = it.next;
        }

        return new_list;
    }

    def clone():SELF<T> {
        result:SELF<T> = new SELF<T>();
        it :ListItem<T>? = self.head;
        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.next;
        }
        return result;
    }

    def subList(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count >= start && count < end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def deleteWithRange(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def fill(start:int, end:int, item:T):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            else {
                new_list.add(item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }
    def fill(item:T):SELF<T> {
        return self.fill(0,-1,item);
    }

    def reverse():SELF<T> {
        result:SELF<T> = new SELF<T>();

        it :ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.prev;
        }

        return result;
    }

    def shuffle():SELF<T> {
        result:SELF<T> = self.clone();

        for(i:int =0; i<50; i++) {
            n :int = System.rand() % self.number;
            m :int = System.rand() % self.number;

            item :T = result.items(n);
            item2 :T = result.items(m);

            result.replace(m, item);
            result.replace(n, item2);
        }

        return result;
    }
)
body MEqualableList (
    def equals(right:SELF<T>):bool {
        if(self.number != right.number) {
            return false;
        }
        for(i:int =0; i<self.number; i++) {
            if(!self.items(i).equals(right.items(i))) {
                return false;
            }
        }

        return true;
    }

    def delete(item:T):SELF<T> {
        it:ListItem<T>? = self.head;
        it2:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def indexOf(item:T):int {
        result:int = 0;

        it:ListItem<T>? = self.head;
        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }

            result++;

            it = it.next;
        }

        return -1;
    }
    def toString():String {
        if(self.number == 0) {
            return "elist {}";
        }

        result:String = "elist {";

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            result.append(",");

            it = it.next;
        }

        result.replace(-1, '}');

        return result;
    }
    def join(separator:String):String {
        result:String = new String("");
        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            it = it.next;

            if(!it.identifyWith(null)) {
                result.append(separator);
            }
        }

        return result;
    }

    def join():String {
        return self.join("");
    }

    def count(item:T):int {
        result:int = 0;

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                result++;
            }

            it = it.next;
        }

        return result;
    }

    def indexOf(item:T):int {
        result:int = 0;
        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }
            result++;
            it = it.next;
        }

        return -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MInclude (
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(seContainer.clcl 338: There is no field(head) in this class(List)
Container.clcl 338: The different type between left type and right type(2). ListItem and int
Container.clcl 339: There is no field(tail) in this class(List)
Container.clcl 339: The different type between left type and right type(2). ListItem and int
Container.clcl 340: There is no field(number) in this class(List)
Container.clcl 617: method not found(1)
Container.clcl 617: List.each(1 prametors) is not found
Container.clcl 617: parametor#0 is lambda
Container.clcl 950: at including Module MList
Container.clcl 338: There is no field(head) in this class(List)
Container.clcl 338: The different type between left type and right type(2). ListItem and int
Container.clcl 339: There is no field(tail) in this class(List)
Container.clcl 339: The different type between left type and right type(2). ListItem and int
Container.clcl 340: There is no field(number) in this class(List)
Container.clcl 617: method not found(1)
Container.clcl 617: List.each(1 prametors) is not found
Container.clcl 617: parametor#0 is lambda
Container.clcl 1007: at including Module MList
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Byte
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1668: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is UByte
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1673: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Short
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1678: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is UShort
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1683: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Integer
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1688: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is UInteger
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1693: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Long
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1698: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is ULong
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1703: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Float
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1708: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Double
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1713: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Pointer
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1718: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Char
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1723: at including Module MInclude
Container.clcl 1662: method not found(1)
Container.clcl 1662: List.indexOf(1 prametors) is not found
Container.clcl 1662: parametor#0 is Bool
Container.clcl 1662: Invalid type of return value(4)
Container.clcl 1728: at including Module MInclude
Parser error number is 0. Compile error number is 38
cclover2 can't compile (null)
lf.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
body MPrintOutObject (
    def printf(format:String) {
        printf(format, array { self });
    }
    def print() {
        print(self.toString());
    }
    def println() {
        println(self.toString());
    }
)
