include "String.clcl"

class System
{
    def sprintf(format:String, prams:Array<Object>): native static String throws Exception;
}

class Clover
{
    def appendField(class_name:String, name:String, type:String):static native throws Exception;
    def appendMethod(class_name:String, code:String): static native throws Exception;
    def appendMethod(class_name:String, method_index:int, code:String): static native throws Exception;
    def appendClassField(class_name:String, name:String, type:String):static native throws Exception;
    def appendClass(code:String):static native throws Exception;
    def declareMethod(class_name:String, code:String): static native int throws Exception;

    def getField(class_name:String, index:int):static native Field throws Exception;
    def getClassField(class_name:String, index:int):static native Field throws Exception;
    def getMethod(class_name:String, index:int):static native Method throws Exception;
    def getClassFlags(class_name:String): static native long throws Exception;
    def getClassGenericsParamTypes(class_name:String): static native String[] throws Exception;
    def getClassGenericsParamNames(class_name:String): static native String[] throws Exception;
    def getNumFields(class_name:String): static native int throws Exception;
    def getNumClassFields(class_name:String): static native int throws Exception;
    def getNumMethods(class_name:String): static native int throws Exception;
    def isLoadedClass(class_name:String): static native bool throws Exception;
    def isDefinedClass(class_name:String): static native bool throws Exception;
    def createObject(class_name:String): static native Anonymous;
    def createArray(class_name:String, size:int): static native Anonymous;

    def isTypedefedClass(class_name:String, class_name2:String): static native bool;

    def isPrimitiveClass(name:String):static bool {
        return name.equals("int") || isTypedefedClass(name, "int") || name.equals("uint") || isTypedefedClass(name, "uint") || name.equals("byte") || isTypedefedClass(name, "byte") || name.equals("ubyte") || isTypedefedClass(name, "ubyte") || name.equals("short") || isTypedefedClass(name, "short") || name.equals("ushort") || isTypedefedClass(name, "ushort") || name.equals("long") || isTypedefedClass(name, "long") || name.equals("ulong") || isTypedefedClass(name, "ulong") || name.equals("float") || isTypedefedClass(name, "float") || name.equals("double") || isTypedefedClass(name, "double") || name.equals("pointer") || isTypedefedClass(name, "pointer") || name.equals("char") || isTypedefedClass(name, "char") ||  name.equals("bool") || isTypedefedClass(name, "bool") || name.match(/lambda$|lambda\(\)|lambda\(.*/) || isTypedefedClass(name, "lambda") || name.equals("regex")|| isTypedefedClass(name, "regex") ;
    }
    def primitiveClassToBoxingClass(name:String):static String {
        when(name) {
            case ("int") {
                return "Integer";
            }
            case ("uint") {
                return "UInteger";
            }
            case ("byte") {
                return "Byte";
            }
            case ("ubyte") {
                return "UByte";
            }
            case ("short") {
                return "Short";
            }
            case ("ushort") {
                return "UShort";
            }
            case ("long") {
                return "Long";
            }
            case ("ulong") {
                return "ULong";
            }
            case ("float") {
                return "Float";
            }
            case ("double") {
                return "Double";
            }
            case ("pointer") {
                return "Pointer";
            }
            case ("char") {
                return "Char";
            }
            case ("bool") {
                return "Bool";
            }

            else {
                return name;
            }
        }
    }
    def boxingClassToPrimitiveClass(name:String):static String {
        when(name) {
            case ("Integer") {
                return "int";
            }
            case ("UInteger") {
                return "uint";
            }
            case ("Byte") {
                return "byte";
            }
            case ("UByte") {
                return "ubyte";
            }
            case ("Short") {
                return "short";
            }
            case ("UShort") {
                return "ushort";
            }
            case ("Long") {
                return "long";
            }
            case ("ULong") {
                return "ulong";
            }
            case ("Float") {
                return "float";
            }
            case ("Double") {
                return "double";
            }
            case ("Pointer") {
                return "pointer";
            }
            case ("Char") {
                return "char";
            }
            case ("Bool") {
                return "bool";
            }

            else {
                return name;
            }
        }
    }


    def initialize_reflection(): static native;

    FIELD_FLAGS_PRIVATE:static long;
    FIELD_FLAGS_PROTECTED:static long;

    METHOD_FLAGS_NATIVE:static long;
    METHOD_FLAGS_CLASS_METHOD:static long;

    CLASS_FLAGS_PRIMITIVE:static long;
    CLASS_FLAGS_INTERFACE:static long;
    CLASS_FLAGS_MODIFIED:static long;
    CLASS_FLAGS_ALLOCATED:static long;
    CLASS_FLAGS_DYNAMIC_CLASS:static long;
    CLASS_FLAGS_NO_FREE_OBJECT:static long;

    def initialize():static {
        inherit();

        Clover.initialize_reflection();

        Clover.initializeMethodDefinedClasses = List<Class>();
        Clover.cloneMethodDefinedClasses = List<Class>();
        Clover.initializeMethodDefinedClassMethodIndexes = List<Integer>();
        Clover.cloneMethodDefinedClassMethodIndexes = List<Integer>();
        nothingMethodDefinedClasses = List<Class>();
        nothingMethodDefinedClassMethodIndexes = List<Integer>();
    }

    def getAllClassName(): static native String[];

    def getModifiedClass(): static EqualableList<Class> {
        result := EqualableList<Class>();

        getAllClassName().each {
            klass := Class(it);

            if((klass.flags & CLASS_FLAGS_MODIFIED).to_bool) {
                result.add(klass);
            }
        }

        return result;
    }

    initializeMethodDefinedClasses:static List<Class>;
    initializeMethodDefinedClassMethodIndexes:static List<Integer>;
    cloneMethodDefinedClasses:static List<Class>;
    cloneMethodDefinedClassMethodIndexes:static List<Integer>;
    nothingMethodDefinedClasses:static List<Class>;
    nothingMethodDefinedClassMethodIndexes:static List<Integer>;

    def compileTimeScriptingOnDeclareTime():static {
        getModifiedClass().each {
            if((it.flags & CLASS_FLAGS_INTERFACE).to_bool) {
                if(it.getMethod("initialize", 0, false).identifyWith(null)) {
                    it.declareMethod("def initialize();");
                }
                if(it.getMethod("clone", 0, false).identifyWith(null)) {
                    it.declareMethod("def clone(): Self;");
                }
                if(it.getMethod("nothing", 0, false).identifyWith(null)) {
                    it.declareMethod("def nothing(): Self;");
                }
            }
            else {
                if(it.getMethod("initialize", 0, false).identifyWith(null)) {
                    method_index := it.declareMethod("def initialize();");
                    initializeMethodDefinedClasses.add(it);
                    initializeMethodDefinedClassMethodIndexes.add(method_index);
                }
                if(it.getMethod("nothing", 0, false).identifyWith(null)) {
                    method_index := it.declareMethod(
                        """
                        def nothing(): \{it.className} \{
                            output := "";

                            if(it.genericsParamNames.length > 0) {
                                output.append("<");
                                for(i:=0; i<it.genericsParamNames.length; i++) {
                                    output.append(it.genericsParamNames[i]);

                                    if(i != it.genericsParamNames.length-1) {
                                        output.append(",");
                                    }
                                }
                                output.append(">");
                            }

                            output;
                            };
                        """
                    );
                    nothingMethodDefinedClasses.add(it);
                    nothingMethodDefinedClassMethodIndexes.add(method_index);
                }
                if(it.getMethod("clone", 0, false).identifyWith(null)) {
                    method_index := it.declareMethod(
                        """
                        def clone(): \{it.className} \{
                            output := "";

                            if(it.genericsParamNames.length > 0) {
                                output.append("<");
                                for(i:=0; i<it.genericsParamNames.length; i++) {
                                    output.append(it.genericsParamNames[i]);

                                    if(i != it.genericsParamNames.length-1) {
                                        output.append(",");
                                    }
                                }
                                output.append(">");
                            }

                            output;
                            };
                        """
                    );

                    cloneMethodDefinedClasses.add(it);
                    cloneMethodDefinedClassMethodIndexes.add(method_index);
                }
            }
        }
    }

    def compileTimeScripting():static {
        n := 0;
        initializeMethodDefinedClasses.each {
            method_index := initializeMethodDefinedClassMethodIndexes.items(n);
            try {
                it.appendMethod(method_index, 
                    """
                    def initialize() {
                        \{
                            output := "";
                            for(i:=0; i<it.numFields; i++) {
                                field := it.getField(i);

                                class_name:String? = null;
                                if(field.resultType.match(/^GenericsParametorClass\d+$/)) {
                                    generics_param_num := field.resultType.scan(/^GenericsParametorClass(\d+)/).items(0).to_int();
                                    
                                    class_name = it.genericsParamTypes[generics_param_num];
                                }
                                else {
                                    class_name = field.resultType;
                                }

                                if(class_name.length() > 1 && class_name.chars(-1) == '?') {
                                    class_name = class_name.subString(0,-2);
                                }

                                is_array := false;
                                if(class_name.length() > 2 && class_name.chars(-2) == '[' && class_name.chars(-1) == ']') 
                                {
                                    class_name = class_name.subString(0, -3);
                                    is_array = true;
                                }

                                if(class_name.match(/.+<.+>/)) {
                                    class_name = class_name.scan(/(.+)<.+>/).items(1);
                                }

                                if(class_name.match(/lambda$|lambda\(\)|lambda\(.*/)) {
                                    class_name = "lambda"
                                }

                                klass := Class(class_name);

                                is_primitive := isPrimitiveClass(class_name);

                                is_interface := (Class(class_name).flags & CLASS_FLAGS_INTERFACE).to_bool;

                                if(!is_array && !is_primitive && !is_interface)
                                {
                                   output.append(sprintf("self.%s = %s();\n", array { field.name, class_name }));
                                }
                            }
                            output;
                        }
                    }
                    """
                );
            } catch(e:Exception) {
                println("Exception on compile time. \{it.className()}.initialize() can't be defined");
            }
            n++;
        }

        n = 0;
        nothingMethodDefinedClasses.each {
            method_index := nothingMethodDefinedClassMethodIndexes.items(n);
            try {
                it.appendMethod(method_index, "def nothing(): \{it.className} { return self }");
            } catch(e:Exception) {
                println("Exception on compile time. \{it.className()}.nothing() can't be defined");
            }
            n++;
        }

        n = 0;
        cloneMethodDefinedClasses.each {
            class_name := it.className.clone();

            method_index := cloneMethodDefinedClassMethodIndexes.items(n);

            if(it.genericsParamNames.length > 0) {
                class_name.append("<");
                for(i:=0; i<it.genericsParamNames.length; i++) {
                    class_name.append(it.genericsParamNames[i]);

                    if(i != it.genericsParamNames.length-1) {
                        class_name.append(",");
                    }
                }
                class_name.append(">");
            }

            code := "";

            try {
                code = """
                       def clone(): \{class_name}
                       {
                           result := \{class_name}();
                           
                           \{
                               output := "";
                               for(i:=0; i<it.numFields; i++) {
                                   field := it.getField(i);

                                   class_name := field.resultType.clone();

                                   if(class_name.match(/\?/)) {
                                       class_name = class_name.sub(/\?/, "");
                                   }

                                   is_array := false;
                                   class_name_for_array := "";
                                   if(class_name.match(/^lambda\[\].*$/)) {
                                       class_name_for_array = class_name.clone();
                                       class_name = "lambda"
                                       is_array = true;
                                   }
                                   elif(class_name.match(/^lambda$|^lambda\(\)|^lambda\(.*/)) {
                                       class_name = "lambda"
                                       is_array = false;
                                   }
                                   elif(class_name.match(/^.+<.+>\[\]$/)) {
                                       class_name_for_array = class_name.scan(/(.+<.+>)\[\]/).items(1).clone();
                                       class_name = class_name.scan(/(.+)<.+>\[\]/).items(1);
                                       is_array = true;
                                   }
                                   elif(class_name.match(/^.+<.+>$/)) {
                                       class_name = class_name.scan(/(.+)<.+>/).items(1);
                                       is_array = false;
                                   }
                                   elif(class_name.length() > 2 && class_name.chars(-2) == '[' && class_name.chars(-1) == ']') 
                                   {
                                       class_name = class_name.subString(0, -3);
                                       class_name_for_array = class_name.clone();
                                       is_array = true;
                                   }

                                   klass := Class(class_name);

                                   is_primitive := isPrimitiveClass(class_name);
                                   is_interface := (klass.flags & CLASS_FLAGS_INTERFACE).to_bool;
                                   clone_method_existance := !klass.getMethod("clone", 0, false).identifyWith(null);
                                   
                                   if(is_array && class_name.equals("lambda")) {
                                       class_name2 := class_name_for_array.scan(/lambda\[\](.*)$/).items(1);

                                       output.append(sprintf("if(!self.%s.identifyWith(null)) {", array { field.name }));
                                       output.append(sprintf("result.%s = new lambda[self.%s.length]%s();\n", array { field.name, field.name, class_name2 }));

                                       if(is_primitive || !clone_method_existance)
                                       {
                                           output.append(sprintf("for(i:=0; i<self.%s.length; i++) { result.%s[i] = self.%s[i]; }", array { field.name, field.name, field.name }));
                                       }
                                       else {
                                           output.append(sprintf("for(i:=0; i<self.%s.length; i++) { if(!self.%s[i].identifyWith(null)) { result.%s[i] = self.%s[i].toAnonymous().clone(); } }", array { field.name, field.name, field.name, field.name }));
                                       }

                                       output.append("}");
                                   }
                                   elif(is_array) {
                                       output.append(sprintf("if(!self.%s.identifyWith(null)) {", array { field.name }));
                                       output.append(sprintf("result.%s = %s[self.%s.length]();\n", array { field.name, class_name_for_array, field.name}));

                                       if(is_primitive || !clone_method_existance)
                                       {
                                           output.append(sprintf("for(i:=0; i<self.%s.length; i++) { result.%s[i] = self.%s[i]; }", array { field.name, field.name, field.name }));
                                       }
                                       else {
                                           output.append(sprintf("for(i:=0; i<self.%s.length; i++) { if(!self.%s[i].identifyWith(null)) { result.%s[i] = self.%s[i].toAnonymous().clone(); } }", array { field.name, field.name, field.name, field.name }));
                                       }

                                       output.append("}");
                                   }
                                   elif(is_primitive || !clone_method_existance)
                                   {
                                       output.append(sprintf("result.%s = self.%s;\n", array { field.name, field.name }));
                                   }
                                   else {
                                       output.append(sprintf("if(!self.%s.identifyWith(null)) {", array { field.name }));
                                       output.append(sprintf("result.%s = self.%s.toAnonymous().clone();\n", array { field.name, field.name }));
                                       output.append("}");
                                   }
                               }

                               output;
                           }

                           return result;
                       }
                       """;
            }
            catch(e:Exception) {
                println("Exception on compile time. \{class_name}.clone() can't be defined");

                code = "def clone(): \{class_name} { self }";
            }

            it.appendMethod(method_index, code);

            n++;
        }
    }
}

class Field
{
    include MObjectBase;

    flags:long;
    name:String;
    resultType:String;
    #value:Anonymous;

    def initialize() {}

    def clone():Field {
        result := Field();

        result.flags = self.flags;
        if(self.name.identifyWith(null).negative()) {
            result.name = self.name.clone();
        }
        if(self.resultType.identifyWith(null).negative()) {
            result.resultType = self.resultType.clone();
        }

        return result;
    }

    def private():bool {
        return (self.flags & Clover.FIELD_FLAGS_PRIVATE).to_bool;
    }

    def protected():bool {
        return (self.flags & Clover.FIELD_FLAGS_PROTECTED).to_bool;
    }
}

class MethodParam
{
    include MObjectBase;

    name:String;
    type:String;

    def initialize() {}

    def clone(): MethodParam {
        result := MethodParam();

        if(self.name.identifyWith(null).negative()) {
            result.name = self.name.clone();
        }
        if(self.type.identifyWith(null).negative()) {
            result.type = self.type.clone();
        }

        return result;
    }
}

class Method
{
    include MObjectBase;

    flags:long;
    name:String;
    path:String;
    methodNameAndParams:String;
    index:int;

    params:MethodParam[];

    resultType:String;

    varNum:int;

    genericsParamTypes:String[];

    def initialize() {}

    def clone(): Method {
        result := Method();

        result.flags = self.flags;
        if(self.name.identifyWith(null).negative()) {
            result.name = self.name.clone();
        }
        if(self.path.identifyWith(null).negative()) {
            result.path = self.path.clone();
        }
        if(self.methodNameAndParams.identifyWith(null).negative()) {
            result.methodNameAndParams = self.methodNameAndParams.clone();
        }
        result.index = self.index;

        if(self.params.identifyWith(null).negative()) {
            result.params = MethodParam[self.params.length]();
            for(i:=0; i<self.params.length; i++) {
                result.params[i] = self.params[i].clone();
            }
        }

        if(self.resultType.identifyWith(null).negative()) {
            result.resultType = self.resultType.clone();
        }
        result.varNum = self.varNum;

        if(self.genericsParamTypes.identifyWith(null).negative()) {
            result.genericsParamTypes = String[self.genericsParamTypes.length]();

            for(j:=0; j<self.genericsParamTypes.length; j++) {
                result.genericsParamTypes[j] = self.genericsParamTypes[j].clone();
            }
        }

        return result;
    }

    def toString():String {
        return methodNameAndParams;
    }
}

class Class
{
    include MObjectBase;

    className:String;
    flags:long;
    genericsParamTypes:String[];
    genericsParamNames:String[];
    numFields:int;
    numClassFields:int;
    numMethods:int;

    def initialize() {}

    def initialize(class_name:String) {
        className = class_name;
        flags = Clover.getClassFlags(class_name);
        genericsParamTypes = Clover.getClassGenericsParamTypes(class_name);
        genericsParamNames = Clover.getClassGenericsParamNames(class_name);
        numFields = Clover.getNumFields(class_name);
        numClassFields = Clover.getNumClassFields(class_name);
        numMethods = Clover.getNumMethods(class_name);
    }

    def clone():Class {
        result := Class();

        if(self.className.identifyWith(null).negative()) {
            result.className = self.className.clone();
        }
        result.flags = self.flags;
        if(self.genericsParamTypes.identifyWith(null).negative()) {
            result.genericsParamTypes = String[self.genericsParamTypes.length]();
            for(i:=0; i<self.genericsParamTypes.length; i++) {
                result.genericsParamTypes[i] = self.genericsParamTypes[i].clone();
            }
        }
        if(self.genericsParamNames.identifyWith(null).negative()) {
            result.genericsParamNames = String[self.genericsParamNames.length]();
            for(j:=0; j<self.genericsParamNames.length; j++) {
                result.genericsParamNames[j] = self.genericsParamNames[j].clone();
            }
        }
        result.numFields = self.numFields;
        result.numClassFields = self.numClassFields;
        result.numMethods = self.numMethods;

        return result;
    }

    def equals(right:Class): bool {
        return self.className.equals(right.className);
    }

    def toString(): String {
        return self.className;
    }

    def appendField(name:String, type:String) {
        Clover.appendField(className, name, type);
    }
    def appendMethod(code:String) {
        Clover.appendMethod(className, code);
    }
    def appendMethod(method_index:int, code:String) {
        Clover.appendMethod(className, method_index, code);
    }
    def declareMethod(code:String):int {
        return Clover.declareMethod(className, code);
    }
    def appendClassField(name:String, type:String) {
        Clover.appendClassField(className, name, type);
    }
    def getField(index:int): Field {
        return Clover.getField(className, index);
    }
    def getField(name:String): Field? {
        for(i:=0; i<numFields; i++) {
            field := getField(i);

            if(field.name.equals(name)) {
                return field;
            }
        }

        return null;
    }
    def getClassField(index:int): Field {
        return Clover.getClassField(className, index);
    }
    def getClassField(name:String): Field? {
        for(i:=0; i<numClassFields; i++) {
            field := getClassField(i);

            if(field.name.equals(name)) {
                return field;
            }
        }

        return null;
    }
    def getMethod(index:int): Method {
        return Clover.getMethod(className, index);
    }
    def getMethod(name:String): Method? {
        for(i:=numMethods-1; i>=0; i--) { # reverse search for multiple definition
            method := getMethod(i);

            if(method.name.equals(name)) {
                return method;
            }
        }

        return null;
    }
    def getMethod(name:String, param_num:int, class_method:bool): Method? {
        for(i:=numMethods-1; i>=0; i--) { # reverse search for multiple definition
            method := getMethod(i);

            if(method.name.equals(name) && method.params.length == param_num
                && class_method == (method.flags & Clover.METHOD_FLAGS_CLASS_METHOD).to_bool) 
            {
                return method;
            }
        }

        return null;
    }
    def getMethods():List<Method> {
        result := List<Method>();
        for(i:=0; i<numMethods; i++) {
            result.add(getMethod(i));
        }
        return result;
    }
    def createObject(): Anonymous {
        return Clover.createObject(className);
    }
    def createArray(size:int): Anonymous {
        return Clover.createArray(className, size);
    }

    def isInterface():bool {
        return (self.flags & Clover.CLASS_FLAGS_INTERFACE).to_bool;
    }
}
