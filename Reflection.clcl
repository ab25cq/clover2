include "Fundamental.clcl"

class System
{
    def sprintf(format:String, prams:Array<Object>): native static String throws Exception;
}

class Clover
{
    def appendField(class_name:String, name:String, type:String):static native throws Exception;
    def appendMethod(class_name:String, code:String): static native throws Exception;
    def appendClassField(class_name:String, name:String, type:String):static native throws Exception;
    def getField(class_name:String, index:int):static native Field throws Exception;
    def getClassField(class_name:String, index:int):static native Field throws Exception;
    def getMethod(class_name:String, index:int):static native Method throws Exception;
    def getClassFlags(class_name:String): static native long throws Exception;
    def getClassGenericsParamTypes(class_name:String): static native String[] throws Exception;
    def getClassGenericsParamNames(class_name:String): static native String[] throws Exception;
    def getNumFields(class_name:String): static native int throws Exception;
    def getNumClassFields(class_name:String): static native int throws Exception;
    def getNumMethods(class_name:String): static native int throws Exception;
    def isLoadedClass(class_name:String): static native bool throws Exception;
    def isDefinedClass(class_name:String): static native bool throws Exception;
    def appendClass(code:String):static native throws Exception;

    def initialize_reflection(): static native;

    FIELD_FLAGS_PRIVATE:static long;
    FIELD_FLAGS_PROTECTED:static long;

    CLASS_FLAGS_PRIMITIVE:static long;
    CLASS_FLAGS_INTERFACE:static long;
    CLASS_FLAGS_MODIFIED:static long;
    CLASS_FLAGS_ALLOCATED:static long;
    CLASS_FLAGS_DYNAMIC_CLASS:static long;
    CLASS_FLAGS_NO_FREE_OBJECT:static long;

    def initialize():static {
        inherit();

        Clover.initialize_reflection();
    }
}

class Field
{
    flags:long;
    name:String;
    resultType:String;
    #value:Anonymous;

    def private():bool {
        return (self.flags & Clover.FIELD_FLAGS_PRIVATE).to_bool;
    }

    def protected():bool {
        return (self.flags & Clover.FIELD_FLAGS_PROTECTED).to_bool;
    }
}

class MethodParam
{
    name:String;
    type:String;
}

class Method
{
    flags:long;
    name:String;
    path:String;
    methodNameAndParams:String;
    index:int;

    params:MethodParam[];

    resultType:String;

    varNum:int;

    genericsParamTypes:String[];
}

class Class
{
    className:String;
    flags:long;
    genericsParamTypes:String[];
    genericsParamNames:String[];
    numFields:int;
    numClassFields:int;
    numMethods:int;

    def initialize(class_name:String) {
        className = class_name;
        flags = Clover.getClassFlags(class_name);
        genericsParamTypes = Clover.getClassGenericsParamTypes(class_name);
        genericsParamNames = Clover.getClassGenericsParamNames(class_name);
        numFields = Clover.getNumFields(class_name);
        numClassFields = Clover.getNumClassFields(class_name);
        numMethods = Clover.getNumMethods(class_name);
    }

    def appendField(name:String, type:String) {
        Clover.appendField(className, name, type);
    }
    def appendMethod(code:String) {
        Clover.appendMethod(className, code);
    }
    def appendClassField(name:String, type:String) {
        Clover.appendClassField(className, name, type);
    }
    def getField(index:int): Field {
        return Clover.getField(className, index);
    }
    def getField(name:String): Field? {
        for(i:=0; i<numFields; i++) {
            field := getField(i);

            if(field.name.equals(name)) {
                return field;
            }
        }

        return null;
    }
    def getClassField(index:int): Field {
        return Clover.getClassField(className, index);
    }
    def getClassField(name:String): Field? {
        for(i:=0; i<numClassFields; i++) {
            field := getClassField(i);

            if(field.name.equals(name)) {
                return field;
            }
        }

        return null;
    }
    def getMethod(index:int): Method {
        return Clover.getMethod(className, index);
    }
    def getMethod(name:String): Method? {
        for(i:=numMethods-1; i>=0; i--) { # reverse search for multiple definition
            method := getMethod(i);

            if(method.name.equals(name)) {
                return method;
            }
        }

        return null;
    }
}
