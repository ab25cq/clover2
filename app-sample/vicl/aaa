# 1 "<stdin>"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 365 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "<stdin>" 2
# 1 "./common.h" 1







# 1 "./config.h" 1
# 9 "./common.h" 2

# 1 "/data/data/com.termux/files/usr/include/string.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/string.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 1 3 4
# 40 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/api-level.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/android/api-level.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/android/api-level.h" 2 3 4
# 41 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/android/versioning.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/string.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 51 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 62 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 90 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 118 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/__stddef_max_align_t.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/__stddef_max_align_t.h" 3 4
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 119 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/string.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/xlocale.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/xlocale.h" 3 4
struct __locale_t;
typedef struct __locale_t* locale_t;
# 35 "/data/data/com.termux/files/usr/include/string.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/strcasecmp.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/bits/strcasecmp.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/types.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdint.h" 1 3 4
# 63 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/stdint.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/wchar_limits.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/stdint.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/stdint.h" 2 3 4


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long __int64_t;
typedef unsigned long __uint64_t;






typedef long __intptr_t;
typedef unsigned long __uintptr_t;





typedef __int8_t int8_t;
typedef __uint8_t uint8_t;

typedef __int16_t int16_t;
typedef __uint16_t uint16_t;

typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;

typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;

typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef uint8_t uint_fast8_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef int64_t int_fast16_t;
typedef uint64_t uint_fast16_t;
typedef int64_t int_fast32_t;
typedef uint64_t uint_fast32_t;







typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 64 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdint.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/linux/types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/types.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/bitsperlong.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/bitsperlong.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/bitsperlong.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 2 3 4

typedef __signed__ char __s8;
typedef unsigned char __u8;
typedef __signed__ short __s16;
typedef unsigned short __u16;
typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 22 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/types.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/types.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/stddef.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/linux/stddef.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/compiler_types.h" 1 3 4




# 1 "/data/data/com.termux/files/usr/include/linux/compiler.h" 1 3 4
# 6 "/data/data/com.termux/files/usr/include/linux/compiler_types.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/linux/stddef.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 2 3 4


typedef struct {
  unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;
typedef void(* __kernel_sighandler_t) (int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/posix_types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/posix_types.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


# 1 "/data/data/com.termux/files/usr/include/asm-generic/posix_types.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;


typedef __kernel_ulong_t __kernel_ino_t;


typedef unsigned int __kernel_mode_t;


typedef int __kernel_pid_t;


typedef int __kernel_ipc_pid_t;


typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;


typedef __kernel_long_t __kernel_suseconds_t;


typedef int __kernel_daddr_t;


typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;






typedef unsigned int __kernel_old_dev_t;







typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;



typedef struct {
  int val[2];
} __kernel_fsid_t;

typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 25 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/posix_types.h" 2 3 4
# 31 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 2 3 4
# 24 "/data/data/com.termux/files/usr/include/linux/types.h" 2 3 4


typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;






typedef unsigned __poll_t;
# 37 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/types.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 2 3 4

typedef struct {
  uint32_t flags;
  void* stack_base;
  size_t stack_size;
  size_t guard_size;
  int32_t sched_policy;
  int32_t sched_priority;

  char __reserved[16];

} pthread_attr_t;
# 61 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
typedef struct {

  int32_t __private[12];



} pthread_cond_t;

typedef long pthread_condattr_t;

typedef int pthread_key_t;

typedef struct {

  int32_t __private[10];



} pthread_mutex_t;

typedef long pthread_mutexattr_t;

typedef int pthread_once_t;

typedef struct {

  int32_t __private[14];



} pthread_rwlock_t;

typedef long pthread_rwlockattr_t;
# 105 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
typedef long pthread_t;
# 40 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint64_t ino64_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;





typedef uint64_t dev_t;



typedef __kernel_time_t __time_t;
typedef __time_t time_t;




typedef int64_t off_t;
typedef off_t loff_t;
typedef loff_t off64_t;
# 115 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
typedef uint32_t __socklen_t;

typedef __socklen_t socklen_t;

typedef __builtin_va_list __va_list;
# 128 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
typedef __kernel_ssize_t ssize_t;


typedef unsigned int uint_t;
typedef unsigned int uint;


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 34 "/data/data/com.termux/files/usr/include/bits/strcasecmp.h" 2 3 4




int strcasecmp(const char* __s1, const char* __s2) __attribute__((__pure__));





int strncasecmp(const char* __s1, const char* __s2, size_t __n) __attribute__((__pure__));
# 37 "/data/data/com.termux/files/usr/include/string.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/include/strings.h" 1 3 4
# 58 "/data/data/com.termux/files/usr/include/strings.h" 3 4
int ffs(int __i) __attribute__((annotate("introduced_in_x86=" "18")));





# 1 "/data/data/com.termux/files/usr/include/android/legacy_strings_inlines.h" 1 3 4
# 64 "/data/data/com.termux/files/usr/include/strings.h" 2 3 4
# 42 "/data/data/com.termux/files/usr/include/string.h" 2 3 4


void* memccpy(void* __dst, const void* __src, int __stop_char, size_t __n);
void* memchr(const void* __s, int __ch, size_t __n) __attribute__((__pure__));




void* memrchr(const void* __s, int __ch, size_t __n) __attribute__((__pure__));

int memcmp(const void* __lhs, const void* __rhs, size_t __n) __attribute__((__pure__));
void* memcpy(void*, const void*, size_t);







void* memmove(void* __dst, const void* __src, size_t __n);
void* memset(void* __dst, int __ch, size_t __n);
void* memmem(const void* __haystack, size_t __haystack_size, const void* __needle, size_t __needle_size) __attribute__((__pure__));

char* strchr(const char* __s, int __ch) __attribute__((__pure__));


char* __strchr_chk(const char* __s, int __ch, size_t __n) __attribute__((annotate("introduced_in=" "18")));
# 88 "/data/data/com.termux/files/usr/include/string.h" 3 4
char* strrchr(const char* __s, int __ch) __attribute__((__pure__));


char* __strrchr_chk(const char* __s, int __ch, size_t __n) __attribute__((annotate("introduced_in=" "18")));



size_t strlen(const char* __s) __attribute__((__pure__));


size_t __strlen_chk(const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "17")));



int strcmp(const char* __lhs, const char* __rhs) __attribute__((__pure__));


char* stpcpy(char* __dst, const char* __src) __attribute__((annotate("introduced_in=" "21")));


char* strcpy(char* __dst, const char* __src);
char* strcat(char* __dst, const char* __src);
char* strdup(const char* __s);

char* strstr(const char* __haystack, const char* __needle) __attribute__((__pure__));




char* strcasestr(const char* __haystack, const char* __needle) __attribute__((__pure__));

char* strtok(char* __s, const char* __delimiter);
char* strtok_r(char* __s, const char* __delimiter, char** __pos_ptr);

char* strerror(int __errno_value);
# 131 "/data/data/com.termux/files/usr/include/string.h" 3 4
int strerror_r(int __errno_value, char* __buf, size_t __n);


size_t strnlen(const char* __s, size_t __n) __attribute__((__pure__));
char* strncat(char* __dst, const char* __src, size_t __n);
char* strndup(const char* __s, size_t __n);
int strncmp(const char* __lhs, const char* __rhs, size_t __n) __attribute__((__pure__));


char* stpncpy(char* __dst, const char* __src, size_t __n) __attribute__((annotate("introduced_in=" "21")));


char* strncpy(char* __dst, const char* __src, size_t __n);

size_t strlcat(char* __dst, const char* __src, size_t __n);
size_t strlcpy(char* __dst, const char* __src, size_t __n);

size_t strcspn(const char* __s, const char* __reject) __attribute__((__pure__));
char* strpbrk(const char* __s, const char* __accept) __attribute__((__pure__));
char* strsep(char** __s_ptr, const char* __delimiter);
size_t strspn(const char* __s, const char* __accept);

char* strsignal(int __signal);

int strcoll(const char* __lhs, const char* __rhs) __attribute__((__pure__));
size_t strxfrm(char* __dst, const char* __src, size_t __n);


int strcoll_l(const char* __lhs, const char* __rhs, locale_t __l) __attribute__((__pure__)) __attribute__((annotate("introduced_in=" "21")));
size_t strxfrm_l(char* __dst, const char* __src, size_t __n, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
# 11 "./common.h" 2
# 1 "/data/data/com.termux/files/usr/include/stdlib.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/alloca.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/wait.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/bits/wait.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/wait.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/bits/wait.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/malloc.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/malloc.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/malloc.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/stdio.h" 1 3 4
# 44 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdarg.h" 1 3 4
# 30 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 45 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 46 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/fcntl.h" 1 3 4
# 25 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/fcntl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 1 3 4
# 121 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 3 4
struct f_owner_ex {
  int type;
  __kernel_pid_t pid;
};
# 148 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 3 4
struct flock {
  short l_type;
  short l_whence;
  __kernel_off_t l_start;
  __kernel_off_t l_len;
  __kernel_pid_t l_pid;

};





struct flock64 {
  short l_type;
  short l_whence;
  __kernel_loff_t l_start;
  __kernel_loff_t l_len;
  __kernel_pid_t l_pid;

};
# 26 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/fcntl.h" 2 3 4
# 49 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/seek_constants.h" 1 3 4
# 51 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 3 4
struct __sbuf {
 unsigned char* _base;
 size_t _size;
};
# 49 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 3 4
typedef int64_t _struct_file_off_t;




struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;

 int _flags;
 int _file;




 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 _struct_file_off_t (*_seek)(void *, _struct_file_off_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ext;

 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 _struct_file_off_t _offset;
};
# 53 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4



typedef off_t fpos_t;
typedef off64_t fpos64_t;

struct __sFILE;
typedef struct __sFILE FILE;
# 73 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
extern FILE __sF[] __attribute__((annotate("obsoleted_in=" "23")));
# 107 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
void clearerr(FILE* __fp);
int fclose(FILE* __fp);
int feof(FILE* __fp);
int ferror(FILE* __fp);
int fflush(FILE* __fp);
int fgetc(FILE* __fp);
char* fgets(char* __buf, int __size, FILE* __fp);
int fprintf(FILE* __fp , const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
int fputc(int __ch, FILE* __fp);
int fputs(const char* __s, FILE* __fp);
size_t fread(void* __buf, size_t __size, size_t __count, FILE* __fp);
int fscanf(FILE* __fp, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
size_t fwrite(const void* __buf, size_t __size, size_t __count, FILE* __fp);
int getc(FILE* __fp);
int getchar(void);


ssize_t getdelim(char** __line_ptr, size_t* __line_length_ptr, int __delimiter, FILE* __fp) __attribute__((annotate("introduced_in=" "18")));
ssize_t getline(char** __line_ptr, size_t* __line_length_ptr, FILE* __fp) __attribute__((annotate("introduced_in=" "18")));



void perror(const char* __msg);
int printf(const char* __fmt, ...) __attribute__((__format__(printf, 1, 2)));
int putc(int __ch, FILE* __fp);
int putchar(int __ch);
int puts(const char* __s);
int remove(const char* __path);
void rewind(FILE* __fp);
int scanf(const char* __fmt, ...) __attribute__((__format__(scanf, 1, 2)));
void setbuf(FILE* __fp, char* __buf);
int setvbuf(FILE* __fp, char* __buf, int __mode, size_t __size);
int sscanf(const char* __s, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
int ungetc(int __ch, FILE* __fp);
int vfprintf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
int vprintf(const char* __fp, va_list __args) __attribute__((__format__(printf, 1, 0)));


int dprintf(int __fd, const char* __fmt, ...) __attribute__((__format__(printf, 2, 3))) __attribute__((annotate("introduced_in=" "21")));
int vdprintf(int __fd, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0))) __attribute__((annotate("introduced_in=" "21")));
# 163 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int sprintf(char* __s, const char* __fmt, ...)
    __attribute__((__format__(printf, 2, 3))) ;
int vsprintf(char* __s, const char* __fmt, va_list __args)
    __attribute__((__format__(printf, 2, 0))) ;
char* tmpnam(char* __s)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));

char* tempnam(const char* __dir, const char* __prefix)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));

int rename(const char* __old_path, const char* __new_path);
int renameat(int __old_dir_fd, const char* __old_path, int __new_dir_fd, const char* __new_path);

int fseek(FILE* __fp, long __offset, int __whence);
long ftell(FILE* __fp);
# 201 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int fgetpos(FILE* __fp, fpos_t* __pos);
int fsetpos(FILE* __fp, const fpos_t* __pos);
int fseeko(FILE* __fp, off_t __offset, int __whence);
off_t ftello(FILE* __fp);

FILE* funopen(const void* __cookie,
              int (*__read_fn)(void*, char*, int),
              int (*__write_fn)(void*, const char*, int),
              fpos_t (*__seek_fn)(void*, fpos_t, int),
              int (*__close_fn)(void*));
# 233 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
FILE* fopen(const char* __path, const char* __mode);





FILE* freopen(const char* __path, const char* __mode, FILE* __fp);
# 250 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int snprintf(char* __buf, size_t __size, const char* __fmt, ...) __attribute__((__format__(printf, 3, 4)));
int vfscanf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
int vscanf(const char* __fmt , va_list __args) __attribute__((__format__(scanf, 1, 0)));
int vsnprintf(char* __buf, size_t __size, const char* __fmt, va_list __args) __attribute__((__format__(printf, 3, 0)));
int vsscanf(const char* __s, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));







static __inline__ char* ctermid(char* s) {
 if (s == 0) return (char*) "/dev/tty";
 strcpy(s, "/dev/tty");
 return s;
}

FILE* fdopen(int __fd, const char* __mode);
int fileno(FILE* __fp);
int pclose(FILE* __fp);
FILE* popen(const char* __command, const char* __mode);
void flockfile(FILE* __fp);
int ftrylockfile(FILE* __fp);
void funlockfile(FILE* __fp);
int getc_unlocked(FILE* __fp);
int getchar_unlocked(void);
int putc_unlocked(int __ch, FILE* __fp);
int putchar_unlocked(int __ch);
# 288 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int asprintf(char** __s_ptr, const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
char* fgetln(FILE* __fp, size_t* __length_ptr);
int fpurge(FILE* __fp);
void setbuffer(FILE* __fp, char* __buf, int __size);
int setlinebuf(FILE* __fp);
int vasprintf(char** __s_ptr, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
# 335 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int open(const char*, int, ...);
extern pid_t getpid();
extern int unlink(const char*);
void free(void* p);
uint32_t arc4random(void);
static __inline__ FILE* tmpfile() {
 int p = getpid();
 char* path;
 int i;
 for (i = 0; i < 100; i++) {
  unsigned int r = arc4random();
  if (asprintf(&path, "/data/data/com.termux/files/usr/tmp/tmpfile.%d-%u", p, r) == -1) return ((void*)0);
  int fd = open(path, 00000002 | 00000100 | 00000200 | 0400000, 0600);
  free(path);
  if (fd >= 0) {
   FILE* result = fdopen(fd, "w+");
   unlink(path);
   return result;
  }
 }
 return ((void*)0);
}
# 23 "/data/data/com.termux/files/usr/include/malloc.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/malloc.h" 3 4
void* malloc(size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(1))) __attribute__((__warn_unused_result__));
void* calloc(size_t __item_count, size_t __item_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2))) __attribute__((__warn_unused_result__));
void* realloc(void* __ptr, size_t __byte_count) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
void free(void* __ptr);

void* memalign(size_t __alignment, size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));


size_t malloc_usable_size(const void* __ptr) __attribute__((annotate("introduced_in=" "17")));





struct mallinfo {
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};


struct mallinfo mallinfo(void);
# 35 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 45 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
__attribute__((__noreturn__)) void abort(void);
__attribute__((__noreturn__)) void exit(int __status);

__attribute__((__noreturn__)) void _Exit(int __status) __attribute__((annotate("introduced_in=" "21")));




int atexit(void (*__fn)(void));



int at_quick_exit(void (*__fn)(void)) __attribute__((annotate("introduced_in=" "21")));
void quick_exit(int __status) __attribute__((__noreturn__)) __attribute__((annotate("introduced_in=" "21")));



char* getenv(const char* __name);
int putenv(char* __assignment);
int setenv(const char* __name, const char* __value, int __overwrite);
int unsetenv(const char* __name);
int clearenv(void);

char* mkdtemp(char* __template);
char* mktemp(char* __template) __attribute__((deprecated("mktemp is unsafe, use mkstemp or tmpfile instead")));
# 81 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
int mkstemp64(char* __template) __attribute__((annotate("introduced_in=" "21")));


int mkstemp(char* __template);





int mkstemps(char* __template, int __flags);

long strtol(const char* __s, char** __end_ptr, int __base);
long long strtoll(const char* __s, char** __end_ptr, int __base);
unsigned long strtoul(const char* __s, char** __end_ptr, int __base);
unsigned long long strtoull(const char* __s, char** __end_ptr, int __base);



int posix_memalign(void** __memptr, size_t __alignment, size_t __size) __attribute__((annotate("introduced_in=" "17")));
# 109 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
double strtod(const char* __s, char** __end_ptr);
long double strtold(const char* __s, char** __end_ptr) __attribute__((annotate("introduced_in=" "21")));







int atoi(const char* __s) __attribute__((__pure__));
long atol(const char* __s) __attribute__((__pure__));
long long atoll(const char* __s) __attribute__((__pure__));

char* realpath(const char* __path, char* __resolved);
int system(const char* __command);

void* bsearch(const void* __key, const void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

void qsort(void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

uint32_t arc4random(void);
uint32_t arc4random_uniform(uint32_t __upper_bound);
void arc4random_buf(void* __buf, size_t __n);





int rand_r(unsigned int* __seed_ptr) __attribute__((annotate("introduced_in=" "21")));



double drand48(void);
double erand48(unsigned short __xsubi[3]);
long jrand48(unsigned short __xsubi[3]);





long lrand48(void);
long mrand48(void);
long nrand48(unsigned short __xsubi[3]);
unsigned short* seed48(unsigned short __seed16v[3]);
void srand48(long __seed);



char* initstate(unsigned int __seed, char* __state, size_t __n) __attribute__((annotate("introduced_in=" "21")));
char* setstate(char* __state) __attribute__((annotate("introduced_in=" "21")));



int getpt(void);


int posix_openpt(int __flags) __attribute__((annotate("introduced_in=" "21")));


char* ptsname(int __fd);
int ptsname_r(int __fd, char* __buf, size_t __n);
int unlockpt(int __fd);







typedef struct {
  int quot;
  int rem;
} div_t;

div_t div(int __numerator, int __denominator) __attribute__((__const__));

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

ldiv_t ldiv(long __numerator, long __denominator) __attribute__((__const__));

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

lldiv_t lldiv(long long __numerator, long long __denominator) __attribute__((__const__));




const char* getprogname(void) __attribute__((annotate("introduced_in=" "21")));
void setprogname(const char* __name) __attribute__((annotate("introduced_in=" "21")));



int mblen(const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "26"))) __attribute__((annotate("versioner_no_guard")));
size_t mbstowcs(wchar_t* __dst, const char* __src, size_t __n);
int mbtowc(wchar_t* __wc_ptr, const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));
int wctomb(char* __dst, wchar_t __wc) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));

size_t wcstombs(char* __dst, const wchar_t* __src, size_t __n);
# 230 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
int abs(int __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));
long labs(long __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));
long long llabs(long long __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));





float strtof(const char* __s, char** __end_ptr) __attribute__((annotate("introduced_in=" "21")));
double atof(const char* __s) __attribute__((__pure__)) __attribute__((annotate("introduced_in=" "21")));
int rand(void) __attribute__((annotate("introduced_in=" "21")));
void srand(unsigned int __seed) __attribute__((annotate("introduced_in=" "21")));
long random(void) __attribute__((annotate("introduced_in=" "21")));
void srandom(unsigned int __seed) __attribute__((annotate("introduced_in=" "21")));
int grantpt(int __fd) __attribute__((annotate("introduced_in=" "21")));

long long strtoll_l(const char* __s, char** __end_ptr, int __base, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
unsigned long long strtoull_l(const char* __s, char** __end_ptr, int __base, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
long double strtold_l(const char* __s, char** __end_ptr, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
# 263 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 1 3 4
# 90 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/stdlib.h" 1 3 4
# 91 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 2 3 4




static __inline double strtod_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtod(__s, __end_ptr);
}

static __inline float strtof_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtof(__s, __end_ptr);
}

static __inline long strtol_l(const char* __s, char** __end_ptr, int __base, locale_t __l) {
  return strtol(__s, __end_ptr, __base);
}
# 264 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 12 "./common.h" 2

# 1 "/data/data/com.termux/files/usr/include/unistd.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/sys/select.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/time.h" 1 3 4
# 24 "/data/data/com.termux/files/usr/include/linux/time.h" 3 4
struct timespec {
  __kernel_time_t tv_sec;
  long tv_nsec;
};

struct timeval {
  __kernel_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};



struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};
struct itimerval {
  struct timeval it_interval;
  struct timeval it_value;
};
struct __kernel_old_timeval {
  __kernel_long_t tv_sec;
  __kernel_long_t tv_usec;
};
# 36 "/data/data/com.termux/files/usr/include/sys/select.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/signal.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/sigcontext.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/sigcontext.h" 3 4
struct sigcontext {
  __u64 fault_address;
  __u64 regs[31];
  __u64 sp;
  __u64 pc;
  __u64 pstate;
  __u8 __reserved[4096] __attribute__((__aligned__(16)));
};
struct _aarch64_ctx {
  __u32 magic;
  __u32 size;
};

struct fpsimd_context {
  struct _aarch64_ctx head;
  __u32 fpsr;
  __u32 fpcr;
  __uint128_t vregs[32];
};

struct esr_context {
  struct _aarch64_ctx head;
  __u64 esr;
};

struct extra_context {
  struct _aarch64_ctx head;
  __u64 datap;
  __u32 size;
  __u32 __reserved[3];
};

struct sve_context {
  struct _aarch64_ctx head;
  __u16 vl;
  __u16 __reserved[3];
};
# 36 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/limits.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/limits.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/float.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/linux/limits.h" 1 3 4
# 44 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4
# 140 "/data/data/com.termux/files/usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/posix_limits.h" 1 3 4
# 141 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4
# 38 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/limits.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 2 3 4
# 42 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/signal.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/signal.h" 1 3 4
# 24 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 1 3 4
# 77 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 3 4
typedef struct {
  unsigned long sig[(64 / 64)];
} sigset_t;
typedef unsigned long old_sigset_t;

# 1 "/data/data/com.termux/files/usr/include/asm-generic/signal-defs.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/asm-generic/signal-defs.h" 3 4
typedef void __signalfn_t(int);
typedef __signalfn_t * __sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t * __sigrestore_t;
# 82 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 2 3 4



struct __kernel_sigaction {
  __sighandler_t sa_handler;
  unsigned long sa_flags;

  __sigrestore_t sa_restorer;

  sigset_t sa_mask;
};
typedef struct sigaltstack {
  void * ss_sp;
  int ss_flags;
  size_t ss_size;
} stack_t;
# 25 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/signal.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/signal.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/siginfo.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/siginfo.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef union sigval {
  int sival_int;
  void * sival_ptr;
} sigval_t;
# 43 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef struct siginfo {
  int si_signo;

  int si_errno;
  int si_code;




  union {
    int _pad[((128 - (4 * sizeof(int))) / sizeof(int))];
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
    } _kill;
    struct {
      __kernel_timer_t _tid;
      int _overrun;
      sigval_t _sigval;
      int _sys_private;
    } _timer;
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      sigval_t _sigval;
    } _rt;
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      int _status;
      __kernel_clock_t _utime;
      __kernel_clock_t _stime;
    } _sigchld;
    struct {
      void * _addr;
# 87 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
      union {
        short _addr_lsb;
        struct {
          char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
          void * _lower;
          void * _upper;
        } _addr_bnd;
        struct {
          char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
          __u32 _pkey;
        } _addr_pkey;
      };
    } _sigfault;
    struct {
      long _band;
      int _fd;
    } _sigpoll;
    struct {
      void * _call_addr;
      int _syscall;
      unsigned int _arch;
    } _sigsys;
  } _sifields;
} siginfo_t;
# 223 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef struct sigevent {
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union {
    int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
    int _tid;
    struct {
      void(* _function) (sigval_t);
      void * _attribute;
    } _sigev_thread;
  } _sigev_un;
} sigevent_t;
# 23 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/siginfo.h" 2 3 4
# 23 "/data/data/com.termux/files/usr/include/linux/signal.h" 2 3 4
# 43 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 2 3 4
# 54 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
typedef int sig_atomic_t;

typedef __sighandler_t sig_t;
typedef __sighandler_t sighandler_t;





typedef sigset_t sigset64_t;
# 79 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
struct sigaction { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
struct sigaction64 { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
# 38 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/timespec.h" 1 3 4
# 39 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/signal.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/user.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/user.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/user.h" 2 3 4
# 240 "/data/data/com.termux/files/usr/include/sys/user.h" 3 4
struct user_regs_struct {
  uint64_t regs[31];
  uint64_t sp;
  uint64_t pc;
  uint64_t pstate;
};
struct user_fpsimd_struct {
  __uint128_t vregs[32];
  uint32_t fpsr;
  uint32_t fpcr;
};
# 36 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 2 3 4
# 106 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 3 4
typedef unsigned long greg_t;
typedef greg_t gregset_t[34];
typedef struct user_fpsimd_struct fpregset_t;


typedef struct sigcontext mcontext_t;

typedef struct ucontext {
  unsigned long uc_flags;
  struct ucontext *uc_link;
  stack_t uc_stack;
  union {
    sigset_t uc_sigmask;
    sigset64_t uc_sigmask64;
  };

  char __padding[128 - sizeof(sigset_t)];
  mcontext_t uc_mcontext;
} ucontext_t;
# 42 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 56 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int __libc_current_sigrtmin(void) __attribute__((annotate("introduced_in=" "21")));
int __libc_current_sigrtmax(void) __attribute__((annotate("introduced_in=" "21")));



extern const char* const sys_siglist[(64 + 1)];
extern const char* const sys_signame[(64 + 1)];



int sigaction(int __signal, const struct sigaction* __new_action, struct sigaction* __old_action);






int siginterrupt(int __signal, int __flag);


sighandler_t signal(int __signal, sighandler_t __handler) __attribute__((annotate("introduced_in=" "21")));
int sigaddset(sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));





int sigdelset(sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));





int sigemptyset(sigset_t* __set) __attribute__((annotate("introduced_in=" "21")));





int sigfillset(sigset_t* __set) __attribute__((annotate("introduced_in=" "21")));





int sigismember(const sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));
# 111 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int sigpending(sigset_t* __set);





int sigprocmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);





int sigsuspend(const sigset_t* __mask);





int sigwait(const sigset_t* __set, int* __signal);
# 153 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int raise(int __signal);
int kill(pid_t __pid, int __signal);
int killpg(int __pgrp, int __signal);


int tgkill(int __tgid, int __tid, int __signal) __attribute__((annotate("introduced_in_32=" "16")));



int sigaltstack(const stack_t* __new_signal_stack, stack_t* __old_signal_stack);



void psiginfo(const siginfo_t* __info, const char* __msg) __attribute__((annotate("introduced_in=" "17")));
void psignal(int __signal, const char* __msg) __attribute__((annotate("introduced_in=" "17")));



int pthread_kill(pthread_t __pthread, int __signal);
int pthread_sigmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);
# 203 "/data/data/com.termux/files/usr/include/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/legacy_signal_inlines.h" 1 3 4
# 204 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 37 "/data/data/com.termux/files/usr/include/sys/select.h" 2 3 4



typedef unsigned long fd_mask;




typedef struct {
  fd_mask fds_bits[1024/(8 * sizeof(fd_mask))];
} fd_set;
# 64 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
void __FD_CLR_chk(int, fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
void __FD_SET_chk(int, fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
int __FD_ISSET_chk(int, const fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
# 85 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
int select(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, struct timeval* __timeout);
int pselect(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, const struct timespec* __timeout, const sigset_t* __mask);
int pselect64(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, const struct timespec* __timeout, const sigset64_t* __mask);
# 36 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/fcntl.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/fcntl.h" 3 4
int fcntl(int __fd, int __cmd, ...);
# 38 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/getopt.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/getopt.h" 3 4
int getopt(int __argc, char* const __argv[], const char* __options);

extern char* optarg;
extern int optind, opterr, optopt;
# 39 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 3 4
int ioctl(int __fd, int __request, ...);
# 56 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 3 4
int ioctl(int __fd, unsigned __request, ...) __attribute__((overloadable)) __attribute__((enable_if(1, ""))) __asm__("ioctl");
# 40 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/lockf.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/bits/sysconf.h" 1 3 4
# 192 "/data/data/com.termux/files/usr/include/bits/sysconf.h" 3 4
long sysconf(int __name);
# 44 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 77 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
extern char** environ;

__attribute__((__noreturn__)) void _exit(int __status);

pid_t fork(void);
pid_t vfork(void);
pid_t getpid(void);
pid_t gettid(void) __attribute__((__const__));
pid_t getpgid(pid_t __pid);
int setpgid(pid_t __pid, pid_t __pgid);
pid_t getppid(void);
pid_t getpgrp(void);
int setpgrp(void);


pid_t getsid(pid_t __pid) __attribute__((annotate("introduced_in=" "17")));


pid_t setsid(void);

int execv(const char* __path, char* const* __argv);
int execvp(const char* __file, char* const* __argv);


int execvpe(const char* __file, char* const* __argv, char* const* __envp) __attribute__((annotate("introduced_in=" "21")));


int execve(const char* __file, char* const* __argv, char* const* __envp);
int execl(const char* __path, const char* __arg0, ...) __attribute__((__sentinel__));
int execlp(const char* __file, const char* __arg0, ...) __attribute__((__sentinel__));
int execle(const char* __path, const char* __arg0, ... )
    __attribute__((__sentinel__(1)));






int nice(int __incr);

int setuid(uid_t __uid);
uid_t getuid(void);
int seteuid(uid_t __uid);
uid_t geteuid(void);
int setgid(gid_t __gid);
gid_t getgid(void);
int setegid(gid_t __gid);
gid_t getegid(void);
int getgroups(int __size, gid_t* __list);
int setgroups(size_t __size, const gid_t* __list);
int setreuid(uid_t __ruid, uid_t __euid);
int setregid(gid_t __rgid, gid_t __egid);
int setresuid(uid_t __ruid, uid_t __euid, uid_t __suid);
int setresgid(gid_t __rgid, gid_t __egid, gid_t __sgid);
int getresuid(uid_t* __ruid, uid_t* __euid, uid_t* __suid);
int getresgid(gid_t* __rgid, gid_t* __egid, gid_t* __sgid);
char* getlogin(void);






long fpathconf(int __fd, int __name);
long pathconf(const char* __path, int __name);

int access(const char* __path, int __mode);


int faccessat(int __dirfd, const char* __path, int __mode, int __flags) __attribute__((annotate("introduced_in=" "16")));


int link(const char* __old_path, const char* __new_path);


int linkat(int __old_dir_fd, const char* __old_path, int __new_dir_fd, const char* __new_path, int __flags) __attribute__((annotate("introduced_in=" "21")));


int unlink(const char* __path);
int unlinkat(int __dirfd, const char* __path, int __flags);
int chdir(const char* __path);
int fchdir(int __fd);
int rmdir(const char* __path);
int pipe(int __fds[2]);

int pipe2(int __fds[2], int __flags) __attribute__((annotate("introduced_in=" "9")));

int chroot(const char* __path);
int symlink(const char* __old_path, const char* __new_path);


int symlinkat(const char* __old_path, int __new_dir_fd, const char* __new_path) __attribute__((annotate("introduced_in=" "21")));


ssize_t readlink(const char* __path, char* __buf, size_t __buf_size);


ssize_t readlinkat(int __dir_fd, const char* __path, char* __buf, size_t __buf_size)
    __attribute__((annotate("introduced_in=" "21")));


int chown(const char* __path, uid_t __owner, gid_t __group);
int fchown(int __fd, uid_t __owner, gid_t __group);
int fchownat(int __dir_fd, const char* __path, uid_t __owner, gid_t __group, int __flags);
int lchown(const char* __path, uid_t __owner, gid_t __group);
char* getcwd(char* __buf, size_t __size);

void sync(void);
# 193 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
int close(int __fd);

ssize_t read(int __fd, void* __buf, size_t __count);
ssize_t write(int __fd, const void* __buf, size_t __count);

int dup(int __old_fd);
int dup2(int __old_fd, int __new_fd);


int dup3(int __old_fd, int __new_fd, int __flags) __attribute__((annotate("introduced_in=" "21")));


int fsync(int __fd);
int fdatasync(int __fd) __attribute__((annotate("introduced_in=" "9")));
# 222 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
int truncate(const char* __path, off_t __length);
off_t lseek(int __fd, off_t __offset, int __whence);
ssize_t pread(int __fd, void* __buf, size_t __count, off_t __offset);
ssize_t pwrite(int __fd, const void* __buf, size_t __count, off_t __offset);
int ftruncate(int __fd, off_t __length);




int truncate64(const char* __path, off64_t __length) __attribute__((annotate("introduced_in=" "21")));


off64_t lseek64(int __fd, off64_t __offset, int __whence);
ssize_t pread64(int __fd, void* __buf, size_t __count, off64_t __offset) __attribute__((annotate("introduced_in=" "12")));
ssize_t pwrite64(int __fd, const void* __buf, size_t __count, off64_t __offset) __attribute__((annotate("introduced_in=" "12")));
int ftruncate64(int __fd, off64_t __length) __attribute__((annotate("introduced_in=" "12")));

int pause(void);
unsigned int alarm(unsigned int __seconds);
unsigned int sleep(unsigned int __seconds);
int usleep(useconds_t __microseconds);

int gethostname(char* __buf, size_t __buf_size);






int brk(void* __addr);
void* sbrk(ptrdiff_t __increment);

int isatty(int __fd);
char* ttyname(int __fd);
int ttyname_r(int __fd, char* __buf, size_t __buf_size) __attribute__((annotate("introduced_in=" "8")));

int acct(const char* __path);


int getpagesize(void) __attribute__((annotate("introduced_in=" "21")));






long syscall(long __number, ...);

int daemon(int __no_chdir, int __no_close);






pid_t tcgetpgrp(int __fd);
int tcsetpgrp(int __fd, pid_t __pid);
# 311 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
static __inline__ char* getpass(const char* prompt) {

    struct _termios {
        unsigned int c_iflag;
        unsigned int c_oflag;
        unsigned int c_cflag;
        unsigned int c_lflag;
        unsigned char c_line;
        unsigned char c_cc[19 ];
    };

    struct _termios term_old, term_new;
    static char password[513] = { 0 };
    int len = 0, tty_changed = 0;


    while (*prompt) {
        write(1, prompt, 1);
        prompt++;
    }


    if (ioctl(0, 0x5401 , &term_old) == 0) {
        term_new = term_old;
        term_new.c_lflag &= ~0000010;

        if (ioctl(0, 0x5402+0 , &term_new) == 0) {
            tty_changed = 1;
        } else {
            tty_changed = 0;
        }
    }


    char chr;
    while (read(0, &chr, sizeof(char)) > 0) {
        if (chr == '\r' || chr == '\n' || chr == 0) {
            break;
        }

        if (len == sizeof(password)-1) {


            continue;
        } else {
            password[len++] = chr;
        }
    }
    password[len] = 0;


    if (tty_changed) {
        ioctl(0, 0x5402+0 , &term_old);
    }


    write(1, "\n", 1);

    return password;
}
# 14 "./common.h" 2


# 1 "/data/data/com.termux/files/usr/include/sys/stat.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/stat.h" 1 3 4
# 54 "/data/data/com.termux/files/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
  __s64 tv_sec;
  __u32 tv_nsec;
  __s32 __reserved;
};
struct statx {
  __u32 stx_mask;
  __u32 stx_blksize;
  __u64 stx_attributes;
  __u32 stx_nlink;
  __u32 stx_uid;
  __u32 stx_gid;
  __u16 stx_mode;
  __u16 __spare0[1];
  __u64 stx_ino;
  __u64 stx_size;
  __u64 stx_blocks;
  __u64 stx_attributes_mask;
  struct statx_timestamp stx_atime;
  struct statx_timestamp stx_btime;
  struct statx_timestamp stx_ctime;
  struct statx_timestamp stx_mtime;
  __u32 stx_rdev_major;
  __u32 stx_rdev_minor;
  __u32 stx_dev_major;
  __u32 stx_dev_minor;
  __u64 __spare2[14];
};
# 34 "/data/data/com.termux/files/usr/include/sys/stat.h" 2 3 4
# 117 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; ino_t st_ino; mode_t st_mode; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; dev_t st_rdev; unsigned long __pad1; off_t st_size; int st_blksize; int __pad2; long st_blocks; struct timespec st_atim; struct timespec st_mtim; struct timespec st_ctim; unsigned int __unused4; unsigned int __unused5; };
struct stat64 { dev_t st_dev; ino_t st_ino; mode_t st_mode; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; dev_t st_rdev; unsigned long __pad1; off_t st_size; int st_blksize; int __pad2; long st_blocks; struct timespec st_atim; struct timespec st_mtim; struct timespec st_ctim; unsigned int __unused4; unsigned int __unused5; };
# 154 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
int chmod(const char* __path, mode_t __mode);
int fchmod(int __fd, mode_t __mode);
int mkdir(const char* __path, mode_t __mode);

int fstat(int __fd, struct stat* __buf);
int fstat64(int __fd, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));
int fstatat(int __dir_fd, const char* __path, struct stat* __buf, int __flags);
int fstatat64(int __dir_fd, const char* __path, struct stat64* __buf, int __flags) __attribute__((annotate("introduced_in=" "21")));
int lstat(const char* __path, struct stat* __buf);
int lstat64(const char* __path, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));
int stat(const char* __path, struct stat* __buf);
int stat64(const char* __path, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));

int mknod(const char* __path, mode_t __mode, dev_t __dev);
mode_t umask(mode_t __mask);






int mkfifo(const char* __path, mode_t __mode) __attribute__((annotate("introduced_in=" "21")));
# 186 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
int fchmodat(int __dir_fd, const char* __path, mode_t __mode, int __flags);
int mkdirat(int __dir_fd, const char* __path, mode_t __mode);


int mknodat(int __dir_fd, const char* __path, mode_t __mode, dev_t __dev) __attribute__((annotate("introduced_in=" "21")));





int utimensat(int __dir_fd, const char* __path, const struct timespec __times[2], int __flags)
  __attribute__((annotate("introduced_in=" "12")));


int futimens(int __dir_fd, const struct timespec __times[2]) __attribute__((annotate("introduced_in=" "19")));






# 1 "/data/data/com.termux/files/usr/include/android/legacy_sys_stat_inlines.h" 1 3 4
# 207 "/data/data/com.termux/files/usr/include/sys/stat.h" 2 3 4
# 17 "./common.h" 2
# 1 "/data/data/com.termux/files/usr/include/fcntl.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/fcntl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/fadvise.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/fcntl.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/falloc.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/fcntl.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/fcntl.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/include/fcntl.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/linux/uio.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/linux/uio.h" 3 4
struct iovec {
  void * iov_base;
  __kernel_size_t iov_len;
};
# 39 "/data/data/com.termux/files/usr/include/fcntl.h" 2 3 4
# 72 "/data/data/com.termux/files/usr/include/fcntl.h" 3 4
int creat(const char* __path, mode_t __mode);


int creat64(const char* __path, mode_t __mode) __attribute__((annotate("introduced_in=" "21")));


int openat(int __dir_fd, const char* __path, int __flags, ...);


int openat64(int __dir_fd, const char* __path, int __flags, ...) __attribute__((annotate("introduced_in=" "21")));


int open(const char* __path, int __flags, ...);


int open64(const char* __path, int __flags, ...) __attribute__((annotate("introduced_in=" "21")));
ssize_t splice(int __in_fd, off64_t* __in_offset, int __out_fd, off64_t* __out_offset, size_t __length, unsigned int __flags) __attribute__((annotate("introduced_in=" "21")));
ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags) __attribute__((annotate("introduced_in=" "21")));
ssize_t vmsplice(int __fd, const struct iovec* __iov, size_t __count, unsigned int __flags) __attribute__((annotate("introduced_in=" "21")));

int fallocate(int __fd, int __mode, off_t __offset, off_t __length) __attribute__((annotate("introduced_in=" "21")));
int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length) __attribute__((annotate("introduced_in=" "21")));
int posix_fadvise(int __fd, off_t __offset, off_t __length, int __advice) __attribute__((annotate("introduced_in=" "21")));
int posix_fadvise64(int __fd, off64_t __offset, off64_t __length, int __advice) __attribute__((annotate("introduced_in=" "21")));
int posix_fallocate(int __fd, off_t __offset, off_t __length) __attribute__((annotate("introduced_in=" "21")));
int posix_fallocate64(int __fd, off64_t __offset, off64_t __length) __attribute__((annotate("introduced_in=" "21")));






ssize_t readahead(int __fd, off64_t __offset, size_t __length) __attribute__((annotate("introduced_in=" "16")));
# 18 "./common.h" 2
# 1 "/data/data/com.termux/files/usr/include/ctype.h" 1 3 4
# 62 "/data/data/com.termux/files/usr/include/ctype.h" 3 4
extern const char* _ctype_;

int isalnum(int __ch);
int isalpha(int __ch);
int isblank(int __ch);
int iscntrl(int __ch);
int isdigit(int __ch);
int isgraph(int __ch);
int islower(int __ch);
int isprint(int __ch);
int ispunct(int __ch);
int isspace(int __ch);
int isupper(int __ch);
int isxdigit(int __ch);
int tolower(int __ch);
int toupper(int __ch);


int isalnum_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isalpha_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isblank_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int iscntrl_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isdigit_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isgraph_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int islower_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isprint_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int ispunct_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isspace_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isupper_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isxdigit_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int tolower_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int toupper_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));




int isascii(int __ch);
int toascii(int __ch);


int _tolower(int __ch) __attribute__((annotate("introduced_in=" "21")));
int _toupper(int __ch) __attribute__((annotate("introduced_in=" "21")));
# 19 "./common.h" 2

# 1 "/data/data/com.termux/files/usr/include/locale.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/locale.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.1/include/stddef.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/include/locale.h" 2 3 4
# 72 "/data/data/com.termux/files/usr/include/locale.h" 3 4
struct lconv {
  char* decimal_point;
  char* thousands_sep;
  char* grouping;
  char* int_curr_symbol;
  char* currency_symbol;
  char* mon_decimal_point;
  char* mon_thousands_sep;
  char* mon_grouping;
  char* positive_sign;
  char* negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

struct lconv* localeconv(void) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));



locale_t duplocale(locale_t __l) __attribute__((annotate("introduced_in=" "21")));
void freelocale(locale_t __l) __attribute__((annotate("introduced_in=" "21")));
locale_t newlocale(int __category_mask, const char* __locale_name, locale_t __base) __attribute__((annotate("introduced_in=" "21")));


char* setlocale(int __category, const char* __locale_name);


locale_t uselocale(locale_t __l) __attribute__((annotate("introduced_in=" "21")));
# 21 "./common.h" 2
# 1 "/data/data/com.termux/files/usr/include/pcre.h" 1 3 4
# 324 "/data/data/com.termux/files/usr/include/pcre.h" 3 4
struct real_pcre8_or_16;
typedef struct real_pcre8_or_16 pcre;

struct real_pcre8_or_16;
typedef struct real_pcre8_or_16 pcre16;

struct real_pcre32;
typedef struct real_pcre32 pcre32;

struct real_pcre_jit_stack;
typedef struct real_pcre_jit_stack pcre_jit_stack;

struct real_pcre16_jit_stack;
typedef struct real_pcre16_jit_stack pcre16_jit_stack;

struct real_pcre32_jit_stack;
typedef struct real_pcre32_jit_stack pcre32_jit_stack;
# 376 "/data/data/com.termux/files/usr/include/pcre.h" 3 4
typedef struct pcre_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned char **mark;
  void *executable_jit;
} pcre_extra;



typedef struct pcre16_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned short **mark;
  void *executable_jit;
} pcre16_extra;



typedef struct pcre32_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned int **mark;
  void *executable_jit;
} pcre32_extra;






typedef struct pcre_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const char * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned char *mark;

} pcre_callout_block;



typedef struct pcre16_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const unsigned short * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned short *mark;

} pcre16_callout_block;



typedef struct pcre32_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const unsigned int * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned int *mark;

} pcre32_callout_block;
# 489 "/data/data/com.termux/files/usr/include/pcre.h" 3 4
extern void *(*pcre_malloc)(size_t);
extern void (*pcre_free)(void *);
extern void *(*pcre_stack_malloc)(size_t);
extern void (*pcre_stack_free)(void *);
extern int (*pcre_callout)(pcre_callout_block *);
extern int (*pcre_stack_guard)(void);

extern void *(*pcre16_malloc)(size_t);
extern void (*pcre16_free)(void *);
extern void *(*pcre16_stack_malloc)(size_t);
extern void (*pcre16_stack_free)(void *);
extern int (*pcre16_callout)(pcre16_callout_block *);
extern int (*pcre16_stack_guard)(void);

extern void *(*pcre32_malloc)(size_t);
extern void (*pcre32_free)(void *);
extern void *(*pcre32_stack_malloc)(size_t);
extern void (*pcre32_stack_free)(void *);
extern int (*pcre32_callout)(pcre32_callout_block *);
extern int (*pcre32_stack_guard)(void);
# 534 "/data/data/com.termux/files/usr/include/pcre.h" 3 4
typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
typedef pcre16_jit_stack *(*pcre16_jit_callback)(void *);
typedef pcre32_jit_stack *(*pcre32_jit_callback)(void *);



extern pcre *pcre_compile(const char *, int, const char **, int *,
                  const unsigned char *);
extern pcre16 *pcre16_compile(const unsigned short *, int, const char **, int *,
                  const unsigned char *);
extern pcre32 *pcre32_compile(const unsigned int *, int, const char **, int *,
                  const unsigned char *);
extern pcre *pcre_compile2(const char *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre16 *pcre16_compile2(const unsigned short *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre32 *pcre32_compile2(const unsigned int *, int, int *, const char **,
                  int *, const unsigned char *);
extern int pcre_config(int, void *);
extern int pcre16_config(int, void *);
extern int pcre32_config(int, void *);
extern int pcre_copy_named_substring(const pcre *, const char *,
                  int *, int, const char *, char *, int);
extern int pcre16_copy_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, unsigned short *, int);
extern int pcre32_copy_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, unsigned int *, int);
extern int pcre_copy_substring(const char *, int *, int, int,
                  char *, int);
extern int pcre16_copy_substring(const unsigned short *, int *, int, int,
                  unsigned short *, int);
extern int pcre32_copy_substring(const unsigned int *, int *, int, int,
                  unsigned int *, int);
extern int pcre_dfa_exec(const pcre *, const pcre_extra *,
                  const char *, int, int, int, int *, int , int *, int);
extern int pcre16_dfa_exec(const pcre16 *, const pcre16_extra *,
                  const unsigned short *, int, int, int, int *, int , int *, int);
extern int pcre32_dfa_exec(const pcre32 *, const pcre32_extra *,
                  const unsigned int *, int, int, int, int *, int , int *, int);
extern int pcre_exec(const pcre *, const pcre_extra *, const char *,
                   int, int, int, int *, int);
extern int pcre16_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int);
extern int pcre32_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int);
extern int pcre_jit_exec(const pcre *, const pcre_extra *,
                   const char *, int, int, int, int *, int,
                   pcre_jit_stack *);
extern int pcre16_jit_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int,
                   pcre16_jit_stack *);
extern int pcre32_jit_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int,
                   pcre32_jit_stack *);
extern void pcre_free_substring(const char *);
extern void pcre16_free_substring(const unsigned short *);
extern void pcre32_free_substring(const unsigned int *);
extern void pcre_free_substring_list(const char **);
extern void pcre16_free_substring_list(const unsigned short * *);
extern void pcre32_free_substring_list(const unsigned int * *);
extern int pcre_fullinfo(const pcre *, const pcre_extra *, int,
                  void *);
extern int pcre16_fullinfo(const pcre16 *, const pcre16_extra *, int,
                  void *);
extern int pcre32_fullinfo(const pcre32 *, const pcre32_extra *, int,
                  void *);
extern int pcre_get_named_substring(const pcre *, const char *,
                  int *, int, const char *, const char **);
extern int pcre16_get_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, const unsigned short * *);
extern int pcre32_get_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, const unsigned int * *);
extern int pcre_get_stringnumber(const pcre *, const char *);
extern int pcre16_get_stringnumber(const pcre16 *, const unsigned short *);
extern int pcre32_get_stringnumber(const pcre32 *, const unsigned int *);
extern int pcre_get_stringtable_entries(const pcre *, const char *,
                  char **, char **);
extern int pcre16_get_stringtable_entries(const pcre16 *, const unsigned short *,
                  unsigned short **, unsigned short **);
extern int pcre32_get_stringtable_entries(const pcre32 *, const unsigned int *,
                  unsigned int **, unsigned int **);
extern int pcre_get_substring(const char *, int *, int, int,
                  const char **);
extern int pcre16_get_substring(const unsigned short *, int *, int, int,
                  const unsigned short * *);
extern int pcre32_get_substring(const unsigned int *, int *, int, int,
                  const unsigned int * *);
extern int pcre_get_substring_list(const char *, int *, int,
                  const char ***);
extern int pcre16_get_substring_list(const unsigned short *, int *, int,
                  const unsigned short * **);
extern int pcre32_get_substring_list(const unsigned int *, int *, int,
                  const unsigned int * **);
extern const unsigned char *pcre_maketables(void);
extern const unsigned char *pcre16_maketables(void);
extern const unsigned char *pcre32_maketables(void);
extern int pcre_refcount(pcre *, int);
extern int pcre16_refcount(pcre16 *, int);
extern int pcre32_refcount(pcre32 *, int);
extern pcre_extra *pcre_study(const pcre *, int, const char **);
extern pcre16_extra *pcre16_study(const pcre16 *, int, const char **);
extern pcre32_extra *pcre32_study(const pcre32 *, int, const char **);
extern void pcre_free_study(pcre_extra *);
extern void pcre16_free_study(pcre16_extra *);
extern void pcre32_free_study(pcre32_extra *);
extern const char *pcre_version(void);
extern const char *pcre16_version(void);
extern const char *pcre32_version(void);


extern int pcre_pattern_to_host_byte_order(pcre *, pcre_extra *,
                  const unsigned char *);
extern int pcre16_pattern_to_host_byte_order(pcre16 *, pcre16_extra *,
                  const unsigned char *);
extern int pcre32_pattern_to_host_byte_order(pcre32 *, pcre32_extra *,
                  const unsigned char *);
extern int pcre16_utf16_to_host_byte_order(unsigned short *,
                  const unsigned short *, int, int *, int);
extern int pcre32_utf32_to_host_byte_order(unsigned int *,
                  const unsigned int *, int, int *, int);



extern pcre_jit_stack *pcre_jit_stack_alloc(int, int);
extern pcre16_jit_stack *pcre16_jit_stack_alloc(int, int);
extern pcre32_jit_stack *pcre32_jit_stack_alloc(int, int);
extern void pcre_jit_stack_free(pcre_jit_stack *);
extern void pcre16_jit_stack_free(pcre16_jit_stack *);
extern void pcre32_jit_stack_free(pcre32_jit_stack *);
extern void pcre_assign_jit_stack(pcre_extra *,
                  pcre_jit_callback, void *);
extern void pcre16_assign_jit_stack(pcre16_extra *,
                  pcre16_jit_callback, void *);
extern void pcre32_assign_jit_stack(pcre32_extra *,
                  pcre32_jit_callback, void *);
extern void pcre_jit_free_unused_memory(void);
extern void pcre16_jit_free_unused_memory(void);
extern void pcre32_jit_free_unused_memory(void);
# 22 "./common.h" 2
# 1 "/data/data/com.termux/files/usr/include/dlfcn.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/include/dlfcn.h" 3 4
typedef struct {

  const char* dli_fname;

  void* dli_fbase;

  const char* dli_sname;

  void* dli_saddr;
} Dl_info;

void* dlopen(const char* __filename, int __flag);
int dlclose(void* __handle);
char* dlerror(void);
void* dlsym(void* __handle, const char* __symbol);





int dladdr(const void* __addr, Dl_info* __info);
# 23 "./common.h" 2
# 33 "./common.h"
# 1 "/data/data/com.termux/files/usr/include/termios.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/termios.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/ioctl.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/ioctl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/ioctl.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/ioctl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctl.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/ioctl.h" 1 3 4
# 20 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctl.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/ioctl.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/ioctl.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/include/linux/termios.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/termios.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termios.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termios.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/termios.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/termios.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termbits.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termbits.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/termbits.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/asm-generic/termbits.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

struct termios {
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[19];
};
struct termios2 {
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[19];
  speed_t c_ispeed;
  speed_t c_ospeed;
};
struct ktermios {
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[19];
  speed_t c_ispeed;
  speed_t c_ospeed;
};
# 20 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termbits.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/asm-generic/termios.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctls.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctls.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/ioctls.h" 1 3 4
# 20 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/ioctls.h" 2 3 4
# 23 "/data/data/com.termux/files/usr/include/asm-generic/termios.h" 2 3 4
struct winsize {
  unsigned short ws_row;
  unsigned short ws_col;
  unsigned short ws_xpixel;
  unsigned short ws_ypixel;
};

struct termio {
  unsigned short c_iflag;
  unsigned short c_oflag;
  unsigned short c_cflag;
  unsigned short c_lflag;
  unsigned char c_line;
  unsigned char c_cc[8];
};
# 20 "/data/data/com.termux/files/usr/include/aarch64-linux-android/asm/termios.h" 2 3 4
# 23 "/data/data/com.termux/files/usr/include/linux/termios.h" 2 3 4

struct termiox {
  __u16 x_hflag;
  __u16 x_cflag;
  __u16 x_rflag[5];
  __u16 x_sflag;
};
# 39 "/data/data/com.termux/files/usr/include/sys/ioctl.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/tty.h" 1 3 4
# 40 "/data/data/com.termux/files/usr/include/sys/ioctl.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/termios.h" 2 3 4







speed_t cfgetispeed(const struct termios* __t) __attribute__((annotate("introduced_in=" "21")));
speed_t cfgetospeed(const struct termios* __t) __attribute__((annotate("introduced_in=" "21")));
void cfmakeraw(struct termios* __t) __attribute__((annotate("introduced_in=" "21")));
int cfsetspeed(struct termios* __t, speed_t __speed) __attribute__((annotate("introduced_in=" "21")));
int cfsetispeed(struct termios* __t, speed_t __speed) __attribute__((annotate("introduced_in=" "21")));
int cfsetospeed(struct termios* __t, speed_t __speed) __attribute__((annotate("introduced_in=" "21")));
int tcdrain(int __fd) __attribute__((annotate("introduced_in=" "21")));
int tcflow(int __fd, int __action) __attribute__((annotate("introduced_in=" "21")));
int tcflush(int __fd, int __queue) __attribute__((annotate("introduced_in=" "21")));
int tcgetattr(int __fd, struct termios* __t) __attribute__((annotate("introduced_in=" "21")));
pid_t tcgetsid(int __fd) __attribute__((annotate("introduced_in=" "21")));
int tcsendbreak(int __fd, int __duration) __attribute__((annotate("introduced_in=" "21")));
int tcsetattr(int __fd, int __optional_actions, const struct termios* __t) __attribute__((annotate("introduced_in=" "21")));





# 1 "/data/data/com.termux/files/usr/include/android/legacy_termios_inlines.h" 1 3 4
# 58 "/data/data/com.termux/files/usr/include/termios.h" 2 3 4
# 34 "./common.h" 2



# 1 "./clover2-macros.h" 1
# 38 "./common.h" 2


# 1 "./clover2-debug.h" 1






# 1 "/data/data/com.termux/files/usr/include/assert.h" 1 3 4
# 63 "/data/data/com.termux/files/usr/include/assert.h" 3 4
void __assert(const char* __file, int __line, const char* __msg) __attribute__((__noreturn__));
void __assert2(const char* __file, int __line, const char* __function, const char* __msg) __attribute__((__noreturn__));
# 8 "./clover2-debug.h" 2








      void* xmalloc(size_t size);
      char* xstrdup(char* str);
      void* xrealloc(void* ptr, size_t size);
      void* xcalloc(size_t count, size_t size);
void xfree(void* ptr);
# 41 "./common.h" 2


# 1 "./clover2-buffer.h" 1






struct sBufStruct {
    char* mBuf;
    int mSize;
    int mLen;
};

typedef struct sBufStruct sBuf;

void sBuf_init(sBuf* self);
void sBuf_append(sBuf* self, void* str, size_t size);
void sBuf_append_char(sBuf* self, char c);
void sBuf_append_str(sBuf* self, char* str);
void sBuf_append_int(sBuf* self, int value);
void sBuf_append_long(sBuf* self, long long value);
void sBuf_clone(sBuf* self, sBuf* buf);
# 44 "./common.h" 2


# 1 "./clover2-xfunc.h" 1



extern char* xstrncpy(char* des, char* src, int size);
extern char* xstrncat(char* des, char* str, int size);
      char* xwcstombs(wchar_t* wstr, int len);
# 47 "./common.h" 2
# 89 "./common.h"
typedef unsigned int CLObject;

union CLVALUEUnion {
    unsigned int mUIntValue;
    unsigned char mUByteValue;
    unsigned short mUShortValue;
    unsigned long long mULongValue;
    int mIntValue;
    char mByteValue;
    short mShortValue;
    long long mLongValue;
    CLObject mObjectValue;
    wchar_t mCharValue;
    float mFloatValue;
    double mDoubleValue;
    int mBoolValue;
    char* mPointerValue;
    void* LLVMValue;
    int mJSValue;
};

typedef union CLVALUEUnion CLVALUE;


struct sByteCodeStruct {
    char* mCodes;
    unsigned int mLen;
    size_t mSize;
};

typedef struct sByteCodeStruct sByteCode;

void sByteCode_init(sByteCode* code);
void sByteCode_init_with_size(sByteCode* code, int size);
void sByteCode_free(sByteCode* code);
void sByteCode_clone(sByteCode* self, sByteCode* code);
void append_value_to_code(sByteCode* code, void* data, size_t size, int no_output);
void append_opecode_to_code(sByteCode* code, unsigned int op, int no_output);
void append_int_value_to_code(sByteCode* code, int value, int no_output);
void append_long_value_to_code(sByteCode* code, long long value, int no_output);
void append_double_value_to_code(sByteCode* code, double value, int no_output);
void append_float_value_to_code(sByteCode* code, float value, int no_output);


struct sConstStruct
{
    char* mConst;
    unsigned int mSize;
    unsigned int mLen;
};

typedef struct sConstStruct sConst;



void sConst_init(sConst* self);
void sConst_init_with_size(sConst* self, unsigned int size);
void sConst_free(sConst* self);
void sConst_clone(sConst* self, sConst* constant);

unsigned int sConst_append(sConst* self, void* data, int size, int no_output);
unsigned int append_int_value_to_constant_pool(sConst* constant, int n, int no_output);
unsigned int append_float_value_to_constant_pool(sConst* constant, float n, int no_output);
unsigned int append_double_value_to_constant_pool(sConst* constant, double n, int no_output);
unsigned int append_str_to_constant_pool(sConst* constant, char* str, int no_output);
void append_buffer_to_constant_pool_and_code(sConst* constant, sByteCode* code, char* buf, int size, int no_output);
unsigned int append_wstr_to_constant_pool(sConst* constant, char* str, int no_output);
void append_str_to_constant_pool_and_code(sConst* constant, sByteCode* code, char* str, int no_output);


struct sCLStackStruct {
    CLVALUE* mStack;
    CLVALUE** mStackPtr;

    int mStackID;
    int mGlobalStack;

    struct sCLStackStruct* mNextStack;
};

typedef struct sCLStackStruct sCLStack;

void stack_init();
void stack_final();

sCLStack* append_stack_to_stack_list(CLVALUE* stack_mem, CLVALUE** stack_ptr, int global);
int remove_stack_to_stack_list(sCLStack* stack);
int check_variables_existance_on_stack(CLVALUE* stack, CLVALUE* stack_ptr);

struct sVMInfoStruct;

void create_global_stack_and_append_it_to_stack_list(struct sVMInfoStruct* info);
void push_value_to_global_stack(CLVALUE value, struct sVMInfoStruct* info);
void push_object_to_global_stack(CLObject obj, struct sVMInfoStruct* info);
void free_global_stack(struct sVMInfoStruct* info);
CLVALUE pop_global_stack(struct sVMInfoStruct* info);

extern sCLStack* gHeadStack;
# 199 "./common.h"
struct sCLTypeStruct;

struct sCLBlockTypeStruct {
    struct sCLTypeStruct* mParams[32];
    int mNumParams;

    struct sCLTypeStruct* mResultType;
};

typedef struct sCLBlockTypeStruct sCLBlockType;

struct sCLTypeStruct {
    unsigned int mClassNameOffset;

    int mNumGenericsTypes;
    struct sCLTypeStruct* mGenericsTypes[32];

    int mArray;
    int mNullable;

    sCLBlockType* mBlockType;
};

typedef struct sCLTypeStruct sCLType;

struct sCLParamStruct {
    unsigned int mNameOffset;

    sCLType* mType;

    unsigned int mDefaultValueOffset;
};

typedef struct sCLParamStruct sCLParam;
# 245 "./common.h"
struct sVMInfoStruct {
    char* try_catch_label_name;

    CLVALUE* current_stack;
    int current_var_num;
    int try_offset;
    char** try_pc;
    sByteCode* try_code;

    struct sCLClassStruct* running_class;
    struct sCLMethodStruct* running_method;

    sCLStack* stack_id;
    char exception_message[1024];

    char stack_trace_sname[64][128];
    int stack_trace_sline[64];

    int num_stack_trace;

    int no_mutex_in_vm;

    int andand_oror_left_value[32];
    int andand_oror_right_value[32];
    int num_andand_oror;

    int running_thread;

    int prohibit_delete_global_stack;

    CLVALUE* mGlobalStack;
    CLVALUE* mGlobalStackPtr;
    int mSizeGlobalStack;
    sCLStack* mGlobalStackID;

    CLVALUE* mTmpGlobalStack;
    CLVALUE* mTmpGlobalStackPtr;
    int mTmpSizeGlobalStack;
    sCLStack* mTmpGlobalStackID;

    char* try_catch_label_name_before;
    int try_offset_before;
    sByteCode* try_code_before;

    char* running_class_name;
    char* running_method_name;

    char sname[128];
    int sline;
    char sname2[128];
    int sline2;

    sBuf* js_source;
    sConst* js_const;

    sBuf* js_class_source;
    int js_compiling_class_source;

    sBuf* require_source;

    int in_finalize_method;

    CLVALUE* stack;
};

typedef struct sVMInfoStruct sVMInfo;

typedef int (*fNativeMethod)(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

struct sCLMethodStruct {
    long long mFlags;
    unsigned int mNameOffset;
    unsigned int mPathOffset;
    unsigned int mMethodNameAndParamsOffset;
    unsigned int mJSMethodNameAndParamsOffset;
    unsigned int mJSMethodNameOffset;
    int mMethodIndex;

    sCLParam mParams[32];
    int mNumParams;

    sCLType* mResultType;

    sByteCode mByteCodes;
    fNativeMethod mNativeMethod;
    char* mNativeFunName;
    sBuf* mNativeCodes;

    int mVarNum;

    void* mJITDynamicSym;

    int mNumGenerics;
    unsigned int mGenericsParamTypeOffsets[32];

    unsigned int mCLibraryOffset;
    void* mCFunctionPointer;
};

typedef struct sCLMethodStruct sCLMethod;







struct sCLFieldStruct {
    long long mFlags;
    unsigned int mNameOffset;

    sCLType* mResultType;
    CLVALUE mValue;

    int mInitializeValue;

    int mDelegatedMethodIndex[512];
    int mNumDelegatedMethod;
    int mNumGetterMethodIndex;
};

struct sCLBlockObjectStruct {
    sByteCode mByteCodes;
    sConst mConst;
    int mVarNum;
    int mNumParams;
    int mLambda;
};

typedef struct sCLBlockObjectStruct sCLBlockObject;

typedef struct sCLFieldStruct sCLField;
typedef void (*fFreeFun)(CLObject self);

struct sCLClassStruct {
    long long mFlags;

    int mGenericsParamClassNum;
    int mMethodGenericsParamClassNum;
    int mNumGenerics;

    unsigned int mGenericsParamNameOffsets[32];
    unsigned int mGenericsParamTypeOffsets[32];

    sConst mConst;

    unsigned int mClassNameOffset;

    sCLMethod* mMethods;
    int mNumMethods;
    int mSizeMethods;

    sCLField* mFields;
    int mNumFields;
    int mSizeFields;

    sCLField* mClassFields;
    int mNumClassFields;
    int mSizeClassFields;

    sCLBlockObject* mBlockObjects;
    int mNumBlockObjects;
    int mSizeBlockObjects;

    int mClassInitializeMethodIndex;
    int mClassFinalizeMethodIndex;
    int mFinalizeMethodIndex;
    int mCallingMethodIndex;
    int mCallingClassMethodIndex;
    int mAllocSizeMethodIndex;

    int mMethodIndexOnCompileTime;
    int mInitMethodIndexOnCompileTime;
    sCLMethod* mVirtualMethodTable[512];

    struct sCLClassStruct* mBoxingClass;
    struct sCLClassStruct* mUnboxingClass;
    void* mDynamicLibrary;

    fFreeFun mFreeFun;

    unsigned int mTypedefClassName1Offsets[32];
    unsigned int mTypedefClassName2Offsets[32];
    int mNumTypedef;

    unsigned int mUnboxingClassNameOffset;

    int mInitialized;

    int mLabelNum;

    int mVersion;

    int mAlreadyLoadedJSClass;
};

typedef struct sCLClassStruct sCLClass;
# 450 "./common.h"
void class_init();
void class_final();

void reset_js_load_class();
sCLClass* get_class_with_load(char* class_name, int js);
sCLClass* get_class(char* class_name, int js);
unsigned int get_hash_key(char* name, unsigned int max);
sCLClass* alloc_class(char* class_name, int primitive_, int generics_param_class_num, int method_generics_param_class_num, int generics_number, char name_of_generics_params[32][64], sCLClass** type_of_generics_params, int interface, int dynamic_class, int no_free_object, int lambda, sCLClass* unboxing_class, int version, int js, int native_);
      sCLType* create_cl_type(sCLClass* klass, sCLClass* klass2);
void free_cl_type(sCLType* cl_type);
sCLClass* get_class(char* class_name, int js);
sCLMethod* search_for_method_from_virtual_method_table(sCLClass* klass, char* method_name_and_params);
int is_valid_class(sCLClass* klass);
int put_class_to_table(char* class_name, sCLClass* klass);
int jit_compile_all_classes();
sCLClass* load_class_from_class_file(char* class_name, char* class_file_name);
void set_boxing_and_unboxing_classes();
int search_for_class_file(char* class_name, char* class_file_name, size_t class_file_name_size, int version, int js);
int is_class_file_existance(char* class_name, int version, int js);
sCLClass* load_class(char* class_name, int version, int js);

struct sClassTableStruct
{
    char* mName;
    sCLClass* mItem;
    int mFreed;
    int mInitialized;

    struct sClassTableStruct* mNextClass;
};

typedef struct sClassTableStruct sClassTable;

extern sClassTable* gHeadClassTable;
extern sClassTable* gJSHeadClassTable;

int create_virtual_method_table(sCLClass* klass);


struct sNodeBlockTypeStruct;

struct sNodeTypeStruct {
    sCLClass* mClass;

    struct sNodeTypeStruct* mGenericsTypes[32];
    int mNumGenericsTypes;

    int mArray;
    int mNullable;
            struct sNodeBlockTypeStruct* mBlockType;
};

typedef struct sNodeTypeStruct sNodeType;

void init_node_types();
void free_node_types();
int is_delegated_class(sNodeType* left_class, sNodeType* right_class);
sNodeType* alloc_node_type();
sNodeType* clone_node_type(sNodeType* node_type);
sNodeType* create_node_type_with_class_name(char* class_name, int js);
sNodeType* create_node_type_with_class_name(char* class_name, int js);
sNodeType* create_node_type_with_method_generics_number(int generics_num, int js);
sNodeType* create_node_type_from_cl_type(sCLType* cl_type, sCLClass* klass);
sNodeType* create_node_type_with_class_pointer(sCLClass* klass);

struct sParserInfoStruct;
int is_exception_type(sNodeType* exception_type);

int substitution_posibility(sNodeType* left, sNodeType* right, sNodeType* left_generics_types, sNodeType* right_generics_types, sNodeType* left_method_generics, sNodeType* right_method_generics, int output_message);
int cast_posibility(sNodeType* left_type, sNodeType* right_type);
sNodeType* create_node_type_with_generics_number(int generics_num, int js);
int substitution_posibility_with_class_name(sNodeType* left, char* right_class_name, int output_message);
int operand_posibility_with_class_name(sNodeType* left, char* right_class_name, char* op_string);
int operand_posibility(sNodeType* left, sNodeType* right, char* op_string);
int solve_generics_types_for_node_type(sNodeType* node_type, sNodeType** result, sNodeType* generics_type, int solve_self, int solve_method_generics);
void solve_generics_for_variable_to_class(sCLClass* klass, sCLClass** result, struct sParserInfoStruct* info);
void solve_method_generics_for_variable_to_class(sCLClass* klass, sCLClass** result, struct sParserInfoStruct* info);
void solve_generics_for_variable(sNodeType* generics_type, sNodeType** generics_type2, struct sParserInfoStruct* info);
int type_identify_with_class_name(sNodeType* left, char* right_class_name);
int type_identify(sNodeType* left, sNodeType* right);
int class_identify_with_class_name(sCLClass* klass, char* class_name);
void print_node_type(sNodeType* node_type);
int boxing_posibility(sNodeType* left_type, sNodeType* right_type);
void boxing_to_lapper_type(sNodeType** type_);
int unboxing_posibility(sNodeType* left_type, sNodeType* right_type);
int unboxig_posibility(sCLClass* klass);
sNodeType* create_generics_types_from_generics_params(sCLClass* klass);
struct sCompileInfoStruct;
void boxing_to_lapper_class(sNodeType** type_, struct sCompileInfoStruct* info);
int unboxing_to_primitive_type(sNodeType** left_type, struct sCompileInfoStruct* info);
void make_boxing_type(sNodeType* type, sNodeType** result);
int no_cast_types_for_binary_operator(sNodeType* left_type, sNodeType* right_type);



struct sNodeBlockTypeStruct {
    sNodeType* mParams[32];
    int mNumParams;

    sNodeType* mResultType;

    int mLambda;
};

typedef struct sNodeBlockTypeStruct sNodeBlockType;

void init_node_block_types();
void free_node_block_types();
sNodeBlockType* alloc_node_block_type();
sNodeBlockType* clone_node_block_type(sNodeBlockType* block);
int substitution_posibility_for_node_block_type(sNodeBlockType* left_block, sNodeBlockType* right_block, sNodeType* left_generics_types, sNodeType* right_generics_types, int output_message);
void free_block(CLObject self);


struct sVarStruct {
    char mName[64];
    int mIndex;
    sNodeType* mType;

    int mBlockLevel;

    int mReadOnly;
};

typedef struct sVarStruct sVar;



struct sVarTableStruct {
    sVar mLocalVariables[1024];
    int mVarNum;
    int mMaxBlockVarNum;

    int mBlockLevel;

    struct sVarTableStruct* mParent;
    struct sVarTableStruct* mNext;
};

typedef struct sVarTableStruct sVarTable;

void init_vtable();
void final_vtable();

sVarTable* init_block_vtable(sVarTable* lv_table);

sVarTable* init_var_table();
sVarTable* clone_var_table(sVarTable* lv_table);
void restore_var_table(sVarTable* left, sVarTable* right);

void set_max_block_var_num(sVarTable* new_table, sVarTable* lv_table);

int get_variable_index(sVarTable* table, char* name);
void check_already_added_variable(sVarTable* table, char* name, struct sParserInfoStruct* info);


int add_variable_to_table(sVarTable* table, char* name, sNodeType* type_, int readonly);


sVar* get_variable_from_table(sVarTable* table, char* name);


sVar* get_variable_from_index(sVarTable* table, int index);

int get_var_num(sVarTable* table);
void show_vtable(sVarTable* table);

int get_parent_var_num_of_sum(sVarTable* table);


extern int gInterpreter;

extern char** gCommandNames;
extern int gNumCommandNames;

struct sGenericsParamInfoStruct
{
    char mParamNames[32][64];
    int mNumParams;
    sCLClass* mInterface[32];
};

typedef struct sGenericsParamInfoStruct sGenericsParamInfo;

struct sCompileInfoStruct;

struct sParserInfoStruct
{
    char* p;
    char* sname;
    char* source;
    int sline;
    int err_num;
    sVarTable* lv_table;
    int parse_phase;
    sCLClass* klass;
    sGenericsParamInfo generics_info;
    sGenericsParamInfo method_generics_info;
    struct sCompileInfoStruct* cinfo;
    int included_source;
    int get_type_for_interpreter;
    int get_in_the_shell_mode;
    int inputing_shell_mode;
    int next_command_is_to_bool;
    int exist_block_object_err;
    int exist_brace_unclosed;
    int get_path_object;
    int inputing_path_object;
    int multiple_assignment;
    int mJS;
};

typedef struct sParserInfoStruct sParserInfo;

void parser_init();
void parser_final();
struct sParserParamStruct;
int parse_params_and_entry_to_lvtable(struct sParserParamStruct* params, int* num_params, sParserInfo* info, sVarTable** new_table, sVarTable* parent_lv_table, int character_type);
void parser_err_msg(sParserInfo* info, const char* msg, ...);
int expression(unsigned int* node, sParserInfo* info);
void skip_spaces_and_lf(sParserInfo* info);
void expect_next_character_with_one_forward(char* characters, sParserInfo* info);
int parse_word(char* buf, int buf_size, sParserInfo* info, int print_out_err_msg, int no_skip_lf);
int parse_type(sNodeType** result_type, sParserInfo* info);
int parse_class_type(sCLClass** klass, sParserInfo* info);
int parse_method_params(int* num_params, unsigned int* params, sParserInfo* info);
int parse_block_object(unsigned int* node, sParserInfo* info, int lambda);
int parse_simple_lambda_params(unsigned int* node, sParserInfo* info, int lambda);


struct sNodeBlockStruct
{
    unsigned int* mNodes;
    unsigned int mSizeNodes;
    unsigned int mNumNodes;

    sVarTable* mLVTable;
    int mUnClosedBlock;

    sBuf mSource;
    char* mSName;
    int mSLine;
};

typedef struct sNodeBlockStruct sNodeBlock;

void sNodeBlock_free(sNodeBlock* block);
sNodeBlock* sNodeBlock_clone(sNodeBlock* block);
int parse_block( sNodeBlock** node_block, sParserInfo* info, sVarTable* new_table, int block_object, int string_expression);
int create_null_block( sNodeBlock** node_block, sParserInfo* info, sVarTable* new_table, int block_object);
int parse_question_operator_block(unsigned int object_node, int num_method_chains, sNodeBlock** node_block, sParserInfo* info);


enum eNodeType { kNodeTypeOperand, kNodeTypeByteValue, kNodeTypeCByteValue, kNodeTypeUByteValue, kNodeTypeCUByteValue, kNodeTypeShortValue, kNodeTypeCShortValue, kNodeTypeUShortValue, kNodeTypeCUShortValue, kNodeTypeIntValue, kNodeTypeCIntValue, kNodeTypeUIntValue, kNodeTypeCUIntValue, kNodeTypeLongValue, kNodeTypeCLongValue, kNodeTypeULongValue, kNodeTypeCULongValue, kNodeTypeAssignVariable, kNodeTypeLoadVariable, kNodeTypeIf, kNodeTypeWhile, kNodeTypeBreak, kNodeTypeTrue, kNodeTypeFalse, kNodeTypeNull, kNodeTypeWildCard, kNodeTypeFor, kNodeTypeClassMethodCall, kNodeTypeMethodCall, kNodeTypeReturn, kNodeTypeNewOperator, kNodeTypeLoadField, kNodeTypeStoreField , kNodeTypeLoadClassField, kNodeTypeStoreClassField, kNodeTypeLoadValueFromPointer, kNodeTypeStoreValueToPointer, kNodeTypeMonadicIncrementOperand, kNodeTypeMonadicDecrementOperand, kNodeTypeLoadArrayElement, kNodeTypeStoreArrayElement, kNodeTypeChar, kNodeTypeString, kNodeTypeBuffer, kNodeTypeThrow, kNodeTypeTry, kNodeTypeBlockObject, kNodeTypeFunction, kNodeTypeBlockCall, kNodeTypeNormalBlock, kNodeTypeArrayValue, kNodeTypeAndAnd, kNodeTypeOrOr, kNodeTypeHashValue, kNodeTypeRegex, kNodeTypeListValue, kNodeTypeSortableListValue, kNodeTypeEqualableListValue, kNodeTypeTupleValue, kNodeTypeCArrayValue, kNodeTypeEqualableCArrayValue, kNodeTypeSortableCArrayValue, kNodeTypeImplements, kNodeTypeGetAddress, kNodeTypeInheritCall, kNodeTypeFloatValue, kNodeTypeCFloatValue, kNodeTypeDoubleValue, kNodeTypeCDoubleValue, kNodeTypePath, kNodeTypeWhen, kNodeTypeRange, kNodeTypeMultipleAsignment, kNodeTypeJSArray, kNodeTypeRequire };

enum eOperand { kOpAdd, kOpSub , kOpComplement, kOpLogicalDenial, kOpMult, kOpDiv, kOpMod, kOpLeftShift, kOpRightShift, kOpComparisonEqual, kOpComparisonNotEqual,kOpComparisonGreaterEqual, kOpComparisonLesserEqual, kOpComparisonGreater, kOpComparisonLesser, kOpAnd, kOpXor, kOpOr, kOpMinus };

struct sParserParamStruct
{
    char mName[64];
    sNodeType* mType;

    char mDefaultValue[128];
};

typedef struct sParserParamStruct sParserParam;

struct sNodeTreeStruct
{
    enum eNodeType mNodeType;

    unsigned int mLeft;
    unsigned int mRight;
    unsigned int mMiddle;

    char* mSName;
    int mLine;

    union {
        enum eOperand mOperand;
        char mByteValue;
        unsigned char mUByteValue;
        short mShortValue;
        unsigned short mUShortValue;
        int mIntValue;
        unsigned int mUIntValue;
        long long mLongValue;
        unsigned long long mULongValue;
        char mVarName[64];

        struct {
            char mVarName[64];
            sCLClass* mClass;
        } sAssignVariable;

        struct {
            char mClassName[64];
            char mFileName[64];
        } sRequire;

        struct {
            unsigned int mExpressionNode;
                    sNodeBlock* mIfNodeBlock;
            unsigned int mElifExpressionNodes[32];
                    sNodeBlock* mElifNodeBlocks[32];
            int mElifNum;
                    sNodeBlock* mElseNodeBlock;
            int mIfUnclosed;
            int mElifUnclosed[32];
        } sIf;
        struct {
            unsigned int mExpressionNode;
            int mNumWhenBlock;
            int mValueNodes[32][32];
            int mNumValues[32];
            sNodeBlock* mWhenBlocks[32];
            sNodeType* mWhenTypes[32];
            sNodeType* mWhenTypes2[32];
            int mMatch[32];
            sNodeBlock* mElseBlock;
        } sWhen;
        struct {
            unsigned int mExpressionNode;
                    sNodeBlock* mWhileNodeBlock;
        } sWhile;
        struct {
            unsigned int mExpressionNode;
            unsigned int mExpressionNode2;
            unsigned int mExpressionNode3;
                    sNodeBlock* mForNodeBlock;
        } sFor;
        struct {
                    sNodeBlock* mTryNodeBlock;
                    sNodeBlock* mCatchNodeBlock;
            char mExceptionVarName[64];
        } sTry;
        struct {
            sNodeType* mClass;
            char mMethodName[64];
            unsigned int mParams[32];
            int mNumParams;
        } sClassMethodCall;
        struct {
            char mMethodName[64];
            unsigned int mParams[32];
            int mNumParams;
            int mNumMethodChains;
        } sMethodCall;
        struct {
            sNodeType* mType;
            unsigned int mParams[32];
            int mNumParams;
            unsigned int mArrayNum;
        } sNewOperator;
        struct {
            char mVarName[64];
            sCLClass* mClass;
        } sClassField;

        wchar_t mCharacter;
        struct {
            char* mString;
            sNodeBlock* mStringExpressions[16];
            int mStringExpressionOffsets[16];
            int mNumStringExpression;
        } sString;

        struct {
            char* mBuffer;
            int mLen;
            sNodeBlock* mStringExpressions[16];
            int mStringExpressionOffsets[16];
            int mNumStringExpression;
        } sBuffer;

        struct {
            sParserParam mParams[32];
            int mNumParams;
            sNodeType* mResultType;
            sNodeBlock* mBlockObjectCode;
            int mLambda;
            int mOmitResultType;
            int mOmitParams;
            sVarTable* mOldTable;

            int mQuestionOperator;
            sCLClass* mClass;
        } sBlockObject;

        struct {
            char mName[64];
            sParserParam mParams[32];
            int mNumParams;
            sNodeType* mResultType;
            sNodeBlock* mBlockObjectCode;
            int mLambda;
            sCLClass* mClass;
        } sFunction;

        struct {
            char mBlockName[64];
            unsigned int mParams[32];
            int mNumParams;
        } sBlockCall;

        struct {
            unsigned int mParams[32];
            int mNumParams;
            int mMethodIndex;
        } sInheritCall;

        sNodeBlock* mBlock;

        struct {
            unsigned int mArrayElements[32];
            int mNumArrayElements;
        } sArrayValue;
        struct {
            unsigned int mListElements[32];
            int mNumListElements;
        } sListValue;
        struct {
            unsigned int mTupleElements[32];
            int mNumTupleElements;
        } sTupleValue;
        struct {
            unsigned int mHashKeys[32];
            unsigned int mHashItems[32];
            int mNumHashElements;
        } sHashValue;
        struct {
            char* mRegexStr;
            int mGlobal;
            int mIgnoreCase;
            int mMultiline;
            int mExtended;
            int mDotAll;
            int mAnchored;
            int mDollarEndOnly;
            int mUngreedy;
            sNodeBlock* mStringExpressions[16];
            int mStringExpressionOffsets[16];
            int mNumStringExpression;
        } sRegex;

        float mFloatValue;
        double mDoubleValue;
    } uValue;

    sNodeType* mType;
    int mMaxMethodChains;
};

typedef struct sNodeTreeStruct sNodeTree;

struct sCompileInfoStruct
{
    sByteCode* code;
    sConst* constant;
    int stack_num;
    sVarTable* lv_table;
    int no_output;
    int err_num;
    struct sParserInfoStruct* pinfo;
    sNodeType* type;
    int* num_break_points;
    int* break_points;
    sCLMethod* method;
    sNodeType* block_result_type;
    int in_block;
    int omit_block_result_type;
    sNodeType* block_last_type;
    char* sname;
    int sline;

    char* break_point_label_name;
    int no_pop_next;

    sNodeType* question_operator_result_type;

    int mNumBlockObject;
};

typedef struct sCompileInfoStruct sCompileInfo;

extern sNodeTree* gNodes;

void init_nodes();
void free_nodes();
void show_node(unsigned int node);
unsigned int clone_node(unsigned int node);

void compile_err_msg(sCompileInfo* info, const char* msg, ...);
int compile(unsigned int node, sCompileInfo* info);
void append_class_name_to_constant_pool_and_code(sCompileInfo* info, sCLClass* klass);
void create_type_name_from_node_type(char* type_name, int type_name_max, sNodeType* node_type);
int get_var_size(sNodeType* var_type);
void boxing_before_method_call(char* method_name, sCompileInfo* info, int* array_and_special_method);

unsigned int sNodeTree_create_operand(enum eOperand operand, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_js_array(int num_elements, unsigned int list_elements[], sParserInfo* info);
unsigned int sNodeTree_create_multiple_asignment(int num_elements, unsigned int tuple_elements[], int right_value, sParserInfo* info);
unsigned int sNodeTree_when_expression(unsigned int expression_node, unsigned int value_nodes[32][32], int num_values[32], sNodeBlock* when_blocks[32], int num_when_block, sNodeBlock* else_block, sNodeType* when_types[32], sNodeType* when_types2[32], int when_match[32], sParserInfo* info, char* sname, int sline);
unsigned int sNodeTree_if_expression(unsigned int expression_node, sNodeBlock* if_node_block, unsigned int* elif_expression_nodes, sNodeBlock** elif_node_blocks, int elif_num, sNodeBlock* else_node_block, int if_unclosed, int* elif_unclosed, sParserInfo* info, char* sname, int sline);
unsigned int sNodeTree_create_range(unsigned int head, unsigned int tail, sParserInfo* info);
unsigned int sNodeTree_create_byte_value(char value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cbyte_value(char value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_ubyte_value(unsigned char value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cubyte_value(unsigned char value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_short_value(short value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cshort_value(short value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_ushort_value(unsigned short value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cushort_value(unsigned short value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_int_value(int value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cint_value(int value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_uint_value(unsigned int value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cuint_value(unsigned int value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_long_value(long long value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_clong_value(long long value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_ulong_value(unsigned long long value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_culong_value(unsigned long long value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_store_variable(char* var_name, sNodeType* node_type, int right, sCLClass* klass, sParserInfo* info);
unsigned int sNodeTree_create_assign_field(char* var_name, unsigned int left_node, unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_load_variable(char* var_name, sParserInfo* info);
unsigned int sNodeTree_create_return_expression(unsigned int expression_node, sParserInfo* info);
unsigned int sNodeTree_create_throw_expression(unsigned int expression_node, sParserInfo* info);
unsigned int sNodeTree_while_expression(unsigned int expression_node, sNodeBlock* while_node_block, sParserInfo* info);
unsigned int sNodeTree_break_expression(sParserInfo* info);
unsigned int sNodeTree_false_expression(sParserInfo* info);
unsigned int sNodeTree_true_expression(sParserInfo* info);
unsigned int sNodeTree_null_expression(sParserInfo* info);
unsigned int sNodeTree_wildcard_expression(sParserInfo* info);
unsigned int sNodeTree_for_expression(unsigned int expression_node1, unsigned int expression_node2, unsigned int expression_node3, sNodeBlock* for_node_block, sParserInfo* info);
int check_node_is_variable(unsigned int node);
unsigned int sNodeTree_create_class_method_call(sNodeType* klass, char* method_name, unsigned int* params, int num_params, sParserInfo* info);
unsigned int sNodeTree_create_method_call(unsigned int object_node, char* method_name, unsigned int* params, int num_params, int num_method_chains, sParserInfo* info);
unsigned int sNodeTree_create_new_operator(sNodeType* node_type, unsigned int* params, int num_params, unsigned int array_num, sParserInfo* info);
unsigned int sNodeTree_create_fields(char* name, unsigned int left_node, sParserInfo* info);
unsigned int sNodeTree_create_class_fields(sCLClass* klass, char* name, sParserInfo* info);
unsigned int sNodeTree_create_assign_class_field(sCLClass* klass, char* name , unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_store_value_to_pointer(unsigned int left_node, sNodeType* node_type, unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_load_value_from_pointer(unsigned int left_node, sNodeType* node_type, sParserInfo* info);
int sNodeTree_create_monadic_decrement_operand(unsigned int right_node, sParserInfo* info);
int sNodeTree_create_monadic_increment_operand(unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_load_array_element(unsigned int array, unsigned int index_node, sParserInfo* info);
unsigned int sNodeTree_create_store_array_element(unsigned int array, unsigned int index_ndoe, unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_character_value(wchar_t c, sParserInfo* info);

unsigned int sNodeTree_create_string_value( char* value, sNodeBlock** string_expressions, int* string_expression_offsets, int num_string_expression, sParserInfo* info);
unsigned int sNodeTree_create_buffer_value( char* value, int len, sNodeBlock** string_expressions, int* string_expression_offsets, int num_string_expression, sParserInfo* info);
unsigned int sNodeTree_try_expression( sNodeBlock* try_node_block, sNodeBlock* catch_node_block, char* exception_var_name, sParserInfo* info);

unsigned int sNodeTree_create_block_object(sParserParam* params, int num_params, sNodeType* result_type, sNodeBlock* node_block, int lambda, sParserInfo* info, int omit_result_type, int omit_params, sVarTable* old_table, int question_operator);
unsigned int sNodeTree_create_block_call(unsigned int block, char* block_name, int num_params, unsigned int params[], sParserInfo* info);
unsigned int sNodeTree_conditional_expression(unsigned int expression_node, unsigned int true_expression_node, unsigned int false_expression_node, sParserInfo* info);
unsigned int sNodeTree_create_normal_block( sNodeBlock* node_block, sParserInfo* info);
unsigned int sNodeTree_create_array_value(int num_elements, unsigned int array_elements[], sParserInfo* info);
unsigned int sNodeTree_create_list_value(int num_elements, unsigned int list_elements[], sParserInfo* info);
unsigned int sNodeTree_create_equalable_list_value(int num_elements, unsigned int list_elements[], sParserInfo* info);
unsigned int sNodeTree_create_sortable_list_value(int num_elements, unsigned int list_elements[], sParserInfo* info);
unsigned int sNodeTree_create_tuple_value(int num_elements, unsigned int tuple_elements[], sParserInfo* info);
unsigned int sNodeTree_create_or_or(unsigned int left_node, unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_and_and(unsigned int left_node, unsigned int right_node, sParserInfo* info);
unsigned int sNodeTree_create_hash_value(int num_elements, unsigned int hash_keys[], unsigned int hash_items[], sParserInfo* info);
unsigned int sNodeTree_create_regex( char* regex_str, int global, int ignore_case, int multiline, int extended, int dotall, int anchored, int dollar_endonly, int ungreedy, sNodeBlock** string_expressions, int* string_expression_offsets, int num_string_expression, sParserInfo* info);
unsigned int sNodeTree_create_carray_value(int num_elements, unsigned int array_elements[], sParserInfo* info);
unsigned int sNodeTree_create_equalable_carray_value(int num_elements, unsigned int array_elements[], sParserInfo* info);
unsigned int sNodeTree_create_sortable_carray_value(int num_elements, unsigned int array_elements[], sParserInfo* info);
unsigned int sNodeTree_create_implements(unsigned int lnode, char* interface_name, sParserInfo* info);
unsigned int sNodeTree_create_get_address(unsigned int node, sParserInfo* info);
unsigned int sNodeTree_create_require(char* class_name, char* file_name, sParserInfo* info);
unsigned int sNodeTree_create_inherit_call(int num_params, unsigned int params[], int method_index, sParserInfo* info);
unsigned int sNodeTree_create_float_value(float value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cfloat_value(float value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_double_value(double value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_cdouble_value(double value, unsigned int left, unsigned int right, unsigned int middle, sParserInfo* info);
unsigned int sNodeTree_create_path_value( char* value, int len, sNodeBlock** string_expressions, int* string_expression_offsets, int num_string_expression, sParserInfo* info);
unsigned int sNodeTree_create_function(char* fun_name, sParserParam* params, int num_params, sNodeType* result_type, sNodeBlock* node_block, int lambda, sParserInfo* info);

void arrange_stack(sCompileInfo* cinfo);


int compile_block(sNodeBlock* block, sCompileInfo* info, sNodeType* result_type, sNodeType** block_last_type);
int compile_block_with_result(sNodeBlock* block, sCompileInfo* info);


int compile_script(char* fname, char* source, int js);
int read_source(char* fname, sBuf* source);
int delete_comment(sBuf* source, sBuf* source2);
void append_cwd_for_path(char* fname, char* fname2);


int eval_file(char* fname, int stack_size);


void cast_right_type_to_byte(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_short(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_int(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_long(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_ubyte(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_ushort(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_uint(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_ulong(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_float(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_double(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_char(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_bool(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_pointer(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_String(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Byte(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_UByte(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Short(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_UShort(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Integer(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_UInteger(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Long(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_ULong(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Float(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Double(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Pointer(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Char(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Bool(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_Array(sNodeType** right_type, sCompileInfo* info);
void cast_right_type_to_left_type(sNodeType* left_type, sNodeType** right_type, sCompileInfo* info);


void show_stack(CLVALUE* stack, CLVALUE* stack_ptr);

extern int gSigInt;
extern int gRunningInitializer;
extern int gBufferToPointerCastCount;
# 1927 "./common.h"
int vm(sByteCode* code, sConst* constant, CLVALUE* stack, int var_num, sCLClass* klass, sVMInfo* info);
sCLClass* get_class_with_load_and_initialize(char* class_name, int js);
void class_final_on_runtime();
int call_finalize_method_on_free_object(sCLClass* klass, CLObject self);
int call_alloc_size_method(sCLClass* klass, unsigned long long* result);
void callOnException(CLObject message, int in_try, sVMInfo* info);
int invoke_method(sCLClass* klass, sCLMethod* method, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info);
int invoke_block(CLObject block_object, CLVALUE* stack, int var_num, int num_params, CLVALUE** stack_ptr, sVMInfo* info);
int class_init_on_runtime();
int class_init_on_runtime_for_js();
void boxing_primitive_value_to_object(CLVALUE object, CLVALUE* result, sCLClass* klass, sVMInfo* info);
void Self_convertion_of_method_name_and_params(char* method_name_and_params, char* method_name_and_params2, char* class_name);
void set_free_fun_to_classes();
int call_all_class_initializer();
void show_inst(unsigned inst);
# 1954 "./common.h"
int compile_class_source(char* fname, char* source);
int parse_method_name_and_params(char* method_name, int method_name_max, sParserParam* params, int* num_params, sNodeType** result_type, int* native_, int* static_, int* dynamic_, int* pure_native_, sParserInfo* info, char* clibrary_path, size_t clibrary_path_size);


void set_dependency_compile();
int dependency_check(char* fname);
int dependency_compile(char* cwd, char* class_name, char* class_file_name, size_t class_file_name_size);
void dependency_final();


void add_native_code_to_method(sCLMethod* method, sBuf* native_code);
int add_method_to_class(sCLClass* klass, char* method_name, sParserParam* params, int num_params, sNodeType* result_type, int native_, int static_, int dynamic_, int pure_native_, sGenericsParamInfo* ginfo, sCLMethod** appended_method, char* clibrary_path, sParserInfo* info);
int add_block_object_to_class(sCLClass* klass, sByteCode codes, sConst constant, int var_num, int num_params, int lambda);
int add_typedef_to_class(sCLClass* klass, char* class_name1, char* class_name2);
int add_class_field_to_class(sCLClass* klass, char* name, int private_, int protected_, int readonly, sNodeType* result_type, int initialize_value, char* header_path);
void add_code_to_method(sCLMethod* method, sByteCode* code, int var_num);
int write_all_modified_classes();
int search_for_method(sCLClass* klass, char* method_name, sNodeType** param_types, int num_params, int search_for_class_method, int start_point, sNodeType* left_generics_type, sNodeType* right_generics_type, sNodeType* right_method_generics, sNodeType** result_type, int lazy_lambda_compile, sNodeType** method_generics_types, struct sParserInfoStruct* info);
int search_for_methods_from_method_name(int method_indexes[], int size_method_indexes, int* num_methods, sCLClass* klass, char* method_name, int start_point, int class_method);
int search_for_field(sCLClass* klass, char* field_name);
int search_for_class_field(sCLClass* klass, char* field_name);
void add_dependences_with_node_type(sCLClass* klass, sNodeType* node_type);
int parse_params(sParserParam* params, int* num_params, sParserInfo* info, int chracter_type);
int check_implemented_methods_for_interface(sCLClass* left_class, sCLClass* right_class, int output_message);
int class_method_name_existance(sCLClass* klass, char* method_name);
int none_class_method_name_existance(sCLClass* klass, char* method_name);
int class_field_name_existance(sCLClass* klass, char* field_name);
int field_name_existance(sCLClass* klass, char* field_name);
void create_method_name_and_params(char* result, int size_result, sCLClass* klass, char* method_name, sNodeType* param_types[32], int num_params);
void create_method_name_and_params_for_js(char* result, int size_result, sCLClass* klass, char* method_name, sNodeType* param_types[32], int num_params);
int determine_method_generics_types(sNodeType* left_param, sNodeType* right_param, sNodeType* method_generics_types);
int is_method_param_name(char* name);
int add_field_to_class(sCLClass* klass, char* name, int private_, int protected_, int delegated, int readonly, sNodeType* result_type);
int add_field_to_class_with_class_name(sCLClass* klass, char* name, int private_, int protected_, int delegated, char* field_type_name);
int add_class_field_to_class_with_class_name(sCLClass* klass, char* name, int private_, int protected_, char* field_type_name, int initialize_value);


void native_method_init();
void native_method_final();

fNativeMethod get_native_method(char* path, char** fun_name);
void put_fun_to_hash_for_native_method(char* path, char* fun_name, fNativeMethod fun);


void entry_exception_object_with_class_name(CLVALUE** stack_ptr, CLVALUE* stack, int var_num, sVMInfo* info, char* class_name, char* msg, ...);
void entry_exception_object(CLObject exception, sVMInfo* info);
void show_exception_message(char* message);
void entry_exception_object_with_class_name2(CLVALUE** stack_ptr, CLVALUE* stack, int var_num, sVMInfo* info, char* class_name, char* msg);


int compile_method(sCLMethod* method, sParserParam* params, int num_params, sParserInfo* info, sCompileInfo* cinfo);


int is_void_type(sCLType* cl_type, sCLClass* klass);
sCLClass* get_class_from_cl_type(sCLType* cl_type, sCLClass* klass);
int is_this_class_with_class_name(sCLClass* klass, char* class_name);
      char* cl_type_to_string(sCLType* cl_type, sCLClass* klass);;


struct sCLHeapMemStruct {
    sCLClass* mClass;
    char* mType;
    int mSize;
    int mArrayNum;
    void* mMem;
};

typedef struct sCLHeapMemStruct sCLHeapMem;



void heap_init(int heap_size, int size_handles);
void heap_final();

CLObject alloc_heap_mem(unsigned int size, sCLClass* klass, int array_num, sVMInfo* info);
sCLHeapMem* get_object_pointer(CLObject obj);
void show_heap(sVMInfo* info);
void mark_object(CLObject obj, unsigned char* mark_flg);
int is_valid_object(CLObject obj);
void gc(sVMInfo* info);
void compaction();
void free_global_stack_objects(sVMInfo* info, CLObject result_object, int num_global_stack_ptr, CLVALUE* lvar, int num_params);

      unsigned char* get_mark_flg(CLObject obj);

void mark_and_store_class_field(sCLClass* klass, int field_index, CLVALUE cl_value);
void mark_singal_handler_object(CLObject obj);
void inc_refference_count(CLObject obj, CLObject prev_obj, int value_is_object);
void dec_refference_count(CLObject obj, int value_is_object);


struct sCLModuleStruct {
    int mModified;
    char mName[64 +1];
    sBuf mBody;
    char mSName[4096];
    int mSLine;
};

typedef struct sCLModuleStruct sCLModule;

void module_init();
void module_final();
sCLModule* create_module(char* module_name, char* sname, int sline);
void unload_module(char* module_name);
void append_character_to_module(sCLModule* self, char c);
void append_str_to_module(sCLModule* self, char* str);
sCLModule* get_module(char* module_name);
char* get_module_body(sCLModule* module);
void write_all_modified_modules();
void this_module_is_modified(sCLModule* self);
int load_module_from_file( sCLModule** self, char* module_name);






struct sCLObjectStruct {
    sCLClass* mClass;
    char* mType;
    int mSize;
    union {
        int mArrayNum;
        int mNumFields;
    };
    union {
        int mHeadOfMemory;
        CLVALUE mFields[32];
    };
};

typedef struct sCLObjectStruct sCLObject;



CLObject create_object(sCLClass* klass, char* type, sVMInfo* info);
int free_object(CLObject self);
void object_mark_fun(CLObject self, unsigned char* mark_flg);
int object_implements_interface(CLObject object, sCLClass* interface);


CLObject create_array_object(sCLClass* klass, int array_num, sVMInfo* info);
void array_mark_fun(CLObject self, unsigned char* mark_flg);
void free_array(CLObject self);


CLObject create_hash_object(char* type_name, sVMInfo* info);
int initialize_hash_object(CLObject hash_object, int num_elements, CLObject* keys, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_keys, sCLClass* class_items);


struct sBlockObjectStruct
{
    sCLClass* mClass;
    char* mType;
    int mSize;
    int mArrayNum;
    sByteCode mCodes;
    sConst mConstant;
    CLVALUE* mParentStack;
    int mParentVarNum;
    int mBlockVarNum;
    int mLambda;
    void* mJITDynamicSym;
    int mBlockID;
    sCLClass* mClass2;
};

typedef struct sBlockObjectStruct sBlockObject;



CLObject create_block_object(sByteCode* codes, sConst* constant, CLVALUE* parent_stack, int parent_var_num, int block_var_num, int lambda, int block_id, sCLClass* klass, sVMInfo* info);
void block_mark_fun(CLObject self, unsigned char* mark_flg);


struct sRegexObjectStruct
{
    sCLClass* mClass;
    char* mType;
    int mSize;
    int mArrayNum;
    pcre* mRegex;
    char* mRegexString;
    int mGlobal;
    int mIgnoreCase;
    int mMultiline;
    int mExtended;
    int mDotAll;
    int mAnchored;
    int mDollarEndOnly;
    int mUngreedy;
};

typedef struct sRegexObjectStruct sRegexObject;



CLObject create_regex_object(char* regex, int global, int ignore_case, int multiline, int extended, int dotall, int anchored, int dollar_endonly, int ungreedy, sVMInfo* info);
void regex_free_fun(CLObject obj);
int regex_equals(CLObject left, CLObject right);


CLObject create_string_object(char* str, sVMInfo* info);
CLObject create_buffer_object(char* buffer, size_t size, sVMInfo* info);
CLObject create_path_object(char* path, sVMInfo* info);
CLObject create_string_from_two_strings(CLObject left, CLObject right);
int get_length_from_string_object(CLObject str);
CLVALUE* get_str_array_from_string_object(CLObject str);


CLObject create_integer(int value, sVMInfo* info);
CLObject create_uinteger(unsigned int value, sVMInfo* info);


CLObject create_byte(char value, sVMInfo* info);
CLObject create_ubyte(unsigned char value, sVMInfo* info);


CLObject create_short(short value, sVMInfo* info);
CLObject create_ushort(unsigned short value, sVMInfo* info);


CLObject create_long(long long value, sVMInfo* info);
CLObject create_ulong(unsigned long long value, sVMInfo* info);


CLObject create_float(float value, sVMInfo* info);
CLObject create_double(double value, sVMInfo* info);


CLObject create_pointer(char* value, sVMInfo* info);


CLObject create_char(wchar_t value, sVMInfo* info);


CLObject create_bool(int value, sVMInfo* info);


int System_exit(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_assert(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_malloc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_realloc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_calloc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_free(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strlen(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strlen2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strcpy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strncpy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strdup(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_print(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_println(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_printlnToError(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_printToError(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_sleep(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pcre_exec(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_sprintf(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_memcpy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_memset(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_memcmp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_mbstowcs(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_wcstombs(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_atof(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_atoi(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strtod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strcmp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strcasecmp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strtol(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strtoul(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_srand(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_rand(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_open(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_close(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_string_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_file_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_read(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_write(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_time(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_localtime(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_mktime(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_stat(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_lstat(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_basename(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dirname(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_realpath(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_opendir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_readdir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_closedir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_command_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pipe(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fork(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dup2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_execvp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_execv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_waitpid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WIFEXITED(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WEXITSTATUS(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WIFSIGNALED(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WTERMSIG(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WCOREDUMP(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WIFSTOPPED(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WSTOPSIG(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_WIFCONTINUED(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getpid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setpgid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_kill(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcsetpgrp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcgetattr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcsetattr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcsendbreak(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcdrain(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcflush(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_tcflow(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfmakeraw(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfgetispeed(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfgetospeed(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfsetispeed(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfsetospeed(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cfsetspeed(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_chmod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_lchmod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fchmod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_chown(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_lchown(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fchown(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_unlink(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_access(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_utime(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fnmatch(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_link(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_symlink(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_readlink(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_rename(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_truncate(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_ftruncate(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_chdir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fchdir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_rmdir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_mkdir(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_clock_getres(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_clock_gettime(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_clock_settime(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getenv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setenv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_unsetenv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dlopen(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dlclose(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dlsym(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_put_fun_to_hash_for_native_method(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_system_calls_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_alarm(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dup(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_dup3(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_execvpe(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fopen(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fclose(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fwrite(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fread(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_feof(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fgetc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fgets(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getchar(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_ungetc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getcwd(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getopt(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getopt_long(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getopt_long_only(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getppid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setsid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getsid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setpgrp(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_gettid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_popen(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pclose(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_thread_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutex_init(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutex_destroy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutex_lock(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutex_unlock(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutex_trylock(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutexattr_gettype(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutexattr_destroy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutexattr_settype(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_mutexattr_init(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_init(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_signal(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_broadcast(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_wait(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_timedwait(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_pthread_cond_destroy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_cgi_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setlocale(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_flock(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_fileno(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getbsize(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getegid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getgid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_geteuid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getuid(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isatty(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_umask(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_usleep(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_nanosleep(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_putenv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_setvbuf(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strncat(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_strchr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_initialize_socket_system(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_socket(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_connect(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_accept(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_accept2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_listen(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_bind(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_inet_addr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_connect2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_bind2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_gethostbyaddr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_gethostbyname(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getservbyport(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getservbyname(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_inet_ntoa(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_gethostname(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_signal(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
void class_system_init();
int System_signal2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int fd_set_allocSize(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_FD_ISSET(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_FD_SET(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_FD_CLR(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_FD_ZERO(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_select(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_ioctl(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_initscr(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_endwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_move(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_GC_malloc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_printw(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_refresh(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_box(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isendwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_clear(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_erase(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_idcok(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_idlok(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_attron(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_attroff(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_attrset(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_echo(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_noecho(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_cbreak(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_nocbreak(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_raw(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_noraw(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_nodelay(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getch(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_mvwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_wrefresh(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_wclear(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getEscapeDelay(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_setEscapeDelay(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_touchwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_keypad(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_newwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_delwin(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_wmove(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_wprintw(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getmaxx(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_getmaxy(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isblank(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isascii(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isxdigit(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isupper(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isspace(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_ispunct(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isprint(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_islower(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isgraph(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isdigit(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_iscntrl(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isalnum(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_isalpha(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_send(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_sendto(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_sendto2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

int System_recv(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_recvfrom(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int System_recvfrom2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

extern CLObject signal_handler_object[256];


void alignment(unsigned int* size);


      wchar_t* string_object_to_wchar_array(CLObject string_object);
      char* string_object_to_char_array(CLObject string_object);
         CLVALUE* get_element_from_array(CLObject array, int index);
         CLVALUE* get_element_from_Array(CLObject array, int index);
int get_element_number_from_Array(CLObject array);
char get_value_from_Byte(CLObject object);
unsigned char get_value_from_UByte(CLObject object);
short get_value_from_Short(CLObject object);
unsigned short get_value_from_UShort(CLObject object);
int get_value_from_Integer(CLObject object);
unsigned int get_value_from_UInteger(CLObject object);
long long get_value_from_Long(CLObject object);
unsigned long long get_value_from_ULong(CLObject object);
wchar_t get_value_from_Char(CLObject object);
float get_value_from_Float(CLObject object);
double get_value_from_Double(CLObject object);
int get_value_from_Bool(CLObject object);
char* get_value_from_Pointer(CLObject object);
sCLClass* get_class_from_object(CLObject object);
void* get_pointer_from_buffer_object(CLObject buffer);
size_t get_size_from_buffer_object(CLObject buffer);
      CLObject* list_to_array(CLObject list, int* num_elements);
void clover_termios_to_c_termios(CLObject terminfo_object, struct termios* terminfo_value);
void c_termios_to_clover_termios(struct termios* terminfo_value, CLObject terminfo_object);
int create_termios_object(CLObject* result, CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);


CLObject create_list_object(char* type_name, sVMInfo* info);
int initialize_list_object(CLObject list_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);
CLObject create_sortable_list_object(char* type_name, sVMInfo* info);
int initialize_sortable_list_object(CLObject list_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);
CLObject create_equalable_list_object(char* type_name, sVMInfo* info);
int initialize_equalable_list_object(CLObject list_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);


CLObject create_tuple_object(int num_elements, char* type_name, sVMInfo* info);
int initialize_tuple_object(CLObject tuple_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info);


CLObject create_carray_object(char* type_name, sVMInfo* info);
CLObject create_equalable_carray_object(char* type_name, sVMInfo* info);
CLObject create_sortable_carray_object(char* type_name, sVMInfo* info);
CLObject create_carray_object_with_elements(int num_elements, CLObject* elements, sVMInfo* info);
int initialize_carray_object(CLObject array_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);
CLObject create_equalable_carray_object_with_elements(int num_elements, CLObject* elements, sVMInfo* info);
int initialize_equalable_carray_object(CLObject array_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);
CLObject create_sortable_carray_object_with_elements(int num_elements, CLObject* elements, sVMInfo* info);
int initialize_sortable_carray_object(CLObject array_object, int num_elements, CLObject* items, CLVALUE* stack, int var_num, CLVALUE** stack_ptr, sVMInfo* info, sCLClass* class_items);


int utf8_index_to_utf32_index(char* str, int utf8index);
int utf32_index_to_utf8_index(char* str, int utf32index);


int Clover_load(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_initialize_lang(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_initialize_reflection(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_appendField(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_appendMethod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_appendMethod2(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_declareMethod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_appendClassField(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getField(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getMethod(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getClassField(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getClassGenericsParamNames(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getClassGenericsParamTypes(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getClassFlags(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getNumFields(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getNumClassFields(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getNumMethods(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_isLoadedClass(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_isDefinedClass(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_appendClass(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getAllClassName(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_createObject(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_createArray(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_isTypedefedClass(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_gc(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_compaction(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Clover_getType(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);


int jit(sByteCode* code, sConst* constant, CLVALUE* stack, int var_num, sCLClass* klass, sCLMethod* method, CLObject block_object, sVMInfo* info, CLVALUE** stack_ptr);
void jit_init();
void jit_final();
int compile_jit_method(sCLClass* klass, sCLMethod* method);
# 2555 "./common.h"
int CLParser_initialize(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);


extern int gARGC;
extern char** gARGV;
extern char* gVersion;
extern int gRunningCompiler;
extern int gCompilingCore;

extern char gScriptDirPath[4096];


void thread_init();
void thread_final();
void vm_mutex_on();
void vm_mutex_off();
int Thread_initialize_thread(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int Thread_pthread_join(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
void new_vm_mutex();
pid_t gettid();
int pthread_mutex_t_allocSize(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);
int pthread_cond_t_allocSize(CLVALUE** stack_ptr, CLVALUE* lvar, sVMInfo* info);

extern int gVMMutexFlg;


int js_compiler(char* sname);
int js_class_compiler(char* class_name);
# 2 "<stdin>" 2






# 1 "/data/data/com.termux/files/usr/include/time.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/time.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/time.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/sys/time.h" 3 4
int gettimeofday(struct timeval* __tv, struct timezone* __tz);
int settimeofday(const struct timeval* __tv, const struct timezone* __tz);

int getitimer(int __which, struct itimerval* __current_value);
int setitimer(int __which, const struct itimerval* __new_value, struct itimerval* __old_value);

int utimes(const char* __path, const struct timeval __times[2]);
# 34 "/data/data/com.termux/files/usr/include/time.h" 2 3 4






extern char* tzname[];
extern int daylight;
extern long int timezone;

struct sigevent;

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long int tm_gmtoff;
  const char* tm_zone;
};



time_t time(time_t* __t);
int nanosleep(const struct timespec* __request, struct timespec* __remainder);

char* asctime(const struct tm* __tm);
char* asctime_r(const struct tm* __tm, char* __buf);

double difftime(time_t __lhs, time_t __rhs);
time_t mktime(struct tm* __tm);

struct tm* localtime(const time_t* __t);
struct tm* localtime_r(const time_t* __t, struct tm* __tm);

struct tm* gmtime(const time_t* __t);
struct tm* gmtime_r(const time_t* __t, struct tm* __tm);

char* strptime(const char* __s, const char* __fmt, struct tm* __tm) __attribute__((__format__(strftime, 2, 0)));






size_t strftime(char* __buf, size_t __n, const char* __fmt, const struct tm* __tm) __attribute__((__format__(strftime, 3, 0)));

size_t strftime_l(char* __buf, size_t __n, const char* __fmt, const struct tm* __tm, locale_t __l) __attribute__((__format__(strftime, 3, 0))) __attribute__((annotate("introduced_in=" "21")));




char* ctime(const time_t* __t);
char* ctime_r(const time_t* __t, char* __buf);

void tzset(void);

clock_t clock(void);







int clock_getres(clockid_t __clock, struct timespec* __resolution);
int clock_gettime(clockid_t __clock, struct timespec* __ts);
int clock_nanosleep(clockid_t __clock, int __flags, const struct timespec* __request, struct timespec* __remainder);
int clock_settime(clockid_t __clock, const struct timespec* __ts);

int timer_create(clockid_t __clock, struct sigevent* __event, timer_t* __timer_ptr);
int timer_delete(timer_t __timer);
int timer_settime(timer_t __timer, int __flags, const struct itimerspec* __new_value, struct itimerspec* __old_value);
int timer_gettime(timer_t __timer, struct itimerspec* __ts);
int timer_getoverrun(timer_t __timer);


time_t timelocal(struct tm* __tm) __attribute__((annotate("introduced_in=" "12")));
time_t timegm(struct tm* __tm) __attribute__((annotate("introduced_in=" "12")));
# 9 "<stdin>" 2



# 1 "/data/data/com.termux/files/usr/include/dirent.h" 1 3 4
# 63 "/data/data/com.termux/files/usr/include/dirent.h" 3 4
struct dirent { ino_t d_ino; off64_t d_off; unsigned short d_reclen; unsigned char d_type; char d_name[256]; };
struct dirent64 { ino_t d_ino; off64_t d_off; unsigned short d_reclen; unsigned char d_type; char d_name[256]; };
# 77 "/data/data/com.termux/files/usr/include/dirent.h" 3 4
typedef struct DIR DIR;

DIR* opendir(const char* __path);
DIR* fdopendir(int __dir_fd);
struct dirent* readdir(DIR* __dir);


struct dirent64* readdir64(DIR* __dir) __attribute__((annotate("introduced_in=" "21")));


int readdir_r(DIR* __dir, struct dirent* __entry, struct dirent** __buffer) __attribute__((__deprecated__("readdir_r is deprecated; use readdir instead")));


int readdir64_r(DIR* __dir, struct dirent64* __entry, struct dirent64** __buffer) __attribute__((annotate("introduced_in=" "21"))) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));


int closedir(DIR* __dir);
void rewinddir(DIR* __dir);






int dirfd(DIR* __dir);
int alphasort(const struct dirent** __lhs, const struct dirent** __rhs);


int alphasort64(const struct dirent64** __lhs, const struct dirent64** __rhs) __attribute__((annotate("introduced_in=" "21")));
int scandir64(const char* __path, struct dirent64*** __name_list, int (*__filter)(const struct dirent64*), int (*__comparator)(const struct dirent64**, const struct dirent64**)) __attribute__((annotate("introduced_in=" "21")));


int scandir(const char* __path, struct dirent*** __name_list, int (*__filter)(const struct dirent*), int (*__comparator)(const struct dirent**, const struct dirent**));
# 13 "<stdin>" 2
# 1 "/data/data/com.termux/files/usr/include/libgen.h" 1 3 4
# 44 "/data/data/com.termux/files/usr/include/libgen.h" 3 4
char* __posix_basename(const char* __path) __asm__("basename");




char* dirname(const char* __path);
# 14 "<stdin>" 2


int gInterpreter = 0;

static int expression_substitution(unsigned int* node, sParserInfo* info);
int parse_type_for_new(sNodeType** result_type, unsigned int* array_num, sParserInfo* info);

char** gCommandNames = ((void*)0);
int gNumCommandNames = 0;

void parser_init()
{
    int size = 128;
    gCommandNames = xcalloc(1, sizeof(char*)*size);
    int i;
    int n = 0;

    char* env = getenv("PATH");
    char path[4096];

    char* p = path;
    int len = strlen(env);

    for(i= 0; i<len+1; i++) {
        if(env[i] == ':' || i == len) {
            *p = '\0';

            if(access(path, 0) == 0) {
                struct stat stat_;

                if(stat(path, &stat_) == 0 && (((stat_.st_mode) & 00170000) == 0040000)) {
                    DIR* dir = opendir(path);

                    if(dir) {
                        while(1) {
                            struct dirent* entry = readdir(dir);

                            if(entry == ((void*)0)) {
                                break;
                            }

                            if(strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
                            {
                                char path2[4096];
                                xstrncpy(path2, path, 4096);

                                if(path[strlen(path)-1] != '/') {
                                    xstrncat(path2, "/", 4096);
                                }
                                xstrncat(path2, entry->d_name, 4096);

                                struct stat stat_;
                                if(stat(path2, &stat_) == 0) {
                                    if(stat_.st_mode & 00100) {
                                        char candidate[4096];
# 79 "<stdin>"
                                        snprintf(candidate, 4096, "%s", entry->d_name);
                                        gCommandNames[n++] = xstrdup(candidate);

                                        if(n >= size) {
                                            size *= 2;
                                            gCommandNames = xrealloc(gCommandNames, sizeof(char*)*size);
                                        }
                                    }
                                }
                            }
                        }

                        closedir(dir);
                    }
                }
            }

            p = path;

            if(i == len) {
                break;
            }
        }
        else {
            *p++ = env[i];

            if(p - path >= 4096) {
                fprintf((&__sF[2]), "The element of path in PATH environment variable is too long");
                return;
            }
        }
    }

    gCommandNames[n++] = xstrdup("cd");

    if(n >= size) {
        size *= 2;
        gCommandNames = xrealloc(gCommandNames, sizeof(char*)*size);
    }

    gCommandNames[n++] = xstrdup("jobs");

    if(n >= size) {
        size *= 2;
        gCommandNames = xrealloc(gCommandNames, sizeof(char*)*size);
    }

    gCommandNames[n++] = xstrdup("fg");

    if(n >= size) {
        size *= 2;
        gCommandNames = xrealloc(gCommandNames, sizeof(char*)*size);
    }

    gCommandNames[n] = ((void*)0);
    gNumCommandNames = n;
}

void parser_final()
{
    int i;
    for(i=0; i<gNumCommandNames; i++) {
        xfree(gCommandNames[i]);
    }
    xfree(gCommandNames);
}

static int is_command_name(char* name)
{
    int i;
    for(i=0; i<gNumCommandNames; i++) {
        if(strcmp(gCommandNames[i], name) == 0) {
            return 1;
        }
    }

    return 0;
}

void parser_err_msg(sParserInfo* info, const char* msg, ...)
{
    char msg2[1024];

    va_list args;
    __builtin_va_start(args, msg);
    vsnprintf(msg2, 1024, msg, args);
    __builtin_va_end(args);

    if(!info->get_type_for_interpreter)
    {
        static int output_num = 0;

        if(output_num < 8) {
            fprintf((&__sF[2]), "%s:%d: %s\n", info->sname, info->sline, msg2);
        }

        output_num++;
    }
}

void skip_spaces_and_lf(sParserInfo* info)
{
    while(*info->p == ' ' || *info->p == '\t' || (*info->p == '\n' && (info->sline)++)) {
        info->p++;
    }
}

void skip_spaces(sParserInfo* info)
{
    while(*info->p == ' ' || *info->p == '\t') {
        info->p++;
    }
}


int parse_word(char* buf, int buf_size, sParserInfo* info, int print_out_err_msg, int no_skip_lf)
{
    buf[0] = 0;

    char* p2 = buf;

    if(isalpha(*info->p) || *info->p == '_') {
        while(isalnum(*info->p) || *info->p == '_') {
            if(p2 - buf < buf_size-1) {
                *p2++ = *info->p;
                info->p++;
            }
            else {
                parser_err_msg(info, "length of word is too long");
                return 0;
            }
        }
    }

    *p2 = 0;
    if(no_skip_lf) {
        skip_spaces(info);
    }
    else {
        skip_spaces_and_lf(info);
    }

    if(*info->p == 0 && buf[0] == 0) {
        if(print_out_err_msg) {
            parser_err_msg(info, "require word(alphabet or number). this is the end of source");
        }
        return 0;
    }

    if(buf[0] == 0) {
        if(print_out_err_msg) {
            parser_err_msg(info, "require word(alphabet or _ or number). this is (%c)", *info->p);
            info->err_num++;
        }

        if(*info->p == '\n') info->sline++;

        info->p++;
    }

    return 1;
}

void expect_next_character_with_one_forward(char* characters, sParserInfo* info)
{
    skip_spaces_and_lf(info);

    int found = 0;
    char* p2 = characters;
    while(*p2) {
        if(*info->p == *p2) {
            found = 1;
        }
        p2++;
    }

    if(found) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        parser_err_msg(info, "expected that next character is %s, but it is %c(%d)", characters, *info->p, *info->p);
        info->err_num++;
        info->p++;
        skip_spaces_and_lf(info);
    }
}

int expect_next_character(char* characters, sParserInfo* info)
{
    int sline_top = info->sline;

    char err_characters[128];
    char* perr_characters = err_characters;

    int err = 0;
    while(1) {
        int found;
        char* p2;

        if(*info->p == '\0') {
            parser_err_msg(info, "clover has expected that next characters are '%s', but it arrived at source end", characters);
            info->err_num++;
            return 1;
        }

        found = 0;
        p2 = characters;
        while(*p2) {
            if(*info->p == *p2) {
                found = 1;
                break;
            }
            else {
                p2++;
            }
        }

        if(found) {
            break;
        }
        else {
            err = 1;
            if(perr_characters - err_characters < 127) {
                *perr_characters = *info->p;
                perr_characters++;
            }
            if(*info->p == '\n') { info->sline++; }
            info->p++;
        }
    }

    if(err) {
        *perr_characters = 0;
        parser_err_msg(info, "Clover has expected that next characters are '%s', but there are some characters(%s) before them", characters, err_characters);
        info->err_num++;
        info->p++;
    }

    return 1;
}


int parse_simple_lambda_params(unsigned int* node, sParserInfo* info, int lambda)
{
    sParserParam params[32];
    memset(params, 0, sizeof(sParserParam)*32);
    int num_params = 0;


    sNodeType* result_type = ((void*)0);
    sVarTable* new_table = ((void*)0);
    int omit_result_type = 0;
    int omit_params = 0;
    sVarTable* old_table = info->lv_table;

    if(*info->p == '|') {
        info->p++;
        skip_spaces_and_lf(info);

        if(lambda) {
            if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, ((void*)0), 1)) {
                return 0;
            }
        }
        else {
            if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, info->lv_table, 1)) {
                return 0;
            }
        }

        if(*info->p == ':') {
            info->p++;
            skip_spaces_and_lf(info);

            if(!parse_type(&result_type, info)) {
                return 0;
            }
        }
        else {
            omit_result_type = 1;
            result_type = create_node_type_with_class_name("Null", info->mJS);
        }
    }
    else {
        result_type = create_node_type_with_class_name("Null", info->mJS);
        if(lambda) {
            new_table = init_block_vtable(((void*)0));
        }
        else {
            new_table = init_block_vtable(info->lv_table);
        }

        omit_params = 1;
        omit_result_type = 1;
    }

    sNodeBlock* node_block = ((void*)0);

    if(!parse_block( &node_block, info, new_table, 1, 0)) {
        return 0;
    }

    *node = sNodeTree_create_block_object(params, num_params, result_type, node_block, lambda, info, omit_result_type, omit_params, old_table, 0);

    return 1;
}

int parse_method_params(int* num_params, unsigned int* params, sParserInfo* info)
{
    *num_params = 0;

    if(*info->p == '(') {
        info->p++;
        skip_spaces_and_lf(info);

        if(*info->p == ')') {
            info->p++;
            skip_spaces_and_lf(info);
        }
        else {
            while(1) {
                unsigned int node = 0;
                if(!expression(&node, info)) {
                    return 0;
                }

                if(node == 0) {
                    parser_err_msg(info, "require expression");
                    info->err_num++;
                    break;
                }

                params[*num_params] = node;
                (*num_params)++;

                if(*num_params >= 32) {
                    parser_err_msg(info, "overflow parametor number for method call");
                    return 0;
                }

                if(*info->p == '@') {
                    info->p++;
                    while(isalnum(*info->p) || *info->p == '_') {
                        info->p++;
                    }
                    skip_spaces_and_lf(info);
                }

                if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ')') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
                else if(*info->p == '\0') {
                    parser_err_msg(info, "unexpected the source end");
                    info->err_num++;
                    break;
                }
                else {
                    parser_err_msg(info, "Clover2 requires , or ) for method call");
                    info->err_num++;
                    break;
                }
            }
        }
    }


    if(*info->p == '{') {
        info->p++;
        skip_spaces_and_lf(info);

        unsigned int node = 0;
        if(!parse_simple_lambda_params(&node, info, 0)) {
            return 0;
        }

        if(node == 0) {
            parser_err_msg(info, "require expression");
            info->err_num++;
            return 1;
        }

        params[*num_params] = node;
        (*num_params)++;

        if(*num_params >= 32) {
            parser_err_msg(info, "overflow parametor number for method call");
            return 0;
        }
    }

    return 1;
}

static int parse_command_param(sBuf* param, int* quoted_string, sParserInfo* info)
{

    int squort = 0;
    int dquort = 0;

    while(1) {
        if(!squort && *info->p == '$') {
            info->p++;

            sBuf env_name;
            sBuf_init(&env_name);

            if(*info->p == '{') {
                info->p++;

                while(1) {
                    if(*info->p == '}') {
                        info->p++;
                        break;
                    }
                    else if(*info->p == '\0') {
                        parser_err_msg(info, "require } to close ${ENV}");
                        info->err_num++;
                        break;
                    }
                    else {
                        sBuf_append_char(&env_name, *info->p);
                        info->p++;
                    }
                }
            }
            else {
                while(isalnum(*info->p) || *info->p == '_') {
                    sBuf_append_char(&env_name, *info->p);
                    info->p++;
                }
            }

            char* env = getenv(env_name.mBuf);

            if(env) {
                sBuf_append(param, env, strlen(env));
            }

            xfree(env_name.mBuf);
        }
        else if(*info->p == '\\') {
            info->p++;
            sBuf_append_char(param, *info->p);
            info->p++;
        }
        else if(!squort && *info->p == '"') {
            info->p++;
            dquort = !dquort;
            if(dquort) {
                *quoted_string = 1;
            }
        }
        else if(!dquort && *info->p == '\'') {
            info->p++;
            squort = !squort;
            if(squort) {
                *quoted_string = 1;
            }
        }
        else if(squort || dquort) {
            sBuf_append_char(param, *info->p);
            info->p++;
        }
        else if(*info->p == ' ' || *info->p == '\t' || *info->p == '\n' || *info->p == ';' || *info->p == '\0' || *info->p == '|' || *info->p == '&' || *info->p == '>')
        {
            break;
        }
        else {
            sBuf_append_char(param, *info->p);
            info->p++;
        }
    }
    skip_spaces(info);

    return 1;
}

static int parse_command_method_params(int* num_params, unsigned int* params, sParserInfo* info, int class_method, char* method_name)
{
    *num_params = 0;

    if(*info->p == ';' || *info->p == '\n') {
    }
    else if(*info->p != '\0') {
        while(1) {
            sBuf param;
            sBuf_init(&param);
            int quoted_string = 0;

            if(!parse_command_param(&param, &quoted_string, info))
            {
                xfree(param.mBuf);
                return 0;
            }

            if(param.mLen > 0) {
                unsigned int node = 0;
                node = sNodeTree_create_string_value( param.mBuf, ((void*)0), ((void*)0), 0, info);

                unsigned int node2 = 0;
                node2 = sNodeTree_create_int_value(quoted_string, 0, 0, 0, info);
                if(quoted_string) {
                    node2 = sNodeTree_true_expression(info);
                }
                else {
                    node2 = sNodeTree_false_expression(info);
                }

                sNodeType* command_class = create_node_type_with_class_name("Command", info->mJS);

                                              ;

                unsigned int params2[32];
                int num_params2 = 2;

                params2[0] = node;
                params2[1] = node2;

                node = sNodeTree_create_class_method_call(command_class, "expandArg", params2, num_params2, info);

                params[*num_params] = node;
                (*num_params)++;

                if(*num_params >= 32) {
                    parser_err_msg(info, "overflow parametor number for method call");
                    return 0;
                }
            }
            else {
                xfree(param.mBuf);
            }

            if(*info->p == '\0' || *info->p == '\n' || *info->p == ';' || *info->p == '|' || *info->p == '&' || *info->p == '>')
            {
                break;
            }
        }
    }

    if(class_method) {
        sCLClass* command_class = get_class("Command", info->mJS);

        if(command_class == ((void*)0)) {
            fprintf((&__sF[2]), "There is no Command class\n");
            return 0;
        }

        if(!class_method_name_existance(command_class, method_name)) {
            params[*num_params] = sNodeTree_create_string_value( xstrdup("--controlling-terminal"), ((void*)0), ((void*)0), 0, info);
            (*num_params)++;

            if(*num_params >= 32) {
                parser_err_msg(info, "overflow parametor number for method call");
                return 0;
            }
        }
    }
    else {
        sCLClass* command_class = get_class("Command", info->mJS);

        if(!none_class_method_name_existance(command_class, method_name)) {
            params[*num_params] = sNodeTree_create_string_value( xstrdup("--controlling-terminal"), ((void*)0), ((void*)0), 0, info);
            (*num_params)++;

            if(*num_params >= 32) {
                parser_err_msg(info, "overflow parametor number for method call");
                return 0;
            }
        }
    }

    return 1;
}

static int get_number(int minus, unsigned int* node, sParserInfo* info)
{
    const int buf_size = 128;
    char buf[128+1];
    char* p2 = buf;

    if(minus) {
        *p2 = '-';
        p2++;
    }

    if(isdigit(*info->p)) {
        while(isdigit(*info->p) || *info->p == '_') {
            if(*info->p == '_') {
                info->p++;
            }
            else {
                *p2++ = *info->p;
                info->p++;
            }

            if(p2 - buf >= buf_size) {
                parser_err_msg(info, "overflow node of number");
                return 0;
            }
        }
        *p2 = 0;
        skip_spaces_and_lf(info);

        if(*info->p == '.' && isdigit(*(info->p+1))) {
            info->p++;
            *p2++ = '.';

            if(p2 - buf >= buf_size) {
                parser_err_msg(info, "overflow node of number");
                return 0;
            }

            while(isdigit(*info->p) || *info->p == '_') {
                if(*info->p == '_') {
                    info->p++;
                }
                else {
                    *p2++ = *info->p;
                    info->p++;
                }

                if(p2 - buf >= buf_size) {
                    parser_err_msg(info, "overflow node of number");
                    return 0;
                }
            }
            *p2 = 0;

            if(*info->p == 'f') {
                info->p++;
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_float_value(atof(buf), 0, 0, 0, info);
            }
            else if(*info->p == 'F') {
                info->p++;
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_cfloat_value(atof(buf), 0, 0, 0, info);
            }
            else if(*info->p == 'D') {
                info->p++;
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_cdouble_value(strtod(buf, ((void*)0)), 0, 0, 0, info);
            }
            else {
                *node = sNodeTree_create_double_value(strtod(buf, ((void*)0)), 0, 0, 0, info);
            }

            skip_spaces_and_lf(info);
        }
        else if(*info->p == 'y') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_byte_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'Y') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cbyte_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'u' && *(info->p+1) == 'y') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_ubyte_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'U' && *(info->p+1) == 'Y') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cubyte_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 's') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_short_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'S') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cshort_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'u' && *(info->p+1) == 's') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_ushort_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'U' && *(info->p+1) == 'S') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cushort_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'l') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_long_value(atol(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'L') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_clong_value(atol(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'u' && *(info->p+1) == 'l') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_ulong_value(atol(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'U' && *(info->p+1) == 'L') {
            info->p+=2;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_culong_value(atol(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'u') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_uint_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'U') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cuint_value(atoi(buf), 0, 0, 0, info);
        }
        else if(*info->p == 'I') {
            info->p++;
            skip_spaces_and_lf(info);

            *node = sNodeTree_create_cint_value(atoi(buf), 0, 0, 0, info);
        }
        else {
            *node = sNodeTree_create_int_value(atoi(buf), 0, 0, 0, info);
        }
    }
    else {
        parser_err_msg(info, "require digits after + or -");
        info->err_num++;

        *node = 0;
    }

    return 1;
}

static int get_hex_number(unsigned int* node, sParserInfo* info)
{
    int buf_size = 128;
    char buf[128+1];
    char* p = buf;

    *p++ = '0';
    *p++ = 'x';

    while((*info->p >= '0' && *info->p <= '9') || (*info->p >= 'a' && *info->p <= 'f') || (*info->p >= 'A' && *info->p <= 'F') || *info->p == '_')
    {
        if(*info->p == '_') {
            info->p++;
        }
        else {
            *p++ = *info->p;
            info->p++;
        }

        if(p - buf >= buf_size-1) {
            parser_err_msg(info, "overflow node of number");
            return 0;
        }
    }
    *p = 0;
    skip_spaces_and_lf(info);

    unsigned long long value = strtoll(buf, ((void*)0), 0);

    if(*info->p == 'y') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_byte_value((char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'Y') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cbyte_value((char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 'y') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ubyte_value((unsigned char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'Y') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cubyte_value((unsigned char)value, 0, 0, 0, info);
    }
    else if(*info->p == 's') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_short_value((short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'S') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cshort_value((short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 's') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ushort_value((unsigned short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'S') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cushort_value((unsigned short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'l') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_long_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'L') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ulong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 'l') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ulong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'L') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_culong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'u') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_uint_value((unsigned int)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cuint_value((unsigned int)value, 0, 0, 0, info);
    }
    else if(*info->p == 'I') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cint_value((int)value, 0, 0, 0, info);
    }
    else {
        *node = sNodeTree_create_int_value((int)value, 0, 0, 0, info);
    }

    return 1;
}

static int get_oct_number(unsigned int* node, sParserInfo* info)
{
    int buf_size = 128;
    char buf[128+1];
    char* p = buf;

    *p++ = '0';

    while((*info->p >= '0' && *info->p <= '7') || *info->p == '_') {
        if(*info->p == '_') {
            info->p++;
        }
        else {
            *p++ = *info->p++;
        }

        if(p - buf >= buf_size-1) {
            parser_err_msg(info, "overflow node of number");
            return 0;
        }
    }
    *p = 0;
    skip_spaces_and_lf(info);

    unsigned long long value = strtoul(buf, ((void*)0), 0);

    if(*info->p == 'y') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_byte_value((char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'Y') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cbyte_value((char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 'y') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ubyte_value((unsigned char)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'Y') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cubyte_value((unsigned char)value, 0, 0, 0, info);
    }
    else if(*info->p == 's') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_short_value((short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'S') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cshort_value((short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 's') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ushort_value((unsigned short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'S') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cushort_value((unsigned short)value, 0, 0, 0, info);
    }
    else if(*info->p == 'l') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_long_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'L') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_clong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'u' && *(info->p+1) == 'l') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_ulong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'U' && *(info->p+1) == 'L') {
        info->p+=2;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_culong_value(value, 0, 0, 0, info);
    }
    else if(*info->p == 'u') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_uint_value((unsigned int)value, 0, 0, 0, info);
    }
    else if(*info->p == 'U') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cuint_value((unsigned int)value, 0, 0, 0, info);
    }
    else if(*info->p == 'I') {
        info->p++;
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_cint_value((int)value, 0, 0, 0, info);
    }
    else {
        *node = sNodeTree_create_int_value((int)value, 0, 0, 0, info);
    }

    return 1;
}

static int if_expression(unsigned int* node, sParserInfo* info)
{
    char* sname = info->sname;
    int sline = info->sline;

    expect_next_character_with_one_forward("(", info);


    unsigned int expression_node = 0;
    if(!expression(&expression_node, info)) {
        return 0;
    }

    if(expression_node == 0) {
        parser_err_msg(info, "require expression for if");
        info->err_num++;
        return 1;
    }

    int if_unclosed;

    if(*info->p != ')') {
        if_unclosed = 1;
    }
    else {
        if_unclosed = 0;
    }

    if(if_unclosed) {
        *node = sNodeTree_if_expression(expression_node, ((void*)0), ((void*)0), ((void*)0), 0, ((void*)0), if_unclosed, ((void*)0), info, sname, sline);

        return 1;
    }

    expect_next_character_with_one_forward(")", info);
    expect_next_character_with_one_forward("{", info);

    sNodeBlock* if_node_block = ((void*)0);
    if(!parse_block( &if_node_block, info, ((void*)0), 0, 0)) {
        return 0;
    }

    unsigned int elif_expression_nodes[32];
    memset(elif_expression_nodes, 0, sizeof(unsigned int)*32);

    sNodeBlock* elif_node_blocks[32];
    memset(elif_node_blocks, 0, sizeof(sNodeBlock*)*32);

    int elif_unclosed[32];
    memset(elif_unclosed, 0, sizeof(int)*32);

    int elif_num = 0;

    sNodeBlock* else_node_block = ((void*)0);

    while(1) {
        char* saved_p = info->p;
        int saved_sline = info->sline;

        char buf[64];


        if(!isalpha(*info->p)) {
            break;
        }
        if(!parse_word(buf, 64, info, 1, 0)) {
            return 0;
        }

        if(strcmp(buf, "else") == 0) {
            expect_next_character_with_one_forward("{", info);

            if(!parse_block( &else_node_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
            break;
        }
        else if(strcmp(buf, "elif") == 0) {
            expect_next_character_with_one_forward("(", info);


            if(!expression(&elif_expression_nodes[elif_num], info)) {
                return 0;
            }

            if(elif_expression_nodes[elif_num] == 0) {
                parser_err_msg(info, "require elif expression");
                info->err_num++;
                return 1;
            }

            if(*info->p != ')') {
                elif_unclosed[elif_num] = 1;
            }
            else {
                elif_unclosed[elif_num] = 0;
            }

            if(elif_unclosed[elif_num]) {
                elif_num++;
                *node = sNodeTree_if_expression(expression_node, if_node_block, elif_expression_nodes, elif_node_blocks, elif_num, ((void*)0), if_unclosed, elif_unclosed, info, sname, sline);
                return 1;
            }

            expect_next_character_with_one_forward(")", info);
            expect_next_character_with_one_forward("{", info);

            if(!parse_block( &elif_node_blocks[elif_num], info, ((void*)0), 0, 0)) {
                return 0;
            }

            elif_num++;
            if(elif_num >= 32) {
                parser_err_msg(info, "overflow elif num");
                info->err_num++;
                return 0;
            }
        }
        else {
            info->p = saved_p;
            info->sline = saved_sline;
            break;
        }
    }

    *node = sNodeTree_if_expression(expression_node, if_node_block, elif_expression_nodes, elif_node_blocks, elif_num, else_node_block, if_unclosed, elif_unclosed, info, sname, sline);

    return 1;
}

static int while_expression(unsigned int* node, sParserInfo* info)
{
    expect_next_character_with_one_forward("(", info);


    unsigned int expression_node = 0;
    if(!expression(&expression_node, info)) {
        return 0;
    }

    if(expression_node == 0) {
        parser_err_msg(info, "require expression for while");
        info->err_num++;
        return 1;
    }

    if(*info->p != ')') {
        info->exist_brace_unclosed = 1;
    }
    else {
        info->exist_brace_unclosed = 0;
    }

    if(info->get_type_for_interpreter && *info->p == '\0') {
        *node = sNodeTree_while_expression(expression_node, ((void*)0), info);
        return 1;
    }

    expect_next_character_with_one_forward(")", info);
    expect_next_character_with_one_forward("{", info);

    sNodeBlock* while_node_block = ((void*)0);
    if(!parse_block( &while_node_block, info, ((void*)0), 0, 0)) {
        return 0;
    }

    *node = sNodeTree_while_expression(expression_node, while_node_block, info);

    return 1;
}

static int for_expression(unsigned int* node, sParserInfo* info)
{
    expect_next_character_with_one_forward("(", info);


    unsigned int expression_node = 0;
    if(!expression(&expression_node, info)) {
        return 0;
    }

    if(expression_node == 0) {
        parser_err_msg(info, "require expression for \"for\"");
        info->err_num++;
        return 1;
    }

    if(*info->p == ';') {
        expect_next_character_with_one_forward(";", info);
    }
    else {
        *node = expression_node;
        return 1;
    }


    unsigned int expression_node2 = 0;
    if(!expression(&expression_node2, info)) {
        return 0;
    }

    if(expression_node2 == 0) {
        parser_err_msg(info, "require expression2 for \"for\"");
        info->err_num++;
        return 1;
    }

    if(*info->p == ';') {
        expect_next_character_with_one_forward(";", info);
    }
    else {
        *node = expression_node2;
        return 1;
    }


    unsigned int expression_node3 = 0;
    if(!expression(&expression_node3, info)) {
        return 0;
    }

    if(expression_node3 == 0) {
        parser_err_msg(info, "require expression3 for \"for\"");
        info->err_num++;
        return 1;
    }

    if(*info->p == ')') {
        expect_next_character_with_one_forward(")", info);
    }
    else {
        *node = expression_node3;
        return 1;
    }

    expect_next_character_with_one_forward("{", info);

    sNodeBlock* for_node_block = ((void*)0);
    if(!parse_block( &for_node_block, info, ((void*)0), 0, 0)) {
        return 0;
    }

    *node = sNodeTree_for_expression(expression_node, expression_node2, expression_node3, for_node_block, info);

    return 1;
}

static int when_expression(unsigned int* node, sParserInfo* info)
{
    char* sname = info->sname;
    int sline = info->sline;

    expect_next_character_with_one_forward("(", info);


    unsigned int expression_node = 0;
    if(!expression(&expression_node, info)) {
        return 0;
    }

    if(expression_node == 0) {
        parser_err_msg(info, "require expression for when");
        info->err_num++;
        return 1;
    }

    expect_next_character_with_one_forward(")", info);
    expect_next_character_with_one_forward("{", info);
    skip_spaces_and_lf(info);

    unsigned int value_nodes[32][32];
    int num_values[32];
    sNodeBlock* when_blocks[32];
    sNodeType* when_types[32];
    sNodeType* when_types2[32];
    int when_match[32];
    sNodeBlock* else_block = ((void*)0);
    int num_when_block = 0;

    memset(when_types, 0, sizeof(sNodeType*)*32);
    memset(when_types2, 0, sizeof(sNodeType*)*32);
    memset(when_match, 0, sizeof(int*)*32);


    while(1) {
        if(*info->p == '}') {
            info->p++;
            skip_spaces_and_lf(info);
            break;
        }
        else if(*info->p == '\0') {
            if(info->get_type_for_interpreter) {
                break;
            }
            else {
                parser_err_msg(info, "Unexpected the source end");
                info->err_num++;
                return 1;
            }
        }

        if(*info->p == 'i' && *(info->p+1) == 's') {
            info->p+=2;
            skip_spaces_and_lf(info);

            sNodeType* node_type = ((void*)0);
            if(!parse_type(&node_type, info)) {
                return 0;
            }

            when_types[num_when_block] = node_type;

            expect_next_character_with_one_forward("{", info);

            sNodeBlock* when_block = ((void*)0);
            if(!parse_block( &when_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
            when_blocks[num_when_block] = when_block;
            num_values[num_when_block] = 1;
            num_when_block++;

            if(num_when_block >= 32) {
                parser_err_msg(info, "overflow when block number");
                return 0;
            }
        }
        else if(*info->p == '!' && *(info->p+1) == 'i' && *(info->p+2) == 's') {
            info->p+=3;
            skip_spaces_and_lf(info);

            sNodeType* node_type = ((void*)0);
            if(!parse_type(&node_type, info)) {
                return 0;
            }

            when_types2[num_when_block] = node_type;

            expect_next_character_with_one_forward("{", info);

            sNodeBlock* when_block = ((void*)0);
            if(!parse_block( &when_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
            when_blocks[num_when_block] = when_block;
            num_values[num_when_block] = 1;
            num_when_block++;

            if(num_when_block >= 32) {
                parser_err_msg(info, "overflow when block number");
                return 0;
            }
        }
        else if(*info->p == 'e' && *(info->p+1) == 'l' && *(info->p+2) == 's' && *(info->p+3) == 'e') {
            info->p+=4;
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(else_block != ((void*)0)) {
                parser_err_msg(info, "else block should be one");
                info->err_num++;
                return 1;
            }

            if(!parse_block( &else_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
        }
        else if(*info->p == 'm' && *(info->p+1) == 'a' && *(info->p+2) == 't' && *(info->p+3) == 'c' && *(info->p+4) == 'h')
        {
            info->p+=5;
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("(", info);

            int num_value = 0;

            while(1) {
                unsigned int node = 0;
                if(!expression(&node, info)) {
                    return 0;
                }

                if(node == 0) {
                    parser_err_msg(info, "require expression for when");
                    info->err_num++;
                    return 1;
                }

                value_nodes[num_when_block][num_value] = node;
                num_value++;

                if(num_value >= 32) {
                    parser_err_msg(info, "overflow when value number");
                    return 0;
                }

                num_values[num_when_block] = num_value;

                if(*info->p == '\0') {
                    parser_err_msg(info, "Unexpected the source end");
                    info->err_num++;
                    return 1;
                }
                else if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ')') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
            }

            expect_next_character_with_one_forward("{", info);

            sNodeBlock* when_block = ((void*)0);
            if(!parse_block( &when_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
            when_blocks[num_when_block] = when_block;
            when_match[num_when_block] = 1;

            num_when_block++;

            if(num_when_block >= 32) {
                parser_err_msg(info, "overflow when block number");
                return 0;
            }
        }
        else if(*info->p == 'c' && *(info->p+1) == 'a' && *(info->p+2) == 's' && *(info->p+3) == 'e') {
            info->p+=4;
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("(", info);

            int num_value = 0;

            while(1) {
                unsigned int node2 = 0;
                if(!expression(&node2, info)) {
                    return 0;
                }

                if(node2 == 0) {
                    parser_err_msg(info, "require expression for when");
                    info->err_num++;
                    return 1;
                }

                value_nodes[num_when_block][num_value] = node2;
                num_value++;

                if(num_value >= 32) {
                    parser_err_msg(info, "overflow when value number");
                    return 0;
                }

                num_values[num_when_block] = num_value;

                if(*info->p == '\0') {
                    if(info->get_type_for_interpreter) {
                        when_blocks[num_when_block] = ((void*)0);
                        num_when_block++;
                        *node = sNodeTree_when_expression(expression_node, value_nodes, num_values, when_blocks, num_when_block, else_block, when_types, when_types2, when_match, info, sname, sline);
                        return 1;
                    }
                    else {
                        parser_err_msg(info, "Unexpected the source end");
                        info->err_num++;
                        return 1;
                    }
                }
                else if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ')') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
            }

            expect_next_character_with_one_forward("{", info);

            sNodeBlock* when_block = ((void*)0);
            if(!parse_block( &when_block, info, ((void*)0), 0, 0)) {
                return 0;
            }
            when_blocks[num_when_block] = when_block;

            num_when_block++;

            if(num_when_block >= 32) {
                parser_err_msg(info, "overflow when block number");
                return 0;
            }
        }
        else {
            parser_err_msg(info, "when requires is or !is or case");
            return 0;
        }
    }

    *node = sNodeTree_when_expression(expression_node, value_nodes, num_values, when_blocks, num_when_block, else_block, when_types, when_types2, when_match, info, sname, sline);

    return 1;
}

static int return_expression(unsigned int* node, sParserInfo* info)
{







    unsigned int expression_node = 0;
    if(*info->p != ';') {

        if(!expression(&expression_node, info)) {
            return 0;
        }
    }
# 1627 "<stdin>"
    *node = sNodeTree_create_return_expression(expression_node, info);

    return 1;
}

static int new_expression(unsigned int* node, sParserInfo* info)
{
    sNodeType* node_type = ((void*)0);
    unsigned int array_num = 0;

    if(!parse_type_for_new(&node_type, &array_num, info)) {
        return 0;
    }

    unsigned int params[32];
    int num_params = 0;

    if(!parse_method_params(&num_params, params, info)) {
        return 0;
    }

    *node = sNodeTree_create_new_operator(node_type, params, num_params, array_num, info);

    return 1;
}

static int new_expression_for_js_value(unsigned int* node, unsigned int* params, int num_params, char* class_name, sParserInfo* info)
{
    unsigned int array_num = 0;
    sNodeType* node_type = create_node_type_with_class_name(class_name, 1);

    *node = sNodeTree_create_new_operator(node_type, params, num_params, array_num, info);

    return 1;
}

static int throw_expression(unsigned int* node, sParserInfo* info)
{

    unsigned int expression_node = 0;
    if(!expression(&expression_node, info)) {
        return 0;
    }

    *node = sNodeTree_create_throw_expression(expression_node, info);

    return 1;
}

static int expect_next_word(char* word, sParserInfo* info)
{
    char buf[32];

    if(!parse_word(buf, 32, info, 1, 0)) {
        return 0;
    }

    if(strcmp(buf, word) != 0) {
        parser_err_msg(info, "Expected next word is %s\n", word);
        info->err_num++;
    }

    return 1;
}

static int parse_param(sParserParam* param, sParserInfo* info)
{

    if(!parse_word(param->mName, 64, info, 1, 0)) {
        return 0;
    }

    expect_next_character_with_one_forward(":", info);

    if(!parse_type(&param->mType, info)) {
        return 0;
    }


    if(*info->p == '=') {
        info->p++;
        skip_spaces_and_lf(info);

        char* p = info->p;

        unsigned int node = 0;
        if(!expression(&node, info)) {
            return 0;
        }

        char* p2 = info->p;

        if(p2 - p > 128) {
            parser_err_msg(info, "overflow method default param character");
            return 0;
        }

        memcpy(param->mDefaultValue, p, p2 - p);
        param->mDefaultValue[p2 -p] = '\0';
    }
    else {
        param->mDefaultValue[0] = '\0';
    }

    return 1;
}


int parse_params(sParserParam* params, int* num_params, sParserInfo* info, int character_type)
{
    if((character_type == 0 && *info->p == ')') || (character_type == 1 && *info->p == '|')) {
        info->p++;
        skip_spaces_and_lf(info);

        *num_params = 0;

        return 1;
    }

    while(1) {
        if(!parse_param(params + *num_params, info)) {
            return 0;
        }

        (*num_params)++;

        if(*num_params >= 32) {
            parser_err_msg(info, "overflow params number");
            return 0;
        }

        if(*info->p == ',') {
            info->p++;
            skip_spaces_and_lf(info);
        }
        else if((character_type == 0 && *info->p == ')') || (character_type == 1 && *info->p == '|')) {
            info->p++;
            skip_spaces_and_lf(info);
            break;
        }
        else if(*info->p == '\0') {
            parser_err_msg(info, "It is required to ',' or ')' before the source end");
            info->err_num++;
            break;
        }
        else {
            parser_err_msg(info, "Unexpected character(%c). It is required to ',' or ')' or '|' character", *info->p);
            if(*info->p == '\n') {
                info->sline++;
            }
            info->p++;

            info->err_num++;
        }
    }

    return 1;
}

int parse_params_and_entry_to_lvtable(struct sParserParamStruct* params, int* num_params, sParserInfo* info, sVarTable** new_table, sVarTable* parent_lv_table, int character_type)
{
    if(!parse_params(params, num_params, info, character_type)) {
        return 0;
    }

    *new_table = init_block_vtable(parent_lv_table);

    int i;
    for(i=0; i<*num_params; i++) {
        sParserParam* param = params + i;

        if(!add_variable_to_table(*new_table, param->mName, param->mType, 0)) {
            return 0;
        }
    }

    return 1;
}

static int try_expression(unsigned int* node, sParserInfo* info)
{
    expect_next_character_with_one_forward("{", info);


    sNodeBlock* try_node_block = ((void*)0);
    if(!parse_block( &try_node_block, info, ((void*)0), 0, 0)) {
        return 0;
    }

    sNodeBlock* catch_node_block = ((void*)0);
    sParserParam params[32];
    memset(params, 0, sizeof(sParserParam)*32);
    int num_params = 0;
    params[0].mName[0] = '\0';

    if(info->err_num == 0) {
        if(strstr(info->p, "catch") == info->p) {

            expect_next_word("catch", info);

            expect_next_character_with_one_forward("(", info);


            sVarTable* new_table = ((void*)0);

            if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, info->lv_table, 0)) {
                return 0;
            }

            if(num_params != 1 || !is_exception_type(params[0].mType)) {
                parser_err_msg(info, "Require the type of a catch param should be a exception type");
                info->err_num++;
            }

            expect_next_character_with_one_forward("{", info);

            if(!parse_block( &catch_node_block, info, new_table, 0, 0)) {
                return 0;
            }
        }
        else {
            sVarTable* new_table = ((void*)0);

            num_params = 1;

            xstrncpy(params[0].mName, "e", 64);
            params[0].mType = create_node_type_with_class_name("Exception", info->mJS);

            new_table = init_block_vtable(info->lv_table);

            if(!add_variable_to_table(new_table, params[0].mName, params[0].mType, 0)) {
                return 0;
            }

            if(!create_null_block( &catch_node_block, info, new_table, 0)) {
                return 0;
            }
        }
    }

    *node = sNodeTree_try_expression( try_node_block, catch_node_block, params[0].mName, info);

    return 1;
}

int parse_class_type(sCLClass** klass, sParserInfo* info)
{
    char class_name[64];

    if(!parse_word(class_name, 64, info, 1, 0)) {
        return 0;
    }

    if(strcmp(class_name, "SELF") == 0) {
        *klass = info->klass;
    }
    else {
        *klass = get_class_with_load(class_name, info->mJS);
    }

    if(*klass == ((void*)0)) {
        parser_err_msg(info, "%s is not defined class(1)", class_name);
        info->err_num++;
    }

    return 1;
}

int parse_type(sNodeType** result_type, sParserInfo* info)
{
    int js = info->mJS;

    char type_name[64];

    *result_type = ((void*)0);

    if(!parse_word(type_name, 64, info, 1, 0)) {
        return 0;
    }

    int generics_num = 0;

    int i;
    for(i=0; i<info->method_generics_info.mNumParams; i++) {
        if(strcmp(type_name, info->method_generics_info.mParamNames[i]) == 0) {
            *result_type = create_node_type_with_method_generics_number(i, info->mJS);
            break;
        }
    }

    for(i=0; i<info->generics_info.mNumParams; i++) {
        if(strcmp(type_name, info->generics_info.mParamNames[i]) == 0) {
            *result_type = create_node_type_with_generics_number(i, info->mJS);
            break;
        }
    }

    if(*result_type == ((void*)0)) {
        if(strcmp(type_name, "SELF") == 0) {
            *result_type = create_node_type_with_class_pointer(info->klass);


            if(*info->p != '<') {
                int i;
                for(i=0; i< info->generics_info.mNumParams; i++) {
                    (*result_type)->mGenericsTypes[i] = create_node_type_with_class_pointer(info->generics_info.mInterface[i]);
                }

                generics_num = info->generics_info.mNumParams;
            }
        }
        else {
            *result_type = create_node_type_with_class_name(type_name, info->mJS);
        }
    }

    if(*result_type == ((void*)0)) {
        *result_type = alloc_node_type();
    }

    if(*result_type != ((void*)0)) {
        (*result_type)->mNullable = 0;
    }

    if(strcmp(type_name, "lambda") == 0) {
        if(*info->p == '[' && *(info->p+1) == ']') {
            info->p+=2;
            skip_spaces_and_lf(info);

            (*result_type)->mArray = 1;
        }

        if(*info->p == '?') {
            info->p++;
            skip_spaces_and_lf(info);

            (*result_type)->mNullable = 1;
        }
    }

    if(*result_type == ((void*)0) || (*result_type)->mClass == ((void*)0)) {
        parser_err_msg(info, "%s is not defined class(2)", type_name);
        info->err_num++;
    }

    if(strcmp(type_name, "lambda") == 0) {
        sNodeBlockType* node_block_type = alloc_node_block_type();

        if(*info->p == '(') {
            info->p++;
            skip_spaces_and_lf(info);

            if(*info->p == ')') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else {
                while(1) {
                    sNodeType* node_type = ((void*)0);
                    if(!parse_type(&node_type, info)) {
                        return 0;
                    }

                    node_block_type->mParams[node_block_type->mNumParams] = node_type;
                    node_block_type->mNumParams++;

                    if(node_block_type->mNumParams >= 32) {
                        parser_err_msg(info, "oveflow block object type params");
                        return 0;
                    }

                    if(*info->p == ')') {
                        info->p++;
                        skip_spaces_and_lf(info);
                        break;
                    }
                    else if(*info->p == ',') {
                        info->p++;
                        skip_spaces_and_lf(info);
                    }
                    else {
                        parser_err_msg(info, "invalid character in block type name(%c)", *info->p);
                        break;
                    }
                }
            }
        }

        if(*info->p == ':') {
            info->p++;
            skip_spaces_and_lf(info);

            sNodeType* node_type = ((void*)0);
            if(!parse_type(&node_type, info)) {
                return 0;
            }

            node_block_type->mResultType = node_type;
        }
        else {
            node_block_type->mResultType = create_node_type_with_class_name("Null", info->mJS);
        }

        (*result_type)->mBlockType = node_block_type;
    }
    else if(*info->p == '<' && *(info->p+1) != '<' && *(info->p+1) != '=') {
        info->p++;
        skip_spaces_and_lf(info);

        while(1) {
            if(!parse_type(&(*result_type)->mGenericsTypes[generics_num], info)) {
                return 0;
            }

            generics_num++;

            if(generics_num >= 32) {
                parser_err_msg(info, "overflow generics parametor number");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '>') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
            else {
                parser_err_msg(info, "invalid character(%c) in generics types", *info->p);
                info->err_num++;
                break;
            }
        }
    }

    if(*info->p == '[' && *(info->p+1) == ']') {
        info->p+=2;
        skip_spaces_and_lf(info);

        (*result_type)->mArray = 1;
    }


    if(*result_type != ((void*)0)) {
        (*result_type)->mNumGenericsTypes = generics_num;
    }


    if(*info->p == '?') {
        info->p++;
        skip_spaces_and_lf(info);

        (*result_type)->mNullable = 1;
    }


    if(*info->p == '@') {
        info->p++;

        if(isalpha(*info->p)) {
            while(isalnum(*info->p) || *info->p == '-' || *info->p == '_' || *info->p == '[' || *info->p == ']') {
                info->p++;
            }
            skip_spaces_and_lf(info);
        }
        else {
            parser_err_msg(info, "require alphabets for anotation");
            info->err_num++;
        }
    }


    if(info->err_num == 0) {
        sCLClass* klass = (*result_type)->mClass;

        int i;
        for(i=0; i<generics_num; i++) {
            sCLClass* left_type = get_class_with_load((char*)((&klass->mConst)->mConst + klass->mGenericsParamTypeOffsets[i]), js);

            sCLClass* right_type = (*result_type)->mGenericsTypes[i]->mClass;

            sCLClass* right_type2;
            solve_method_generics_for_variable_to_class(right_type, &right_type2, info);

            sCLClass* right_type3;
            solve_generics_for_variable_to_class(right_type2, &right_type3, info);

            if(!check_implemented_methods_for_interface(left_type, right_type3, 1)) {
                parser_err_msg(info, "%s is not implemented %s interface" , ((char*)(((&(right_type2)->mConst))->mConst + (right_type2)->mClassNameOffset)), ((char*)(((&(left_type)->mConst))->mConst + (left_type)->mClassNameOffset)));
                info->err_num++;
            }
        }
    }

    return 1;
}

int parse_type_for_new(sNodeType** result_type, unsigned int* array_num, sParserInfo* info)
{
    int js = info->mJS;

    char type_name[64];

    *result_type = ((void*)0);

    if(!parse_word(type_name, 64, info, 1, 0)) {
        return 0;
    }

    int i;
    for(i=0; i<info->generics_info.mNumParams; i++) {
        if(strcmp(type_name, info->generics_info.mParamNames[i]) == 0) {
            *result_type = create_node_type_with_generics_number(i, info->mJS);
            break;
        }
    }

    for(i=0; i<info->method_generics_info.mNumParams; i++) {
        if(strcmp(type_name, info->method_generics_info.mParamNames[i]) == 0) {
            *result_type = create_node_type_with_method_generics_number(i, info->mJS);
            break;
        }
    }

    int generics_num = 0;

    if(*result_type == ((void*)0)) {
        if(strcmp(type_name, "SELF") == 0) {
            *result_type = create_node_type_with_class_pointer(info->klass);
# 2170 "<stdin>"
        }
        else {
            *result_type = create_node_type_with_class_name(type_name, info->mJS);
        }
    }

    if(*result_type == ((void*)0) || (*result_type)->mClass == ((void*)0)) {
        parser_err_msg(info, "%s is not defined class(3)", type_name);
        info->err_num++;
        return 1;
    }

    *array_num = 0;

    if(type_identify_with_class_name(*result_type, "lambda")) {
        if(*info->p == '[') {
            info->p++;
            skip_spaces_and_lf(info);

            if(!expression(array_num, info)) {
                return 0;
            }

            expect_next_character_with_one_forward("]", info);

            (*result_type)->mArray = 1;
        }

        sNodeBlockType* node_block_type = alloc_node_block_type();

        if(*info->p == '(') {
            info->p++;
            skip_spaces_and_lf(info);

            if(*info->p == ')') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else {
                while(1) {
                    sNodeType* node_type = ((void*)0);
                    if(!parse_type(&node_type, info)) {
                        return 0;
                    }

                    node_block_type->mParams[node_block_type->mNumParams] = node_type;
                    node_block_type->mNumParams++;

                    if(node_block_type->mNumParams >= 32) {
                        parser_err_msg(info, "oveflow block object type params");
                        return 0;
                    }

                    if(*info->p == ')') {
                        info->p++;
                        skip_spaces_and_lf(info);
                        break;
                    }
                    else if(*info->p == ',') {
                        info->p++;
                        skip_spaces_and_lf(info);
                    }
                    else {
                        parser_err_msg(info, "invalid character in block type name(%c)", *info->p);
                        break;
                    }
                }
            }
        }

        if(*info->p == ':') {
            info->p++;
            skip_spaces_and_lf(info);

            sNodeType* node_type = ((void*)0);
            if(!parse_type(&node_type, info)) {
                return 0;
            }

            node_block_type->mResultType = node_type;
        }
        else {
            node_block_type->mResultType = create_node_type_with_class_name("Null", info->mJS);
        }

        (*result_type)->mBlockType = node_block_type;
    }
    else if(*info->p == '<' && *(info->p+1) != '<' && *(info->p+1) != '=') {
        info->p++;
        skip_spaces_and_lf(info);

        while(1) {
            if(!parse_type(&(*result_type)->mGenericsTypes[generics_num], info)) {
                return 0;
            }

            generics_num++;

            if(generics_num >= 32) {
                parser_err_msg(info, "overflow generics parametor number");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '>') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
            else {
                parser_err_msg(info, "invalid character(%c) in generics types", *info->p);
                info->err_num++;
                break;
            }
        }
    }

    if(*info->p == '[') {
        info->p++;
        skip_spaces_and_lf(info);

        if(!expression(array_num, info)) {
            return 0;
        }

        expect_next_character_with_one_forward("]", info);

        (*result_type)->mArray = 1;
    }

    (*result_type)->mNumGenericsTypes = generics_num;


    sCLClass* klass = (*result_type)->mClass;

    for(i=0; i<generics_num; i++) {
        int generics_paramType_offset = klass->mGenericsParamTypeOffsets[i];
        sCLClass* left_type = get_class_with_load((char*)((&klass->mConst)->mConst + generics_paramType_offset), js);

        sCLClass* right_type = (*result_type)->mGenericsTypes[i]->mClass;

        sCLClass* right_type2;
        solve_method_generics_for_variable_to_class(right_type, &right_type2, info);

        sCLClass* right_type3;
        solve_generics_for_variable_to_class(right_type2, &right_type3, info);

        if(!check_implemented_methods_for_interface(left_type, right_type3, 1)) {
            parser_err_msg(info, "%s is not implemented %s interface" , ((char*)(((&(right_type2)->mConst))->mConst + (right_type2)->mClassNameOffset)), ((char*)(((&(left_type)->mConst))->mConst + (left_type)->mClassNameOffset)));
            info->err_num++;
        }
    }

    if(generics_num != (*result_type)->mClass->mNumGenerics) {
        parser_err_msg(info, "Invalid genrics parametor number");
        info->err_num++;
    }

    return 1;
}

static int is_assign_operator(sParserInfo* info)
{
    return (*info->p == '+' && *(info->p+1) == '+')
        || (*info->p == '-' && *(info->p+1) == '-' && !isalnum(*(info->p+2)))
        || (*info->p == '+' && *(info->p+1) == '=')
        || (*info->p == '-' && *(info->p+1) == '=')
        || (*info->p == '*' && *(info->p+1) == '=')
        || (*info->p == '/' && *(info->p+1) == '=')
        || (*info->p == '%' && *(info->p+1) == '=')
        || (*info->p == '<' && *(info->p+1) == '<' && *(info->p+2) == '=')
        || (*info->p == '>' && *(info->p+1) == '>' && *(info->p+2) == '=')
        || (*info->p == '&' && *(info->p+1) == '=')
        || (*info->p == '^' && *(info->p+1) == '=')
        || (*info->p == '|' && *(info->p+1) == '=');
}

static int assign_operator(unsigned int* node, sParserInfo* info, int* plus_plus, int* minus_minus)
{
    *plus_plus = 0;
    *minus_minus = 0;

    if(*info->p == '+' && *(info->p+1) == '+') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = sNodeTree_create_int_value(1, 0, 0, 0, info);

        *node = sNodeTree_create_operand(kOpAdd, *node, right, 0, info);

        *plus_plus = 1;
    }
    else if(*info->p == '-' && *(info->p+1) == '-') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = sNodeTree_create_int_value(1, 0, 0, 0, info);

        *node = sNodeTree_create_operand(kOpSub, *node, right, 0, info);

        *minus_minus = 1;
    }
    else if(*info->p == '+' && *(info->p+1) == '=') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpAdd, *node, right, 0, info);
    }
    else if(*info->p == '-' && *(info->p+1) == '=') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpSub, *node, right, 0, info);;
    }
    else if(*info->p == '*' && *(info->p+1) == '=') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpMult, *node, right, 0, info);
    }
    else if(*info->p == '/' && *(info->p+1) == '=') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpDiv, *node, right, 0, info);
    }
    else if(*info->p == '%' && *(info->p+1) == '=') {
        info->p += 2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpMod, *node, right, 0, info);
    }
    else if(*info->p == '<' && *(info->p+1) == '<' && *(info->p+2) == '=') {
        info->p += 3;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpLeftShift, *node, right, 0, info);
    }
    else if(*info->p == '>' && *(info->p+1) == '>' && *(info->p+2) == '=') {
        info->p += 3;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpRightShift, *node, right, 0, info);
    }
    else if(*info->p == '&' && *(info->p+1) == '=') {
        info->p+=2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpAnd, *node, right, 0, info);
    }
    else if(*info->p == '^' && *(info->p+1) == '=') {
        info->p+=2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpXor, *node, right, 0, info);
    }
    else if(*info->p == '|' && *(info->p+1) == '=') {
        info->p+=2;
        skip_spaces_and_lf(info);

        unsigned int right = 0;
        if(!expression(&right, info)) {
            return 0;
        }

        if(right == 0) {
            parser_err_msg(info, "require right value for operator +=");
            info->err_num++;
        }

        *node = sNodeTree_create_operand(kOpOr, *node, right, 0, info);
    }

    return 1;
}

void after_assign_operator(unsigned int* node, sParserInfo* info, int plus_plus, int minus_minus)
{
    if(plus_plus) {
        unsigned int right = sNodeTree_create_int_value(1, 0, 0, 0, info);

        *node = sNodeTree_create_operand(kOpSub, *node, right, 0, info);
    }
    if(minus_minus) {
        unsigned int right = sNodeTree_create_int_value(1, 0, 0, 0, info);

        *node = sNodeTree_create_operand(kOpAdd, *node, right, 0, info);
    }
}

static int postposition_operator(unsigned int* node, sParserInfo* info, int* num_method_chains, unsigned int max_method_chains_node[128])
{
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '.' && *(info->p+1) == '.') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int tail = 0;
            if(!expression(&tail, info)) {
                return 0;
            }

            *node = sNodeTree_create_range(*node, tail, info);
        }

        else if(*info->p == '.' && *(info->p+1) != '.' && *(info->p+1) != '/') {
            info->p++;
            skip_spaces_and_lf(info);

            if(info->get_type_for_interpreter && *info->p == '\0')
            {
                *node = sNodeTree_create_method_call(*node, "", ((void*)0), 0, 0, info);
                return 1;
            }

            if(isalpha(*info->p) || *info->p == '_') {
                char buf[64];

                if(!parse_word(buf, 64, info, 1, 0)) {
                    return 0;
                }
                skip_spaces_and_lf(info);

                if(info->get_type_for_interpreter && *info->p == '\0') {
                    *node = sNodeTree_create_method_call(*node, "", ((void*)0), 0, *num_method_chains, info);
                    return 1;
                }


                if(*info->p == '(' || *info->p == '{') {
                    unsigned int params[32];
                    int num_params = 0;

                    if(!parse_method_params(&num_params, params, info)) {
                        return 0;
                    }

                    *node = sNodeTree_create_method_call(*node, buf, params, num_params, *num_method_chains, info);
                    max_method_chains_node[*num_method_chains] = *node;

                    (*num_method_chains)++;

                    if(*num_method_chains >= 128) {
                        parser_err_msg(info, "overflow method chain");
                        return 0;
                    }
                }

                else {
                    if(is_assign_operator(info)) {
                        unsigned int node2 = clone_node(*node);
                        unsigned int node3 = clone_node(*node);


                        *node = sNodeTree_create_fields(buf, node2, info);


                        int plus_plus = 0;
                        int minus_minus = 0;
                        if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                            return 0;
                        }

                        *node = sNodeTree_create_assign_field(buf, node3, *node, info);

                        after_assign_operator(node, info, plus_plus, minus_minus);
                    }
                    else if(*info->p == '=' && *(info->p +1) != '=') {
                        info->p++;
                        skip_spaces_and_lf(info);

                        unsigned int right_node = 0;

                        if(!expression(&right_node, info)) {
                            return 0;
                        }

                        if(right_node == 0) {
                            parser_err_msg(info, "Require right value");
                            info->err_num++;

                            *node = 0;
                        }
                        else {
                            *node = sNodeTree_create_assign_field(buf, *node, right_node, info);
                        }
                    }
                    else {
                        *node = sNodeTree_create_fields(buf, *node, info);
                    }
                }
            }
            else {
                parser_err_msg(info, "require method name or field name after .");
                info->err_num++;
                *node = 0;
                break;
            }
        }

        else if(*info->p == '[') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int index_node = 0;

            if(!expression(&index_node, info)) {
                return 0;
            }

            if(index_node == 0) {
                parser_err_msg(info, "Require index value");
                info->err_num++;

                *node = 0;
            }
            else {
                expect_next_character_with_one_forward("]", info);


                if(*info->p == '(') {
                    *node = sNodeTree_create_load_array_element(*node, index_node, info);

                    unsigned int params[32];
                    int num_params = 0;

                    if(!parse_method_params(&num_params, params, info)) {
                        return 0;
                    }

                    *node = sNodeTree_create_block_call(*node, "", num_params, params, info);
                }
                else if(is_assign_operator(info)) {
                    unsigned int node2 = clone_node(*node);
                    unsigned int index_node2 = clone_node(index_node);


                    *node = sNodeTree_create_load_array_element(*node, index_node, info);


                    int plus_plus = 0;
                    int minus_minus = 0;
                    if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                        return 0;
                    }

                    *node = sNodeTree_create_store_array_element(node2, index_node2, *node, info);

                    after_assign_operator(node, info, plus_plus, minus_minus);
                }
                else if(*info->p == '=' && *(info->p+1) != '=') {
                    info->p++;
                    skip_spaces_and_lf(info);

                    unsigned int right_node = 0;

                    if(!expression(&right_node, info)) {
                        return 0;
                    }

                    if(right_node == 0) {
                        parser_err_msg(info, "Require right value");
                        info->err_num++;

                        *node = 0;
                    }
                    else {
                        *node = sNodeTree_create_store_array_element(*node, index_node, right_node, info);
                    }
                }
                else {
                    *node = sNodeTree_create_load_array_element(*node, index_node, info);
                }
            }
        }

        else if(*info->p == '-' && *(info->p+1) == '>')
        {
            info->p+=2;
            skip_spaces_and_lf(info);

            sNodeType* node_type = ((void*)0);

            if(!parse_type(&node_type, info)) {
                return 0;
            }

            if(node_type == ((void*)0)) {
                parser_err_msg(info, "require a type for the pointer value");
                info->err_num++;
                *node = 0;
                return 1;
            }

            if(*info->p == '=' && *(info->p + 1) != '=') {
                info->p++;
                skip_spaces_and_lf(info);

                unsigned int right_node = 0;

                if(!expression(&right_node, info)) {
                    return 0;
                }

                if(right_node == 0) {
                    parser_err_msg(info, "Require right value");
                    info->err_num++;

                    *node = 0;
                }
                else {
                    *node = sNodeTree_create_store_value_to_pointer(*node, node_type, right_node, info);
                }
            }
            else {
                *node = sNodeTree_create_load_value_from_pointer(*node, node_type, info);
            }
        }
        else if(*info->p == '?') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int object_node = *node;

            unsigned int params[32];
            int num_params = 1;

            params[0] = sNodeTree_null_expression(info);

            *node = sNodeTree_create_method_call(*node, "identifyWith", params, num_params, *num_method_chains, info);

            *node = sNodeTree_create_method_call(*node, "negative", ((void*)0), 0, *num_method_chains, info);

            sNodeBlock* node_block;
            if(!parse_question_operator_block(object_node, *num_method_chains, &node_block, info)) {
                return 0;
            }

            if(*info->p == ':') {
                info->p++;
                skip_spaces_and_lf(info);

                num_params = 2;

                if(!expression(&params[0], info)) {
                    return 0;
                }

                int lambda = 0;
                sNodeType* result_type = create_node_type_with_class_name("Anonymous?", info->mJS);

                params[1] = sNodeTree_create_block_object(((void*)0), 0, result_type, node_block, lambda, info, 0, 0, ((void*)0), 1);

                *node = sNodeTree_create_method_call(*node, "if", params, num_params, *num_method_chains, info);
            }
            else {







                num_params = 1;

                int lambda = 0;
                sNodeType* result_type = create_node_type_with_class_name("Anonymous?", info->mJS);

                params[0] = sNodeTree_create_block_object(((void*)0), 0, result_type, node_block, lambda, info, 0, 0, ((void*)0), 1);

                *node = sNodeTree_create_method_call(*node, "if", params, num_params, *num_method_chains, info);
            }
        }
        else {
            break;
        }
    }

    return 1;
}

int parse_block_object(unsigned int* node, sParserInfo* info, int lambda)
{
    sParserParam params[32];
    memset(params, 0, sizeof(sParserParam)*32);
    int num_params = 0;


    sVarTable* new_table = ((void*)0);

    if(lambda) {
        if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, ((void*)0), 0)) {
            return 0;
        }
    }
    else {
        if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, info->lv_table, 0)) {
            return 0;
        }
    }

    sNodeType* result_type = ((void*)0);
    int omit_result_type = 0;
    if(*info->p == ':') {
        info->p++;
        skip_spaces_and_lf(info);

        if(!parse_type(&result_type, info)) {
            return 0;
        }
    }
    else {
        result_type = create_node_type_with_class_name("Null", info->mJS);
        omit_result_type = 1;
    }

    expect_next_character_with_one_forward("{", info);

    sNodeBlock* node_block = ((void*)0);
    if(!parse_block( &node_block, info, new_table, 1, 0)) {
        return 0;
    }

    *node = sNodeTree_create_block_object(params, num_params, result_type, node_block, lambda, info, omit_result_type, 0, ((void*)0), 0);

    return 1;
}

static int parse_var(unsigned int* node, sParserInfo* info, int readonly)
{

    char buf[64];

    if(!parse_word(buf, 64, info, 1, 0)) {
        return 0;
    }

    if(*info->p == ':') {
        info->p++;
    }

    sNodeType* node_type;
    if(*info->p != '=') {
        if(!parse_type(&node_type, info)) {
            return 0;
        }

        if(node_type->mClass == ((void*)0)) {
            *node = 0;
            return 1;
        }
        if(node_type) {
            check_already_added_variable(info->lv_table, buf, info);
            add_variable_to_table(info->lv_table, buf, node_type, readonly);
        }
    }
    else {
        node_type = ((void*)0);
        check_already_added_variable(info->lv_table, buf, info);
        add_variable_to_table(info->lv_table, buf, node_type, readonly);
    }


    if(*info->p == '=' && *(info->p+1) != '=') {
        info->p++;
        skip_spaces_and_lf(info);

        unsigned int right_node = 0;

        if(!expression(&right_node, info)) {
            return 0;
        }

        if(right_node == 0) {
            parser_err_msg(info, "Require right value");
            info->err_num++;

            *node = 0;
        }
        else {
            *node = sNodeTree_create_store_variable(buf, node_type, right_node, info->klass, info);
        }
    }
    else {
        parser_err_msg(info, "A variable should be initialized");
        info->err_num++;
    }

    return 1;
}

static int parse_function(unsigned int* node, sParserInfo* info, int lambda)
{

    char fun_name[64];

    if(!parse_word(fun_name, 64, info, 1, 0)) {
        return 0;
    }

    expect_next_character_with_one_forward("(", info);

    sNodeType* node_type = ((void*)0);
    check_already_added_variable(info->lv_table, fun_name, info);
    add_variable_to_table(info->lv_table, fun_name, node_type, 0);


    sParserParam params[32];
    memset(params, 0, sizeof(sParserParam)*32);
    int num_params = 0;


    sVarTable* new_table = ((void*)0);

    if(!parse_params_and_entry_to_lvtable(params, &num_params, info, &new_table, info->lv_table, 0)) {
        return 0;
    }

    sNodeType* result_type = ((void*)0);
    if(*info->p == ':') {
        info->p++;
        skip_spaces_and_lf(info);

        if(!parse_type(&result_type, info)) {
            return 0;
        }
    }
    else {
        result_type = create_node_type_with_class_name("Null", info->mJS);
    }

    expect_next_character_with_one_forward("{", info);

    sNodeBlock* node_block = ((void*)0);
    if(!parse_block( &node_block, info, new_table, 1, 0)) {
        return 0;
    }

    *node = sNodeTree_create_function(fun_name, params, num_params, result_type, node_block, lambda, info);

    return 1;
}

static int parse_normal_block(unsigned int* node, sParserInfo* info)
{
    sNodeBlock* node_block = ((void*)0);
    if(!parse_block( &node_block, info, ((void*)0), 0, 0)) {
        return 0;
    }

    *node = sNodeTree_create_normal_block( node_block, info);

    return 1;
}

static int parse_js_array_value_or_hash_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int array_elements[32];
    memset(array_elements, 0, sizeof(unsigned int)*32);

    unsigned int hash_keys[32 +1];
    unsigned int hash_items[32 +1];

    memset(hash_keys, 0, sizeof(unsigned int)*32);
    memset(hash_items, 0, sizeof(unsigned int)*32);

    if(*info->p == ']') {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            unsigned int node = 0;
            if(!expression(&node, info)) {
                return 0;
            }

            if(*info->p == '=' && *(info->p+1) == '>') {
                info->p+=2;
                skip_spaces_and_lf(info);

                hash_keys[num_elements] = node;

                unsigned int node2 = 0;
                if(!expression(&node2, info)) {
                    return 0;
                }

                hash_items[num_elements] = node2;

                num_elements++;

                if(num_elements >= 32) {
                    parser_err_msg(info, "overflow hash value elements");
                    return 0;
                }

                if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ']') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
                else {
                    parser_err_msg(info, "invalid hash value");
                    info->err_num++;
                }
            }
            else {
                array_elements[num_elements] = node;

                num_elements++;

                if(num_elements >= 32) {
                    parser_err_msg(info, "overflow array value elements");
                    return 0;
                }

                if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ']') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
                else {
                    parser_err_msg(info, "invalid array value");
                    info->err_num++;
                }
            }
        }
    }

    if(array_elements[0] == 0 && hash_keys[0] == 0) {
        *node = sNodeTree_create_js_array(num_elements, array_elements, info);
    }
    else if(array_elements[0] != 0 && hash_keys[0] != 0) {
        parser_err_msg(info, "invalid hash or array value");
        info->err_num++;
    }
    else if(array_elements[0] != 0) {
        *node = sNodeTree_create_js_array(num_elements, array_elements, info);
    }
    else if(hash_keys[0] != 0) {
        *node = sNodeTree_create_hash_value(num_elements, hash_keys, hash_items, info);
    }

    return 1;
}

static int parse_array_value_or_hash_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int array_elements[32];
    memset(array_elements, 0, sizeof(unsigned int)*32);

    unsigned int hash_keys[32 +1];
    unsigned int hash_items[32 +1];

    memset(hash_keys, 0, sizeof(unsigned int)*32);
    memset(hash_items, 0, sizeof(unsigned int)*32);

    while(1) {
        unsigned int node = 0;
        if(!expression(&node, info)) {
            return 0;
        }

        if(*info->p == '=' && *(info->p+1) == '>') {
            info->p+=2;
            skip_spaces_and_lf(info);

            hash_keys[num_elements] = node;

            unsigned int node2 = 0;
            if(!expression(&node2, info)) {
                return 0;
            }

            hash_items[num_elements] = node2;

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow hash value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == ']') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
            else {
                parser_err_msg(info, "invalid hash value");
                info->err_num++;
            }
        }
        else {
            array_elements[num_elements] = node;

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == ']') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
            else {
                parser_err_msg(info, "invalid array value");
                info->err_num++;
            }
        }
    }

    if(array_elements[0] != 0 && hash_keys[0] != 0) {
        parser_err_msg(info, "invalid hash or array value");
        info->err_num++;
    }
    else if(array_elements[0] != 0) {
        *node = sNodeTree_create_array_value(num_elements, array_elements, info);
    }
    else if(hash_keys[0] != 0) {
        *node = sNodeTree_create_hash_value(num_elements, hash_keys, hash_items, info);
    }

    return 1;
}

static int parse_carray_value(unsigned int* node, sParserInfo* info, char tail_char)
{
    int num_elements = 0;

    unsigned int array_elements[32];
    memset(array_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == tail_char) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(array_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == tail_char) {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_carray_value(num_elements, array_elements, info);

    return 1;
}

static int parse_equalable_carray_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int array_elements[32];
    memset(array_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == '}') {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(array_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '}') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_equalable_carray_value(num_elements, array_elements, info);

    return 1;
}

static int parse_sortable_carray_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int array_elements[32];
    memset(array_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == '}') {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(array_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '}') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_sortable_carray_value(num_elements, array_elements, info);

    return 1;
}

static int parse_hash_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int hash_keys[32 +1];
    unsigned int hash_items[32 +1];

    memset(hash_keys, 0, sizeof(unsigned int)*32);
    memset(hash_items, 0, sizeof(unsigned int)*32);

    if(*info->p == '}') {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(hash_keys + num_elements, info)) {
                return 0;
            }

            expect_next_character_with_one_forward(":", info);

            if(!expression(hash_items + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow hash value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '}') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_hash_value(num_elements, hash_keys, hash_items, info);

    return 1;
}

static int parse_list_value(unsigned int* node, sParserInfo* info, char tail_char)
{
    int num_elements = 0;

    unsigned int list_elements[32];
    memset(list_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == tail_char) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(list_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == tail_char) {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_list_value(num_elements, list_elements, info);

    return 1;
}

static int parse_equalable_list_value(unsigned int* node, sParserInfo* info, char tail_char)
{
    int num_elements = 0;

    unsigned int list_elements[32];
    memset(list_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == tail_char) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(list_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == tail_char) {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_equalable_list_value(num_elements, list_elements, info);

    return 1;
}

static int parse_sortable_list_value(unsigned int* node, sParserInfo* info, char tail_char)
{
    int num_elements = 0;

    unsigned int list_elements[32];
    memset(list_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == tail_char) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(list_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == tail_char) {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_sortable_list_value(num_elements, list_elements, info);

    return 1;
}

static int parse_js_array(unsigned int* node, sParserInfo* info, char tail_char)
{
    int num_elements = 0;

    unsigned int list_elements[32];
    memset(list_elements, 0, sizeof(unsigned int)*32);

    if(*info->p == tail_char) {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(list_elements + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == tail_char) {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_js_array(num_elements, list_elements, info);

    return 1;
}


static int parse_tuple_value(unsigned int* node, sParserInfo* info)
{
    int num_elements = 0;

    unsigned int tuple_element[32];
    memset(tuple_element, 0, sizeof(unsigned int)*32);

    if(*info->p == '}') {
        info->p++;
        skip_spaces_and_lf(info);
    }
    else {
        while(1) {
            if(!expression(tuple_element + num_elements, info)) {
                return 0;
            }

            num_elements++;

            if(num_elements >= 32) {
                parser_err_msg(info, "overflow array value elements");
                return 0;
            }

            if(*info->p == ',') {
                info->p++;
                skip_spaces_and_lf(info);
            }
            else if(*info->p == '}') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
        }
    }

    *node = sNodeTree_create_tuple_value(num_elements, tuple_element, info);

    return 1;
}

int parse_iniherit(unsigned int* node, sParserInfo* info)
{
    unsigned int params[32];
    int num_params = 0;

    if(!parse_method_params(&num_params, params, info)) {
        return 0;
    }

    *node = sNodeTree_create_inherit_call(num_params, params, info->klass->mMethodIndexOnCompileTime-1, info);

    return 1;
}

int parse_unset(unsigned int* node, sParserInfo* info)
{
    char var_name[64];


    if(!parse_word(var_name, 64, info, 1, 0)) {
        return 0;
    }

    sVar* var = get_variable_from_table(info->lv_table, var_name);

    if(var == ((void*)0)) {
        parser_err_msg(info, "%s is not defined", var_name);
        info->err_num++;
        return 1;
    }

    xstrncpy(var->mName, "", 64);

    return 1;
}

static int parse_string_expression(sNodeBlock** string_expressions, int* string_expression_offsets, int* num_string_expression, sBuf* value, sParserInfo* info)
{
    sNodeBlock* block = ((void*)0);
    if(!parse_block( &block, info, ((void*)0), 0, 1)) {
        return 0;
    }

    string_expressions[*num_string_expression] = block;
    string_expression_offsets[*num_string_expression] = value->mLen;

    (*num_string_expression)++;

    if(*num_string_expression >= 16) {
        parser_err_msg(info, "overflow string expression number");
        return 0;
    }

    return 1;
}

static int remove_indent_for_multi_line_string(sBuf* value, int indent, sParserInfo* info)
{
    int i;
    for(i=0; i<indent; i++) {
        if(*info->p == ' ') {
            info->p++;
        }
        else if(*info->p == '\n') {
            info->sline++;
            sBuf_append_char(value, *info->p);
            info->p++;

            remove_indent_for_multi_line_string(value, indent, info);
            break;
        }
        else {
            parser_err_msg(info, "require white space for indent of multi line string");
            info->err_num++;
        }
    }

    return 1;
}

static int parse_regex(unsigned int* node, sParserInfo* info)
{
    sNodeBlock* string_expressions[16];
    memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

    int string_expression_offsets[16];
    memset(string_expression_offsets, 0, sizeof(int)*16);

    int num_string_expression = 0;

    sBuf regex;
    sBuf_init(&regex);

    while(1) {
        if(*info->p == '\\' && *(info->p+1) == '"') {
            info->p++;
            sBuf_append_char(&regex, *info->p);
            info->p++;
        }
        else if(*info->p == '"') {
            info->p++;
            skip_spaces_and_lf(info);
            break;
        }
        else if(*info->p == '\\' && *(info->p+1) == '\\' && *(info->p+2) == '{') {
            sBuf_append_char(&regex, *info->p);
            info->p++;
            sBuf_append_char(&regex, *info->p);
            info->p++;
            sBuf_append_char(&regex, *info->p);
            info->p++;
        }
        else if(*info->p == '\\' && *(info->p+1) == '{') {
            info->p+=2;


            if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &regex, info))
            {
                xfree(regex.mBuf);
                return 0;
            }
        }
        else if(*info->p == '\0') {
            parser_err_msg(info, "close \" to make string value");
            info->err_num++;
            break;
        }
        else {
            if(*info->p == '\n') info->sline++;

            sBuf_append_char(&regex, *info->p);
            info->p++;
        }
    }

    skip_spaces_and_lf(info);

    int global = 0;
    int ignore_case = 0;
    int multiline = 0;
    int extended = 0;
    int dotall = 0;
    int anchored = 0;
    int dollar_endonly = 0;
    int ungreedy = 0;
    while(1) {
        if(*info->p == 'g') {
            info->p++;
            global = 1;
        }
        else if(*info->p == 'i') {
            info->p++;
            ignore_case = 1;
        }
        else if(*info->p == 's') {
            info->p++;
            dotall = 1;
        }
        else if(*info->p == 'm') {
            info->p++;
            multiline = 1;
        }
        else if(*info->p == 'A') {
            info->p++;
            anchored = 1;
        }
        else if(*info->p == 'D') {
            info->p++;
            dollar_endonly = 1;
        }
        else if(*info->p == 'U') {
            info->p++;
            ungreedy = 1;
        }
        else if(*info->p == 'x') {
            info->p++;
            extended = 1;
        }
        else {
            break;
        }
    }

    skip_spaces_and_lf(info);

    *node = sNodeTree_create_regex( regex.mBuf, global, ignore_case, multiline, extended, dotall, anchored, dollar_endonly, ungreedy, string_expressions, string_expression_offsets, num_string_expression, info);

    return 1;
}

static int expression_node(unsigned int* node, sParserInfo* info)
{
    int js = info->mJS;

    int num_method_chains = 0;
    unsigned int max_method_chains_node[128];


    if((*info->p == '-' && *(info->p+1) != '=' && *(info->p+1) != '-' && *(info->p+1) != '>') || (*info->p == '+' && *(info->p+1) != '=' && *(info->p+1) != '+'))
    {
        if(*info->p == '-') {
            info->p++;
            skip_spaces_and_lf(info);

            if(isdigit(*info->p)) {
                if(!get_number(1, node, info)) {
                    return 0;
                }
            }
            else {
                if(!expression_node(node, info)) {
                    return 0;
                }

                if(*node == 0) {
                    parser_err_msg(info, "require right value for -");
                    info->err_num++;
                }

                *node = sNodeTree_create_operand(kOpMinus, *node, 0, 0, info);
            }
        }
        else if(*info->p =='+') {
            info->p++;
            skip_spaces_and_lf(info);

            if(isdigit(*info->p)) {
                if(!get_number(0, node, info)) {
                    return 0;
                }
            }
            else {
                if(!expression_node(node, info)) {
                    return 0;
                }

                if(*node == 0) {
                    parser_err_msg(info, "require right value for -");
                    info->err_num++;
                }
            }
        }
    }

    else if(*info->p == '0' && *(info->p+1) == 'x') {
        info->p += 2;

        if(!get_hex_number(node, info)) {
            return 0;
        }
    }

    else if(*info->p == '0' && isdigit(*(info->p+1))) {
        info->p++;

        if(!get_oct_number(node, info)) {
            return 0;
        }
    }

    else if(isdigit(*info->p)) {
        if(!get_number(0, node, info)) {
            return 0;
        }
    }

    else if(*info->p == '"' && *(info->p+1) == '"' && *(info->p + 2) == '"' && *(info->p+3) == '\n')
    {
        int indent = 0;

        char* p = info->p;
        while(1) {
            if(p == info->source) {
                break;
            }
            else if(*p == '\n') {
                indent--;
                break;
            }
            else {
                p--;
                indent++;
            }
        }

        info->p+=4;

        int i;
        for(i=0; i<indent; i++) {
            if(*info->p == ' ') {
                info->p++;
            }
            else if(*info->p == '\n') {
                info->sline++;
                info->p++;
                break;
            }
            else {
                parser_err_msg(info, "require white space for indent of multi line string");
                info->err_num++;
            }
        }

        sBuf value;
        sBuf_init(&value);

        sNodeBlock* string_expressions[16];
        memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

        int string_expression_offsets[16];
        memset(string_expression_offsets, 0, sizeof(int)*16);

        int num_string_expression = 0;

        while(1) {
            if(*info->p == '"' && *(info->p+1) == '"' && *(info->p + 2) == '"')
            {
                info->p+=3;
                break;
            }
            else if(*info->p == '\\') {
                info->p++;

                switch(*info->p) {
                    case '0':
                        sBuf_append_char(&value, '\0');
                        info->p++;
                        break;

                    case '{':
                        info->p++;


                        if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &value, info))
                        {
                            xfree(value.mBuf);
                            return 0;
                        }
                        break;

                    case 'n':
                        sBuf_append_char(&value, '\n');
                        info->p++;
                        break;

                    case 't':
                        sBuf_append_char(&value, '\t');
                        info->p++;
                        break;

                    case 'r':
                        sBuf_append_char(&value, '\r');
                        info->p++;
                        break;

                    case 'a':
                        sBuf_append_char(&value, '\a');
                        info->p++;
                        break;

                    case '\\':
                        sBuf_append_char(&value, '\\');
                        info->p++;
                        break;

                    default:
                        sBuf_append_char(&value, *info->p);
                        info->p++;
                        break;
                }
            }
            else if(*info->p == '\0') {
                if(info->get_type_for_interpreter) {
                    break;
                }
                else {
                    parser_err_msg(info, "close \"\"\" to make string value");
                    xfree(value.mBuf);
                    return 0;
                }
            }
            else if(*info->p == '\n') {
                info->sline++;

                sBuf_append_char(&value, *info->p);
                info->p++;

                remove_indent_for_multi_line_string(&value, indent, info);
            }
            else {
                sBuf_append_char(&value, *info->p);
                info->p++;
            }
        }

        skip_spaces_and_lf(info);

        *node = sNodeTree_create_string_value( value.mBuf, string_expressions, string_expression_offsets, num_string_expression, info);
    }

    else if(*info->p == '"') {
        info->p++;

        sBuf value;
        sBuf_init(&value);

        sNodeBlock* string_expressions[16];
        memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

        int string_expression_offsets[16];
        memset(string_expression_offsets, 0, sizeof(int)*16);

        int num_string_expression = 0;

        while(1) {
            if(*info->p == '"') {
                info->p++;
                break;
            }
            else if(*info->p == '\\') {
                info->p++;

                switch(*info->p) {
                    case '0':
                        sBuf_append_char(&value, '\0');
                        info->p++;
                        break;

                    case '{':
                        info->p++;


                        if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &value, info))
                        {
                            xfree(value.mBuf);
                            return 0;
                        }
                        break;

                    case 'n':
                        sBuf_append_char(&value, '\n');
                        info->p++;
                        break;

                    case 't':
                        sBuf_append_char(&value, '\t');
                        info->p++;
                        break;

                    case 'r':
                        sBuf_append_char(&value, '\r');
                        info->p++;
                        break;

                    case 'a':
                        sBuf_append_char(&value, '\a');
                        info->p++;
                        break;

                    case '\\':
                        sBuf_append_char(&value, '\\');
                        info->p++;
                        break;

                    default:
                        sBuf_append_char(&value, *info->p);
                        info->p++;
                        break;
                }
            }
            else if(*info->p == '\0') {
                if(info->get_type_for_interpreter) {
                    break;
                }
                else {
                    parser_err_msg(info, "close \" to make string value");
                    xfree(value.mBuf);
                    return 0;
                }
            }
            else {
                if(*info->p == '\n') info->sline++;

                sBuf_append_char(&value, *info->p);
                info->p++;
            }
        }

        skip_spaces_and_lf(info);


        *node = sNodeTree_create_string_value( value.mBuf, string_expressions, string_expression_offsets, num_string_expression, info);
    }

    else if((*info->p == 'B' || *info->p == 'b') && *(info->p+1) == '"') {
        info->p+=2;

        sBuf value;
        sBuf_init(&value);

        sNodeBlock* string_expressions[16];
        memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

        int string_expression_offsets[16];
        memset(string_expression_offsets, 0, sizeof(int)*16);

        int num_string_expression = 0;

        while(1) {
            if(*info->p == '"') {
                info->p++;
                break;
            }
            else if(*info->p == '\\') {
                info->p++;
                switch(*info->p) {
                    case '0':
                        sBuf_append_char(&value, '\0');
                        info->p++;
                        break;

                    case '{':
                        info->p++;


                        if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &value, info))
                        {
                            xfree(value.mBuf);
                            return 0;
                        }
                        break;

                    case 'n':
                        sBuf_append_char(&value, '\n');
                        info->p++;
                        break;

                    case 't':
                        sBuf_append_char(&value, '\t');
                        info->p++;
                        break;

                    case 'r':
                        sBuf_append_char(&value, '\r');
                        info->p++;
                        break;

                    case 'a':
                        sBuf_append_char(&value, '\a');
                        info->p++;
                        break;

                    case '\\':
                        sBuf_append_char(&value, '\\');
                        info->p++;
                        break;

                    default:
                        sBuf_append_char(&value, *info->p);
                        info->p++;
                        break;
                }
            }
            else if(*info->p == '\0') {
                if(info->get_type_for_interpreter) {
                    break;
                }
                else {
                    parser_err_msg(info, "close \" to make string buffer value");
                    return 0;
                }
            }
            else {
                if(*info->p == '\n') info->sline++;

                sBuf_append_char(&value, *info->p);
                info->p++;
            }
        }

        skip_spaces_and_lf(info);

        *node = sNodeTree_create_buffer_value( value.mBuf, value.mLen, string_expressions, string_expression_offsets, num_string_expression, info);
    }

    else if((*info->p == 'P' || *info->p == 'p') && *(info->p+1) == '"') {
        info->p+=2;

        sBuf value;
        sBuf_init(&value);

        sNodeBlock* string_expressions[16];
        memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

        int string_expression_offsets[16];
        memset(string_expression_offsets, 0, sizeof(int)*16);

        int num_string_expression = 0;

        while(1) {
            if(*info->p == '"') {
                info->p++;
                break;
            }
            else if(*info->p == '\\') {
                info->p++;
                switch(*info->p) {
                    case '0':
                        sBuf_append_char(&value, '\0');
                        info->p++;
                        break;

                    case '{':
                        info->p++;


                        if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &value, info))
                        {
                            xfree(value.mBuf);
                            return 0;
                        }
                        break;

                    case 'n':
                        sBuf_append_char(&value, '\n');
                        info->p++;
                        break;

                    case 't':
                        sBuf_append_char(&value, '\t');
                        info->p++;
                        break;

                    case 'r':
                        sBuf_append_char(&value, '\r');
                        info->p++;
                        break;

                    case 'a':
                        sBuf_append_char(&value, '\a');
                        info->p++;
                        break;

                    case '\\':
                        sBuf_append_char(&value, '\\');
                        info->p++;
                        break;

                    default:
                        sBuf_append_char(&value, *info->p);
                        info->p++;
                        break;
                }
            }
            else if(*info->p == '\0') {
                if(info->get_type_for_interpreter) {
                    break;
                }
                else if(info->get_path_object) {
                    info->inputing_path_object = 1;
                    return 0;
                }
                else {
                    parser_err_msg(info, "close \" to make string buffer value");
                    return 0;
                }
            }
            else {
                if(*info->p == '\n') info->sline++;

                sBuf_append_char(&value, *info->p);
                info->p++;
            }
        }

        skip_spaces_and_lf(info);

        *node = sNodeTree_create_path_value( value.mBuf, value.mLen, string_expressions, string_expression_offsets, num_string_expression, info);
    }

    else if(*info->p == '\'') {
        info->p++;

        wchar_t c;

        if(*info->p == '\\') {
            info->p++;

            switch(*info->p) {
                case 'n':
                    c = '\n';
                    info->p++;
                    break;

                case 't':
                    c = '\t';
                    info->p++;
                    break;

                case 'r':
                    c = '\r';
                    info->p++;
                    break;

                case 'a':
                    c = '\a';
                    info->p++;
                    break;

                case '\\':
                    c = '\\';
                    info->p++;
                    break;

                case '0':
                    c = '\0';
                    info->p++;
                    break;

                default:
                    c = *info->p;
                    info->p++;
                    break;
            }
        }
        else {
            unsigned char p2 = *(unsigned char*)info->p;


            if(p2 > 127) {
                int size;
                char str[4 +1];

                size = ((p2 & 0x80) >> 7) + ((p2 & 0x40) >> 6) + ((p2 & 0x20) >> 5) + ((p2 & 0x10) >> 4);

                if(size > 4) {
                    parser_err_msg(info, "invalid utf-8 character. MB_LEN_MAX");
                    info->err_num++;
                }
                else {
                    memcpy(str, info->p, size);
                    str[size] = 0;

                    if(mbtowc(&c, str, size) < 0) {
                        parser_err_msg(info, "invalid utf-8 character. mbtowc");
                        info->err_num++;
                        c = 0;
                    }

                    info->p += size;
                }
            }

            else {
                c = *info->p;
                info->p++;
            }
        }

        if(*info->p != '\'') {
            parser_err_msg(info, "close \' to make character value");
            info->err_num++;
        }
        else {
            info->p++;

            skip_spaces_and_lf(info);

            *node = sNodeTree_create_character_value(c, info);
        }
    }
    else if(info->mJS && *info->p == '[')
    {
        info->p++;
        skip_spaces_and_lf(info);

        if(!parse_js_array_value_or_hash_value(node, info)) {
            return 0;
        }
    }

    else if(*info->p == '[') {
        info->p++;
        skip_spaces_and_lf(info);

        if(!parse_array_value_or_hash_value(node, info)) {
            return 0;
        }
    }

    else if(*info->p == '{') {
        info->p++;
        skip_spaces_and_lf(info);

        int list_value = 0;

        if(!info->mJS) {
            char* p_before = info->p;
            int sline_before = info->sline;

            unsigned int tmp = 0;
            (void)expression(&tmp, info);

            if(*info->p == ',') {
                list_value = 1;
            }

            info->p = p_before;
            info->sline = sline_before;
        }

        if(list_value) {
            if(!parse_sortable_list_value(node, info, '}')) {
                return 0;
            }
        }
        else {
            if(!parse_normal_block(node, info)) {
                return 0;
            }
        }
    }

    else if(isalpha(*info->p) || (*info->p == '.' && *(info->p+1) == '/') || (*info->p == '_'))
    {
        char buf[64];

        char* p_before = info->p;
        int sline_before = info->sline;

        if(*info->p == '.' || *(info->p+1) == '/') {
            info->p += 2;
            buf[0] = '.';
            buf[1] = '/';


            if(!parse_word(buf + 2, 64 -2, info, 1, 1)) {
                return 0;
            }
            skip_spaces_and_lf(info);
        }
        else {

            if(!parse_word(buf, 64, info, 1, 1)) {
                return 0;
            }
            skip_spaces_and_lf(info);
        }

        int including_slash = strstr(buf, "/") != ((void*)0);
        if(strcmp(buf, "if") == 0) {
            skip_spaces_and_lf(info);

            if(!if_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "when") == 0) {
            skip_spaces_and_lf(info);

            if(!when_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "while") == 0) {
            skip_spaces_and_lf(info);

            if(!while_expression(node, info)) {
                return 0;
            }

        }
        else if(strcmp(buf, "for") == 0) {
            skip_spaces_and_lf(info);

            if(!for_expression(node, info)) {
                return 0;
            }

        }
        else if(strcmp(buf, "break") == 0) {
            skip_spaces_and_lf(info);

            *node = sNodeTree_break_expression(info);
        }
        else if(strcmp(buf, "true") == 0) {
            skip_spaces_and_lf(info);

            *node = sNodeTree_true_expression(info);
        }
        else if(strcmp(buf, "false") == 0) {
            skip_spaces_and_lf(info);

            *node = sNodeTree_false_expression(info);
        }
        else if(strcmp(buf, "null") == 0) {
            skip_spaces_and_lf(info);

            *node = sNodeTree_null_expression(info);
        }
        else if(strcmp(buf, "wildcard") == 0) {
            skip_spaces_and_lf(info);

            *node = sNodeTree_wildcard_expression(info);
        }
        else if(strcmp(buf, "throw") == 0) {
            skip_spaces_and_lf(info);

            if(!throw_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "try") == 0) {
            skip_spaces_and_lf(info);

            if(!try_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "return") == 0) {
            skip_spaces_and_lf(info);

            if(!return_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "new") == 0) {
            skip_spaces_and_lf(info);

            if(!new_expression(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "closure") == 0 && *info->p == '(') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("(", info);

            if(!parse_block_object(node, info, 0)) {
                return 0;
            }
        }
        else if(strcmp(buf, "lambda") == 0 && *info->p == '(') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("(", info);

            if(!parse_block_object(node, info, 1)) {
                return 0;
            }
        }
        else if(strcmp(buf, "var") == 0) {
            skip_spaces_and_lf(info);

            if(!parse_var(node, info, 0)) {
                return 0;
            }
        }
        else if(strcmp(buf, "val") == 0) {
            skip_spaces_and_lf(info);

            if(!parse_var(node, info, 1)) {
                return 0;
            }
        }
        else if(strcmp(buf, "def") == 0) {
            skip_spaces_and_lf(info);

            if(!parse_function(node, info, 0)) {
                return 0;
            }
        }
        else if(strcmp(buf, "inherit") == 0) {
            skip_spaces_and_lf(info);

            if(!parse_iniherit(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "unset") == 0) {
            skip_spaces_and_lf(info);

            if(!parse_unset(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "list") == 0 && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_list_value(node, info, '}')) {
                return 0;
            }
        }
        else if((strcmp(buf, "equalable_list") == 0 || strcmp(buf, "elist") == 0) && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_equalable_list_value(node, info, '}')) {
                return 0;
            }
        }
        else if((strcmp(buf, "sortable_list") == 0 || strcmp(buf, "slist") == 0) && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_sortable_list_value(node, info, '}')) {
                return 0;
            }
        }
        else if(strcmp(buf, "tuple") == 0 && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_tuple_value(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "hash") == 0 && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_hash_value(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "array") == 0 && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_carray_value(node, info, '}')) {
                return 0;
            }
        }
        else if((strcmp(buf, "equalable_array") == 0 || strcmp(buf, "earray") == 0) && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_equalable_carray_value(node, info)) {
                return 0;
            }
        }
        else if((strcmp(buf, "sortable_array") == 0 || strcmp(buf, "sarray") == 0) && *info->p == '{') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("{", info);

            if(!parse_sortable_carray_value(node, info)) {
                return 0;
            }
        }
        else if(strcmp(buf, "regex") == 0 && *info->p == '"') {
            skip_spaces_and_lf(info);

            expect_next_character_with_one_forward("\"", info);

            if(!parse_regex(node, info)) {
                return 0;
            }
        }
        else if(info->mJS && strcmp(buf, "require") == 0) {
            skip_spaces_and_lf(info);

            char class_name[64];


            if(!parse_word(class_name, 64, info, 1, 0)) {
                return 0;
            }

            skip_spaces_and_lf(info);

            char file_name[64];


            if(!parse_word(file_name, 64, info, 1, 0)) {
                return 0;
            }

            skip_spaces_and_lf(info);

            *node = sNodeTree_create_require(class_name, file_name, info);
        }


        else if(!including_slash && *info->p == ':') {
            skip_spaces_and_lf(info);

            info->p++;
            skip_spaces_and_lf(info);

            sNodeType* node_type;
            if(*info->p != '=') {
                if(!parse_type(&node_type, info)) {
                    return 0;
                }

                if(node_type->mClass == ((void*)0)) {
                    *node = 0;
                    return 1;
                }
                if(node_type) {
                    check_already_added_variable(info->lv_table, buf, info);
                    add_variable_to_table(info->lv_table, buf, node_type, 0);
                }
            }
            else {
                node_type = ((void*)0);
                check_already_added_variable(info->lv_table, buf, info);
                add_variable_to_table(info->lv_table, buf, node_type, 0);

            }


            if(*info->p == '=' && *(info->p+1) != '=') {
                info->p++;
                skip_spaces_and_lf(info);

                unsigned int right_node = 0;

                if(!expression(&right_node, info)) {
                    return 0;
                }

                if(right_node == 0) {
                    parser_err_msg(info, "Require right value");
                    info->err_num++;

                    *node = 0;
                }
                else {
                    *node = sNodeTree_create_store_variable(buf, node_type, right_node, info->klass, info);
                }
            }
            else {
                parser_err_msg(info, "A variable should be initialized");
                info->err_num++;
            }
        }

        else if(!including_slash && *info->p == '=' && *(info->p+1) != '=') {

            if(get_variable_from_table(info->lv_table, buf) || is_method_param_name(buf)) {
                skip_spaces_and_lf(info);

                info->p++;
                skip_spaces_and_lf(info);

                unsigned int right_node = 0;

                if(!expression(&right_node, info)) {
                    return 0;
                }

                if(right_node == 0) {
                    parser_err_msg(info, "Require right value");
                    info->err_num++;

                    *node = 0;
                }
                else {
                    sVar* var = get_variable_from_table(info->lv_table, buf);

                    if(var && var->mReadOnly) {
                        parser_err_msg(info, "This is readonly variable.");
                        info->err_num++;

                        *node = 0;
                    }
                    else {
                        *node = sNodeTree_create_store_variable(buf, ((void*)0), right_node, info->klass, info);
                    }
                }
            }

            else if(info->klass && field_name_existance(info->klass, buf))
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable("self", info);

                info->p++;
                skip_spaces_and_lf(info);

                unsigned int right_node = 0;

                if(!expression(&right_node, info)) {
                    return 0;
                }

                if(right_node == 0) {
                    parser_err_msg(info, "Require right value");
                    info->err_num++;

                    *node = 0;
                }
                else {
                    *node = sNodeTree_create_assign_field(buf, *node, right_node, info);
                }
            }

            else if(info->klass && class_field_name_existance(info->klass, buf))
            {
                skip_spaces_and_lf(info);

                info->p++;
                skip_spaces_and_lf(info);

                unsigned int right_node = 0;

                if(!expression(&right_node, info)) {
                    return 0;
                }

                if(right_node == 0) {
                    parser_err_msg(info, "Require right value");
                    info->err_num++;

                    *node = 0;
                }
                else {
                    *node = sNodeTree_create_assign_class_field(info->klass, buf, right_node, info);
                }
            }
            else {
                info->sline = sline_before;
                parser_err_msg(info, "%s is undeclared.(1)", buf);
                info->err_num++;
            }
        }

        else if(!including_slash && is_assign_operator(info)) {

            if(get_variable_from_table(info->lv_table, buf) || is_method_param_name(buf)) {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable(buf, info);


                int plus_plus = 0;
                int minus_minus = 0;
                if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                    return 0;
                }

                *node = sNodeTree_create_store_variable(buf, ((void*)0), *node, info->klass, info);

                after_assign_operator(node, info, plus_plus, minus_minus);
            }

            else if(info->klass && class_field_name_existance(info->klass, buf))
            {
                skip_spaces_and_lf(info);


                *node = sNodeTree_create_class_fields(info->klass, buf, info);


                int plus_plus = 0;
                int minus_minus = 0;
                if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                    return 0;
                }

                *node = sNodeTree_create_assign_class_field(info->klass, buf, *node, info);

                after_assign_operator(node, info, plus_plus, minus_minus);
            }

            else if(info->klass && field_name_existance(info->klass, buf))
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable("self", info);

                unsigned int node2 = clone_node(*node);
                unsigned int node3 = clone_node(*node);


                *node = sNodeTree_create_fields(buf, node2, info);


                int plus_plus = 0;
                int minus_minus = 0;
                if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                    return 0;
                }

                *node = sNodeTree_create_assign_field(buf, node3, *node, info);

                after_assign_operator(node, info, plus_plus, minus_minus);
            }
            else {
                info->sline = sline_before;
                parser_err_msg(info, "%s is undeclared.(2)", buf);
                info->err_num++;
            }
        }
        else {
            sCLClass* klass;

            int sline_before = info->sline;

            if(strcmp(buf, "SELF") == 0) {
                klass = info->klass;
            }
            else {
                klass = get_class(buf, js);

                if(klass == ((void*)0)) {
# 4921 "<stdin>"
                    klass = get_class_with_load(buf, js);

                }
            }

            sCLClass* global_klass = get_class("Global", info->mJS);
            sCLClass* system_klass = get_class("System", info->mJS);
            sCLClass* command_class = get_class("Command", info->mJS);


            if(klass) {
                skip_spaces_and_lf(info);

                info->p = p_before;
                info->sline = sline_before;

                sNodeType* klass2;

                if(!parse_type(&klass2, info)) {
                    return 0;
                }


                if(*info->p == '.') {
                    info->p++;
                    skip_spaces_and_lf(info);

                    char buf[64];


                    if(!parse_word(buf, 64, info, 1, 0)) {
                        return 0;
                    }


                    if(*info->p == '(') {
                        unsigned int params[32];
                        int num_params = 0;

                        if(!parse_method_params(&num_params, params, info)) {
                            return 0;
                        }

                        *node = sNodeTree_create_class_method_call(klass2, buf, params, num_params, info);
                        max_method_chains_node[num_method_chains] = *node;
                        num_method_chains++;

                        if(num_method_chains >= 128) {
                            info->sline = sline_before;
                            parser_err_msg(info, "overflow method chain");
                            return 0;
                        }
                    }

                    else {
                        if(is_assign_operator(info)) {

                            *node = sNodeTree_create_class_fields(klass, buf, info);


                            int plus_plus = 0;
                            int minus_minus = 0;
                            if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                                return 0;
                            }

                            *node = sNodeTree_create_assign_class_field(klass, buf, *node, info);

                            after_assign_operator(node, info, plus_plus, minus_minus);
                        }
                        else if(*info->p == '=' && *(info->p +1) != '=') {
                            info->p++;
                            skip_spaces_and_lf(info);

                            unsigned int right_node = 0;

                            if(!expression(&right_node, info)) {
                                return 0;
                            }

                            if(right_node == 0) {
                                info->sline = sline_before;
                                parser_err_msg(info, "Require right value");
                                info->err_num++;

                                *node = 0;
                            }
                            else {
                                *node = sNodeTree_create_assign_class_field(klass, buf, right_node, info);
                            }
                        }
                        else {
                            *node = sNodeTree_create_class_fields(klass, buf, info);
                        }
                    }
                }
                else if(*info->p == '(' || *info->p == '[') {
                    info->p = p_before;
                    info->sline = sline_before;

                    if(!new_expression(node, info)) {
                        return 0;
                    }
                }
                else {
                    info->sline = sline_before;
                    parser_err_msg(info, "require . or ( or [ after class name");
                    info->err_num++;
                }
            }

            else if(strcmp(buf, "self") == 0
                || is_method_param_name(buf)
                || get_variable_from_table(info->lv_table, buf))
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable(buf, info);


                if(*info->p == '(') {
                    unsigned int params[32];
                    int num_params = 0;

                    if(!parse_method_params(&num_params, params, info)) {
                        return 0;
                    }

                    *node = sNodeTree_create_block_call(*node, buf, num_params, params, info);
                }
            }

            else if(info->klass && field_name_existance(info->klass, buf) && *info->p != '(')
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable("self", info);

                *node = sNodeTree_create_fields(buf, *node, info);
            }

            else if(info->klass && class_field_name_existance(info->klass, buf) && *info->p != '(')
            {
                skip_spaces_and_lf(info);

                if(is_assign_operator(info)) {

                    *node = sNodeTree_create_class_fields(info->klass, buf, info);


                    int plus_plus = 0;
                    int minus_minus = 0;
                    if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                        return 0;
                    }

                    *node = sNodeTree_create_assign_class_field(info->klass, buf, *node, info);

                    after_assign_operator(node, info, plus_plus, minus_minus);
                }
                else if(*info->p == '=' && *(info->p +1) != '=') {
                    info->p++;
                    skip_spaces_and_lf(info);

                    unsigned int right_node = 0;

                    if(!expression(&right_node, info)) {
                        return 0;
                    }

                    if(right_node == 0) {
                        info->sline = sline_before;
                        parser_err_msg(info, "Require right value");
                        info->err_num++;

                        *node = 0;
                    }
                    else {
                        *node = sNodeTree_create_assign_class_field(info->klass, buf, right_node, info);
                    }
                }
                else {
                    *node = sNodeTree_create_class_fields(info->klass, buf, info);
                }
            }

            else if(info->klass && none_class_method_name_existance(info->klass, buf) && *info->p == '(')
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable("self", info);

                unsigned int params[32];
                int num_params = 0;

                if(!parse_method_params(&num_params, params, info)) {
                    return 0;
                }

                *node = sNodeTree_create_method_call(*node, buf, params, num_params, num_method_chains, info);
                max_method_chains_node[num_method_chains] = *node;

                num_method_chains++;

                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }
            }

            else if(info->klass && class_method_name_existance(info->klass, buf) && *info->p == '(')
            {
                skip_spaces_and_lf(info);

                unsigned int params[32];
                int num_params = 0;

                if(!parse_method_params(&num_params, params, info)) {
                    return 0;
                }

                sNodeType* node_type = alloc_node_type();

                node_type->mClass = info->klass;
                node_type->mNumGenericsTypes = 0;

                *node = sNodeTree_create_class_method_call(node_type, buf, params, num_params, info);
                max_method_chains_node[num_method_chains] = *node;
                num_method_chains++;
                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }
            }

            else if(system_klass && class_field_name_existance(system_klass, buf) && *info->p != '(')
            {
                skip_spaces_and_lf(info);

                if(is_assign_operator(info)) {

                    *node = sNodeTree_create_class_fields(system_klass, buf, info);


                    int plus_plus = 0;
                    int minus_minus = 0;
                    if(!assign_operator(node, info, &plus_plus, &minus_minus)) {
                        return 0;
                    }

                    *node = sNodeTree_create_assign_class_field(system_klass, buf, *node, info);

                    after_assign_operator(node, info, plus_plus, minus_minus);
                }
                else if(*info->p == '=' && *(info->p +1) != '=') {
                    info->p++;
                    skip_spaces_and_lf(info);

                    unsigned int right_node = 0;

                    if(!expression(&right_node, info)) {
                        return 0;
                    }

                    if(right_node == 0) {
                        info->sline = sline_before;
                        parser_err_msg(info, "Require right value");
                        info->err_num++;

                        *node = 0;
                    }
                    else {
                        *node = sNodeTree_create_assign_class_field(system_klass, buf, right_node, info);
                    }
                }
                else {
                    *node = sNodeTree_create_class_fields(system_klass, buf, info);
                }
            }

            else if(system_klass && class_method_name_existance(system_klass, buf) && *info->p == '(')
            {
                skip_spaces_and_lf(info);

                unsigned int params[32];
                int num_params = 0;

                if(!parse_method_params(&num_params, params, info)) {
                    return 0;
                }

                sNodeType* system_klass_type = alloc_node_type();

                system_klass_type->mClass = system_klass;
                system_klass_type->mNumGenericsTypes = 0;

                *node = sNodeTree_create_class_method_call(system_klass_type, buf, params, num_params, info);
                max_method_chains_node[num_method_chains] = *node;
                num_method_chains++;
                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }
            }

            else if(global_klass && class_method_name_existance(global_klass, buf) && *info->p == '(')
            {
                skip_spaces_and_lf(info);

                unsigned int params[32];
                int num_params = 0;

                if(!parse_method_params(&num_params, params, info)) {
                    return 0;
                }

                sNodeType* global_klass_type = alloc_node_type();

                global_klass_type->mClass = global_klass;
                global_klass_type->mNumGenericsTypes = 0;

                *node = sNodeTree_create_class_method_call(global_klass_type, buf, params, num_params, info);
                max_method_chains_node[num_method_chains] = *node;
                num_method_chains++;
                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }
            }

            else if(get_variable_index(info->lv_table, buf) == -1 && is_command_name(buf) && *info->p == '(')
            {
                skip_spaces_and_lf(info);


                unsigned int params[32];
                int num_params = 0;

                if(!parse_method_params(&num_params, params, info)) {
                    return 0;
                }

                sCLClass* command_klass = get_class("Command", info->mJS);

                                              ;

                sNodeType* command_klass_type = alloc_node_type();

                command_klass_type->mClass = command_klass;
                command_klass_type->mNumGenericsTypes = 0;

                *node = sNodeTree_create_class_method_call(command_klass_type, buf, params, num_params, info);
                max_method_chains_node[num_method_chains] = *node;
                num_method_chains++;

                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }
            }

            else if(info->multiple_assignment)
            {
                skip_spaces_and_lf(info);

                *node = sNodeTree_create_load_variable(buf, info);
            }

            else if(including_slash || (command_class && class_method_name_existance(command_class, buf)) || (get_variable_index(info->lv_table, buf) == -1 && is_command_name(buf) && *info->p != '('))
            {
                unsigned int params[32];
                int num_params = 0;

                char* method_name = buf;

                if(!parse_command_method_params(&num_params, params, info, 1, method_name)) {
                    return 0;
                }

                sCLClass* command_klass = get_class("Command", info->mJS);

                                              ;

                sNodeType* command_klass_type = alloc_node_type();

                command_klass_type->mClass = command_klass;
                command_klass_type->mNumGenericsTypes = 0;

                *node = sNodeTree_create_class_method_call(command_klass_type, buf, params, num_params, info);
                max_method_chains_node[num_method_chains] = *node;
                num_method_chains++;

                if(num_method_chains >= 128) {
                    info->sline = sline_before;
                    parser_err_msg(info, "overflow method chain");
                    return 0;
                }

                while(1) {
                    if(*info->p == '|' && *(info->p+1) != '|')
                    {
                        info->p++;
                        skip_spaces_and_lf(info);

                        char buf[64];


                        if(!parse_word(buf, 64, info, 1, 1)) {
                            return 0;
                        }

                        unsigned int params[32];
                        int num_params = 0;

                        if(!parse_command_method_params(&num_params, params, info, 0, method_name)) {
                            return 0;
                        }

                        *node = sNodeTree_create_method_call(*node, buf, params, num_params, num_method_chains, info);
                        max_method_chains_node[num_method_chains] = *node;

                        num_method_chains++;

                        if(num_method_chains >= 128) {
                            info->sline = sline_before;
                            parser_err_msg(info, "overflow method chain");
                            return 0;
                        }
                    }
                    else if(info->next_command_is_to_bool || (*info->p == '&' && *(info->p+1) == '&') || (*info->p == '|' && *(info->p+1) == '|'))
                    {
                        unsigned int params[32];
                        int num_params = 0;

                        if(gNodes[*node].mNodeType == kNodeTypeClassMethodCall) {
                            int string_node = sNodeTree_create_string_value( xstrdup("--controlling-terminal"), ((void*)0), ((void*)0), 0, info);

                            int num_params = gNodes[*node].uValue.sClassMethodCall.mNumParams;
                            gNodes[*node].uValue.sClassMethodCall.mParams[num_params] = string_node;
                            gNodes[*node].uValue.sClassMethodCall.mNumParams++;
                        }
                        else if(gNodes[*node].mNodeType == kNodeTypeMethodCall) {
                            int string_node = sNodeTree_create_string_value( xstrdup("--controlling-terminal"), ((void*)0), ((void*)0), 0, info);

                            int num_params = gNodes[*node].uValue.sMethodCall.mNumParams;
                            gNodes[*node].uValue.sMethodCall.mParams[num_params] = string_node;
                            gNodes[*node].uValue.sMethodCall.mNumParams++;
                        }

                        *node = sNodeTree_create_method_call(*node, "toBool", ((void*)0), 0, num_method_chains, info);

                        info->next_command_is_to_bool = 1;
                        break;
                    }
                    else if(*info->p == '>' && *(info->p+1) == '>')
                    {
                        info->p+=2;
                        skip_spaces_and_lf(info);

                        sBuf param;
                        sBuf_init(&param);

                        int quoted_string = 0;

                        if(!parse_command_param(&param, &quoted_string, info))
                        {
                            xfree(param.mBuf);
                            info->sline = sline_before;
                            return 0;
                        }

                        if(param.mLen == 0) {
                            xfree(param.mBuf);
                            info->sline = sline_before;
                            parser_err_msg(info, "null file name");
                            return 0;
                        }

                        unsigned int params[32];
                        int num_params = 1;

                        params[0] = sNodeTree_create_string_value( param.mBuf, ((void*)0), ((void*)0), 0, info);

                        *node = sNodeTree_create_method_call(*node, "append", params, num_params, num_method_chains, info);
                        max_method_chains_node[num_method_chains] = *node;

                        num_method_chains++;

                        if(num_method_chains >= 128)
                        {
                            info->sline = sline_before;
                            parser_err_msg(info, "overflow method chain");
                            return 0;
                        }
                    }
                    else if(*info->p == '>') {
                        info->p++;
                        skip_spaces_and_lf(info);

                        sBuf param;
                        sBuf_init(&param);

                        int quoted_string = 0;

                        if(!parse_command_param(&param, &quoted_string, info))
                        {
                            xfree(param.mBuf);
                            info->sline = sline_before;
                            return 0;
                        }

                        if(param.mLen == 0) {
                            xfree(param.mBuf);
                            info->sline = sline_before;
                            parser_err_msg(info, "null file name");
                            return 0;
                        }

                        unsigned int params[32];
                        int num_params = 1;

                        params[0] = sNodeTree_create_string_value( param.mBuf, ((void*)0), ((void*)0), 0, info);

                        *node = sNodeTree_create_method_call(*node, "write", params, num_params, num_method_chains, info);
                        max_method_chains_node[num_method_chains] = *node;

                        num_method_chains++;

                        if(num_method_chains >= 128)
                        {
                            info->sline = sline_before;
                            parser_err_msg(info, "overflow method chain");
                            return 0;
                        }
                    }
                    else if(*info->p == ';' || *info->p == '\n') {
                        info->p++;
                        skip_spaces_and_lf(info);
                        break;
                    }
                    else if(*info->p == '\0') {
                        break;
                    }
                    else {
                        info->sline = sline_before;
                        parser_err_msg(info, "unexpected character (%c) 1", *info->p);
                        info->p++;
                        break;
                    }
                }

                int blank = *(info->p-1) == ' ' || *(info->p-1) == '\t';

                if(info->get_in_the_shell_mode == 1) {
                    if(info->get_in_the_shell_mode
                        && *info->p == '\0'
                        && (num_params > 1
                            || (num_params == 1 && blank)
                            || (num_params == 0 && is_command_name(buf) && blank)
                            || (num_params >= 1 && is_command_name(buf))))
                    {
                        info->inputing_shell_mode = 1;
                        return 0;
                    }
                }
                else if(info->get_in_the_shell_mode == 2) {
                    if(info->get_in_the_shell_mode
                        && *info->p == '\0'
                        && (num_params > 1
                            || (num_params == 1 && blank)
                            || (num_params == 0 && is_command_name(buf) && blank)
                            || (num_params > 1 && is_command_name(buf))))
                    {
                        info->inputing_shell_mode = 1;
                        return 0;
                    }
                }
            }
            else {
                info->sline = sline_before;
                parser_err_msg(info, "%s is undeclared(3)", buf);
                info->err_num++;
            }
        }
    }

    else if(*info->p == '/' && *(info->p+1) != '*') {
        info->p++;
        skip_spaces_and_lf(info);

        sNodeBlock* string_expressions[16];
        memset(string_expressions, 0, sizeof(sNodeBlock*)*16);

        int string_expression_offsets[16];
        memset(string_expression_offsets, 0, sizeof(int)*16);

        int num_string_expression = 0;

        sBuf regex;
        sBuf_init(&regex);

        while(1) {
            if(*info->p == '\\' && *(info->p+1) == '/') {
                info->p++;
                sBuf_append_char(&regex, *info->p);
                info->p++;
            }
            else if(*info->p == '/') {
                info->p++;
                skip_spaces_and_lf(info);
                break;
            }
            else if(*info->p == '\\' && *(info->p+1) == '\\' && *(info->p+2) == '{') {
                sBuf_append_char(&regex, *info->p);
                info->p++;
                sBuf_append_char(&regex, *info->p);
                info->p++;
                sBuf_append_char(&regex, *info->p);
                info->p++;
            }
            else if(*info->p == '\\' && *(info->p+1) == '{') {
                info->p+=2;


                if(!parse_string_expression(string_expressions, string_expression_offsets, &num_string_expression, &regex, info))
                {
                    xfree(regex.mBuf);
                    return 0;
                }
            }
            else if(*info->p == '\0') {
                parser_err_msg(info, "close \" to make string value");
                info->err_num++;
                break;
            }
            else {
                if(*info->p == '\n') info->sline++;

                sBuf_append_char(&regex, *info->p);
                info->p++;
            }
        }

        skip_spaces_and_lf(info);

        int global = 0;
        int ignore_case = 0;
        int multiline = 0;
        int extended = 0;
        int dotall = 0;
        int anchored = 0;
        int dollar_endonly = 0;
        int ungreedy = 0;
        while(1) {
            if(*info->p == 'g') {
                info->p++;
                global = 1;
            }
            else if(*info->p == 'i') {
                info->p++;
                ignore_case = 1;
            }
            else if(*info->p == 's') {
                info->p++;
                dotall = 1;
            }
            else if(*info->p == 'm') {
                info->p++;
                multiline = 1;
            }
            else if(*info->p == 'A') {
                info->p++;
                anchored = 1;
            }
            else if(*info->p == 'D') {
                info->p++;
                dollar_endonly = 1;
            }
            else if(*info->p == 'U') {
                info->p++;
                ungreedy = 1;
            }
            else if(*info->p == 'x') {
                info->p++;
                extended = 1;
            }
            else {
                break;
            }
        }

        skip_spaces_and_lf(info);

        *node = sNodeTree_create_regex( regex.mBuf, global, ignore_case, multiline, extended, dotall, anchored, dollar_endonly, ungreedy, string_expressions, string_expression_offsets, num_string_expression, info);
    }

    else if(*info->p == '(') {
        info->p++;
        skip_spaces_and_lf(info);

        info->multiple_assignment = 1;


        if(!expression(node, info)) {
            info->multiple_assignment = 0;
            return 0;
        }
        skip_spaces_and_lf(info);

        if(*node == 0) {
            parser_err_msg(info, "require expression as ( operand");
            info->err_num++;
        }


        if(*info->p == ',') {
            info->p++;
            skip_spaces_and_lf(info);

            int num_elements = 0;

            unsigned int tuple_element[32];
            memset(tuple_element, 0, sizeof(unsigned int)*32);

            tuple_element[0] = *node;
            num_elements++;

            while(1) {
                if(!expression(tuple_element + num_elements, info)) {
                    info->multiple_assignment = 0;
                    return 0;
                }

                num_elements++;

                if(num_elements >= 32) {
                    parser_err_msg(info, "overflow array value elements");
                    info->multiple_assignment = 0;
                    return 0;
                }

                if(*info->p == ',') {
                    info->p++;
                    skip_spaces_and_lf(info);
                }
                else if(*info->p == ')') {
                    info->p++;
                    skip_spaces_and_lf(info);
                    break;
                }
            }


            if(*info->p == ':' && *(info->p+1) == '=') {
                info->p+=2;
                skip_spaces_and_lf(info);

                unsigned int node2 = 0;
                if(!expression(&node2, info)) {
                    info->multiple_assignment = 0;
                    return 0;
                }


                int i;
                for(i=0; i<num_elements; i++) {
                    int node = tuple_element[i];

                    if(gNodes[node].mNodeType != kNodeTypeLoadVariable) {
                        parser_err_msg(info, "require variable name for left value of :=");
                        info->err_num++;
                    }

                    char* var_name = gNodes[node].uValue.mVarName;

                    check_already_added_variable(info->lv_table, var_name, info);
                    add_variable_to_table(info->lv_table, var_name, ((void*)0), 0);
                }

                *node = sNodeTree_create_multiple_asignment(num_elements, tuple_element, node2, info);
            }

            else if(*info->p == '=' && *(info->p+1) != '=') {
                info->p++;
                skip_spaces_and_lf(info);

                unsigned int node2 = 0;
                if(!expression(&node2, info)) {
                    info->multiple_assignment = 0;
                    return 0;
                }


                int i;
                for(i=0; i<num_elements; i++) {
                    int node = tuple_element[i];

                    if(gNodes[node].mNodeType == kNodeTypeLoadVariable) {
                        char* var_name = gNodes[node].uValue.mVarName;

                        int var_index = get_variable_index(info->lv_table, var_name);
                        if(var_index == -1) {
                            parser_err_msg(info, "undeclared variable(%s)(4)", var_name);
                            info->err_num++;
                        }
                    }
                    else if(gNodes[node].mNodeType == kNodeTypeLoadField) {
                    }
                    else if(gNodes[node].mNodeType == kNodeTypeLoadClassField) {
                    }
                    else {
                        parser_err_msg(info, "require variable name for left value of =");
                        info->err_num++;
                    }
                }

                *node = sNodeTree_create_multiple_asignment(num_elements, tuple_element, node2, info);
            }
            else {
                *node = sNodeTree_create_tuple_value(num_elements, tuple_element, info);
            }
        }
        else {
            if(!expect_next_character(")", info)) {
                info->multiple_assignment = 0;
                return 0;
            }
            info->p++;
            skip_spaces_and_lf(info);
        }

        info->multiple_assignment = 0;
    }

    else if(*info->p == '&') {
        info->p++;
        skip_spaces_and_lf(info);

        if(!expression(node, info)) {
            return 0;
        }
        skip_spaces_and_lf(info);

        *node = sNodeTree_create_get_address(*node, info);
    }

    else if(*info->p == 0) {
        *node = 0;
        return 1;
    }
    else {
        parser_err_msg(info, "invalid character (character code %d) (%c)", *info->p, *info->p);

        if(*info->p == '\n') info->sline++;
        info->p++;
        skip_spaces_and_lf(info);

        info->err_num++;

        *node = 0;
    }


    if(!postposition_operator(node, info, &num_method_chains, max_method_chains_node))
    {
        return 0;
    }

    gNodes[*node].mMaxMethodChains = num_method_chains;

    int i;
    for(i=0; i<num_method_chains; i++) {
        gNodes[max_method_chains_node[i]].mMaxMethodChains = num_method_chains;
    }

    return 1;
}


static int expression_monadic_operator(unsigned int* node, sParserInfo* info)
{
    while(*info->p) {
        if(*info->p == '+' && *(info->p+1) == '+') {
            info->p +=2;
            skip_spaces_and_lf(info);

            if(!expression_monadic_operator(node, info)) {
                return 0;
            }

            if(*node == 0) {
                parser_err_msg(info, "require value for operator ++");
                info->err_num++;
            }

            if(!check_node_is_variable(*node)) {
                parser_err_msg(info, "require the variable name for operator ++");
                info->err_num++;
            }

            *node = sNodeTree_create_monadic_increment_operand(*node, info);
            break;
        }
        else if(*info->p == '-' && *(info->p+1) == '-') {
            info->p +=2;
            skip_spaces_and_lf(info);

            if(!expression_monadic_operator(node, info)) {
                return 0;
            }

            if(*node == 0) {
                parser_err_msg(info, "require value for operator --");
                info->err_num++;
            }

            if(!check_node_is_variable(*node)) {
                parser_err_msg(info, "require the variable name for operator ++");
                info->err_num++;
            }

            *node = sNodeTree_create_monadic_decrement_operand(*node, info);
            break;
        }
        else if(*info->p == '~') {
            info->p++;
            skip_spaces_and_lf(info);

            if(!expression_monadic_operator(node, info)) {
                return 0;
            }

            if(*node == 0) {
                parser_err_msg(info, "require value for operator ~");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComplement, *node, 0, 0, info);
            break;
        }
        else if(*info->p == '!') {
            info->p++;
            skip_spaces_and_lf(info);

            if(!expression_monadic_operator(node, info)) {
                return 0;
            }

            if(*node == 0) {
                parser_err_msg(info, "require value for !");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpLogicalDenial, *node, 0, 0, info);
            break;
        }
        else {
            if(!expression_node(node, info)) {
                return 0;
            }
            break;
        }
    }


    return 1;
}

static int expression_implements(unsigned int* node, sParserInfo* info)
{
    if(!expression_monadic_operator(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(memcmp(info->p, "implements", 10) == 0) {
            info->p+=10;
            skip_spaces_and_lf(info);

            char buf[64 +1];


            if(!parse_word(buf, 64, info, 1, 0)) {
                return 0;
            }

            *node = sNodeTree_create_implements(*node, buf, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_mult_div(unsigned int* node, sParserInfo* info)
{
    if(!expression_implements(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '*' && *(info->p+1) != '=') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_implements(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator *");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpMult, *node, right, 0, info);
        }
        else if(*info->p == '/' && *(info->p+1) != '=' && *(info->p+1) != '*') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_implements(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator /");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpDiv, *node, right, 0, info);
        }
        else if(*info->p == '%' && *(info->p+1) != '=') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_implements(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator ^");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpMod, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_add_sub(unsigned int* node, sParserInfo* info)
{
    if(!expression_mult_div(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '+' && *(info->p+1) != '=' && *(info->p+1) != '+') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_mult_div(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator +");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpAdd, *node, right, 0, info);
        }
        else if(*info->p == '-' && *(info->p+1) != '=' && *(info->p+1) != '-' && *(info->p+1) != '>') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_mult_div(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator -");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpSub, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_shift(unsigned int* node, sParserInfo* info)
{
    if(!expression_add_sub(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '<' && *(info->p+1) == '<' && *(info->p+2) != '=') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_add_sub(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator <<");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpLeftShift, *node, right, 0, info);
        }
        else if(*info->p == '>' && *(info->p+1) == '>' && *(info->p+2) != '=') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_add_sub(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator >>");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpRightShift, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_comparison_operator(unsigned int* node, sParserInfo* info)
{
    if(!expression_shift(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '>' && *(info->p+1) == '=') {
            info->p += 2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_shift(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for >= operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonGreaterEqual, *node, right, 0, info);
        }
        else if(*info->p == '<' && *(info->p+1) == '=') {
            info->p += 2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_shift(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for <= operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonLesserEqual, *node, right, 0, info);
        }
        else if(*info->p == '>' && *(info->p+1) != '>') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_shift(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for > operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonGreater, *node, right, 0, info);
        }
        else if(*info->p == '<' && *(info->p+1) != '<') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_shift(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for < operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonLesser, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_comparison_equal_operator(unsigned int* node, sParserInfo* info)
{
    if(!expression_comparison_operator(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '=' && *(info->p+1) == '=') {
            info->p += 2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_comparison_operator(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for == operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonEqual, *node, right, 0, info);
        }
        else if(*info->p == '!' && *(info->p+1) == '=') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_comparison_operator(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for != operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpComparisonNotEqual, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_and(unsigned int* node, sParserInfo* info)
{
    if(!expression_comparison_equal_operator(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '&' && *(info->p+1) != '&' && *(info->p+1) != '=') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_comparison_equal_operator(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for & operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpAnd, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_xor(unsigned int* node, sParserInfo* info)
{
    if(!expression_and(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '^' && *(info->p+1) != '=') {
            info->p++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_and(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for ^ operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpXor, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}


static int expression_or(unsigned int* node, sParserInfo* info)
{
    if(!expression_xor(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '|' && *(info->p+1) != '=' && *(info->p+1) != '|') {
            (info->p)++;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_xor(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for | operator");
                info->err_num++;
            }

            *node = sNodeTree_create_operand(kOpOr, *node, right, 0, info);
        }
        else {
            break;
        }
    }

    return 1;
}

static int expression_and_and_or_or(unsigned int* node, sParserInfo* info)
{
    if(!expression_or(node, info)) {
        return 0;
    }
    if(*node == 0) {
        return 1;
    }

    while(*info->p) {
        if(*info->p == '&' && *(info->p+1) == '&') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_or(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for && operator");
                info->err_num++;
            }

            *node = sNodeTree_create_and_and(*node, right, info);
        }
        else if(*info->p == '|' && *(info->p+1) == '|') {
            info->p+=2;
            skip_spaces_and_lf(info);

            unsigned int right = 0;
            if(!expression_or(&right, info)) {
                return 0;
            }

            if(right == 0) {
                parser_err_msg(info, "require right value for operator ||");
                info->err_num++;
            }

            *node = sNodeTree_create_or_or(*node, right, info);
        }
        else {
            break;
        }
    }

    return 1;
}

int expression(unsigned int* node, sParserInfo* info)
{
    skip_spaces_and_lf(info);

    if(!expression_and_and_or_or(node, info)) {
        return 0;
    }

    return 1;
}
