include "String.clc"

module MExtendedListImplementation
{
    def sample():T {
        return self.items(System.rand() % self.number);
    }

    def map(block_:lambda(T):Anonymous): SELF<Anonymous> {
        result:SELF<Anonymous> = new SELF<Anonymous>();

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.add(block_(it.item));

            it = it.next;
        }

        return result;
    }

    def append(list:SELF<T>):SELF<T> {
        list.each(closure(item:T) {
            self.add(item);
        });

        return self;
    }

    def multiply(n:int):SELF<T> {
        result:SELF<T> = new SELF<T>();

        for(i:int = 0; i<n; i++) {
            result.append(self);
        }

        return result;
    }

    def select(block_:lambda(T):bool):SELF<T> {
        new_list: SELF<T> = new SELF<T>();

        it := self.head;

        while(!it.identifyWith(null)) {
            if(block_(it.item)) {
                new_list.add(it.item);
            }
            it = it.next;
        }

        return new_list;
    }

    def clone():SELF<T> {
        result:SELF<T> = new SELF<T>();
        it := self.head;
        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.next;
        }
        return result;
    }

    def subList(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it := self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count >= start && count < end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def deleteWithRange(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it := self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def fill(start:int, end:int, item:T):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it := self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            else {
                new_list.add(item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }
    def fill(item:T):SELF<T> {
        return self.fill(0,-1,item);
    }

    def reverse():SELF<T> {
        result:SELF<T> = new SELF<T>();

        it := self.tail;

        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.prev;
        }

        return result;
    }

    def shuffle():SELF<T> {
        result := self.clone();

        for(i:=0; i<50; i++) {
            n := System.rand() % self.number;
            m := System.rand() % self.number;

            item := result.items(n);
            item2 := result.items(m);

            result.replace(m, item);
            result.replace(n, item2);
        }

        return result;
    }
}

module MExtendedEqualableListImplementation
{
    def join(separator:String):String {
        result:String = new String("");
        it := self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            it = it.next;

            if(!it.identifyWith(null)) {
                result.append(separator);
            }
        }

        return result;
    }

    def join():String {
        return self.join("");
    }

    def count(item:T):int {
        result:int = 0;

        it := self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                result++;
            }

            it = it.next;
        }

        return result;
    }

    def indexOf(item:T):int {
        result:int = 0;
        it := self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }
            result++;
            it = it.next;
        }

        return -1;
    }
}

class List <T:Object>
{
    include MExtendedListImplementation;

/*
    def toArray(): Array<T> {
        result:Array<T> = new Array<T>();

        it := result.head;

        while(!it.identifyWith(null)) {
            item := it.item;

            result.add(item);

            it = it.next;
        }

        return result;

    }
*/

    def toSortableList():SortableList<ISortable> throws Exception {
        result:SortableList<ISortable>  = new SortableList<ISortable>();

        it := result.head;

        while(!it.identifyWith(null)) {
            item := it.item;

            if(item implements ISortable) {
                result.add(item);
            }

            it = it.next;
        }

        return result;
    }
}

class EqualableList<T:IEqualable>
{
    include MExtendedListImplementation;
    include MExtendedEqualableListImplementation;

    def toSortableList():SortableList<ISortable> throws Exception {
        result:SortableList<ISortable>  = new SortableList<ISortable>();

        it := result.head;

        while(!it.identifyWith(null)) {
            item := it.item;

            if(item implements ISortable) {
                result.add(item);
            }

            it = it.next;
        }

        return result;
    }
}

interface ISortable
{
    def equals(key:Self): bool;
    def toString(): String;
    def compare(item:Self): int;
}

class SortableList<T:ISortable>
{
    include MListImplementation;
    include MExtendedListImplementation;
    include MEqualableListImplementation;
    include MExtendedEqualableListImplementation;

    def quickSort(list:SortableList<T>, left:int, right:int) {
        l_hold:int = left;
        r_hold:int = right;

        pivot:T = list.items(left);
        pivot_num:int = left;

        while(left < right) {
            while((list.items(right).compare(pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                list.replace(left, list.items(right));
                left++;
            }

            while((list.items(left).compare(pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                list.replace(right, list.items(left));
                right--;
            }
        }

        list.replace(left, pivot);

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(list, left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(list, pivot_num+1, right);
        }
    }

    def mergeList(left:SortableList<T>, right:SortableList<T>):static SortableList<T> {
        list: SortableList<T> = new SortableList<T>();

        it:ListItem<T> = left.head;
        it2:ListItem<T> = right.head;

        while(true) {
            if(it.item.compare(it2.item) <= 0) {
                list.add(it.item);

                it = it.next;
            }
            else {
                list.add(it2.item);

                it2 = it2.next;
            }

            if(it.identifyWith(null)) {
                if(!it2.identifyWith(null)) {
                    while(!it2.identifyWith(null)) {
                        list.add(it2.item);

                        it2 = it2.next;
                    }
                }
                break;
            }
            elif(it2.identifyWith(null)) {
                if(!it.identifyWith(null)) {
                    while(!it.identifyWith(null)) {
                        list.add(it.item);

                        it = it.next;
                    }
                }
                break;
            }
        }

        return list;
    }

    def mergeSort():SortableList<T> {
        if(self.head.identifyWith(null)) {
            return self;
        }
        if(self.head.next.identifyWith(null)) {
            return self;
        }

        list1:SortableList<T> = new SortableList<T>();
        list2:SortableList<T> = new SortableList<T>();

        it:ListItem<T> = self.head;

        while(true) {
            list1.add(it.item);
            list2.add(it.next.item);

            if(it.next.next.identifyWith(null)) {
                break;
            }

            it = it.next.next;

            if(it.next.identifyWith(null)) {
                list1.add(it.item);
                break;
            }
        }

        return SortableList.mergeList(list1.mergeSort(), list2.mergeSort());
    }

    def sort(): SortableList<T> {
        list:SortableList<T> = self.mergeSort();
        self.setValue(list);
        return self;
    }
}
