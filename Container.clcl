
interface IEqualable
{
    def equals(right:Self): bool;
    def toString(): String;
    def clone(): Self;
}

interface ISortable
{
    def compare(item:Self): int;
    def equals(right:Self): bool;
    def toString(): String;
    def clone(): Self;
    def add(right:Self):Self;
}

interface IIteratorable
{
    def compare(item:Self): int;
    def equals(right:Self): bool;
    def toString(): String;
    def clone(): Self;
    def add(right:Self):Self;
    def next(): Self;
    def prev(): Self;
}

interface IHashKey
{
    def getHashKey(): uint;
    def equals(right:Self): bool;
    def toString(): String;
    def clone(): Self;
}

module MEqualableArray
{
    def toString():String {
        if(self.items.length == 0) {
            return "earray {}";
        }

        result:String = "earray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }

    def equals(right:T[]): bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.equals(right.toArray);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }

    def equals(right:Array<T>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            if(self.items.length != right.items.length) {
                return false;
            }

            for(i:int = 0; i<self.items.length; i++) {
                if(!self.items[i].equals(right.items[i])) {
                    return false;
                }
            }

            return true;
        }
    }

    def equals(right:EqualableArray<T>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            if(self.items.length != right.items.length) {
                return false;
            }

            for(i:int = 0; i<self.items.length; i++) {
                if(!self.items[i].equals(right.items[i])) {
                    return false;
                }
            }

            return true;
        }
    }
}

inherit Array<T:Object>
{
    def toString(): String {
        if(self.items.identifyWith(null)) {
            return "Null array";
        }
        else {
            result:String = "";
            result.append(self.items.length.toString);
            result.append(" length array of ");
            result.append(self.items.className());
            return result;
        }
    }
    def toEqualableArray():EqualableArray<IEqualable> throws Exception {
        result:EqualableArray<IEqualable>  = EqualableArray<IEqualable>(self.items.toAnonymous());

        for(i:int = 0; i<result.items.length; i++) {
            if(!(result.items[i] implements IEqualable)) {
                throw Exception("An elements doesn't implement IEqualable");
            }
        }

        return result;
    }

    def toSortableArray():SortableArray<ISortable> throws Exception {
        result:SortableArray<ISortable>  = SortableArray<ISortable>(self.items.toAnonymous());

        for(i:int = 0; i<result.items.length; i++) {
            if(!(result.items[i] implements ISortable)) {
                throw Exception("An elements doesn't implement ISortable");
            }
        }

        return result;
    }

    def toList(): List<T> {
        result:List<T> = List<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }
}

class EqualableArray <T:IEqualable>
{
    include MObjectBase;

    include MArray;
    include MEqualableArray;

    def toArray():Array<T> {
        return Array<T>(self.items.toAnonymous());
    }

    def toSortableArray():SortableArray<ISortable> throws Exception {
        result := SortableArray<ISortable>(self.items.toAnonymous());

        for(i:= 0; i<result.items.length; i++) {
            if(!(result.items[i] implements ISortable)) {
                throw Exception("An elements doesn't implement ISortable");
            }
        }

        return result;
    }

    def toEqualableList(): EqualableList<T> {
        result := EqualableList<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }
}

class SortableArray <T:ISortable>
{
    include MObjectBase;

    include MArray;
    include MEqualableArray;

    def equals(right:SortableArray<T>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            if(self.items.length != right.items.length) {
                return false;
            }

            for(i:int = 0; i<self.items.length; i++) {
                if(!self.items[i].equals(right.items[i])) {
                    return false;
                }
            }

            return true;
        }
    }

    def toArray():Array<T> {
        return Array<T>(self.items.toAnonymous());
    }

    def toEqualableArray():EqualableArray<T> {
        return EqualableArray<T>(self.items.toAnonymous());
    }

    def toSortableList(): SortableList<T> {
        result:SortableList<T> = SortableList<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }

    def quickSort(left:int, right:int, fun:lambda(T, T):int):SortableArray<T> {
        l_hold:int = left;
        r_hold:int = right;

        pivot:T = self.items[left];
        pivot_num:int = left;

        while(left < right) {
            while((fun(self.items[right], pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                self.items[left] = self.items[right];
                left++;
            }

            while((fun(self.items[left], pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                self.items[right] = self.items[left];
                right--;
            }
        }

        self.items[left] = pivot;

        pivot_num = left;

        left2:int = l_hold;
        right2:int = r_hold;

        if(left2 < pivot_num) {
            self.quickSort(left2, pivot_num-1, fun);
        }

        if(right2 > pivot_num) {
            self.quickSort(pivot_num+1, right2, fun);
        }

        return self;
    }

    def sort():SortableArray<T>  {
        return self.quickSort(0, self.length()-1, lambda(left:T, right:T):int { left.compare(right) });
    }
    def sort(fun:lambda(T,T):int):SortableArray<T>  {
        return self.quickSort(0, self.length()-1, fun);
    }

    def toString():String {
        if(self.items.length == 0) {
            return "sarray {}";
        }

        result:String = "sarray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }

    def compare(right:SortableArray<T>):int {
        if(self.length() == 0 && right.length() == 0) {
            return 0;
        }
        elif(self.length() == 0) {
            return -1;
        }
        elif(right.length() == 0) {
            return 1;
        }
        else {
            litem := items(0);
            ritem := right.items(0);

            if(litem == null && ritem == null) {
                return 0;
            }
            elif(litem == null) {
                return -1;
            }
            elif(ritem == null) {
                return 1;
            }
            else {
                return litem.compare(ritem);
            }
        }
    }
}

class ListItem <T:Object>
{
    include MObjectBase;

    item: T?;
    next: ListItem<T>?;
    prev: ListItem<T>?;

    def initialize() {
        self.item = null;
        self.next = null;
        self.prev = null;
    }

    def initialize(item:T?, prev:ListItem<T>?, next:ListItem<T>?) {
        self.item = item;
        self.prev = prev;
        self.next = next;
    }

    def clone(): ListItem<T> {
        result := ListItem<T>();

        result.item = self.item;
        result.prev = self.prev;
        result.next = self.next;

        return result;
    }
}

module MList
{
    head: ListItem<T>?;
    tail: ListItem<T>?;
    number: int;

    def initialize() {
        self.head = null;
        self.tail = null;
        self.number = 0;
    }

    def initialize(items:T[], num_elements:uint) {
        self.head = null;
        self.tail = null;
        self.number = 0;

        for(i:int = 0; i<num_elements; i++) {
            self.add(items[i]);
        }
    }

    def setValue(list:SELF<T>) {
        self.head = list.head;
        self.tail = list.tail;
        self.number = list.number;
    }

    def clone():SELF<T> {
        result:SELF<T> = SELF<T>();
        it :ListItem<T>? = self.head;
        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.next;
        }
        return result;
    }

    def length():int {
        return self.number;
    }

    def toString(): String {
        if(self.head.identifyWith(null)) {
            return "Null list";
        }
        else {
            result:String = "";
            result.append(self.number.toString);
            result.append(" length list of ");
            result.append(self.head.item.className());
            return result;
        }
    }

    def toArray(): Array<T> {
        result := Array<T>(self.number);

        it := self.head;

        n := 0;
        while(it != null) {
            result.put(n, it.item);

            it = it.next;
            n++;
        }

        return result;
    }

    def items(index:int):T? {
        if(index < 0) {
            index += self.number;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                return it.item
            }
            count++;

            it = it.next;
        }

        return null;
    }
    
    def clear(): SELF<T> {
        self.head = null;
        self.tail = null;
        self.number = 0;

        return self;
    }

    def add(item:T):SELF<T> {
        if(self.head.identifyWith(null)) {
            self.head = ListItem<T>(item, null, null);
            self.tail = self.head;
        }
        else {
            new_item:ListItem<T> = ListItem<T>(item, self.tail, null);

            self.tail.next = new_item;
            self.tail = new_item;
        }

        self.number++;

        return self;
    }

    def push(item:T):SELF<T> {
        if(self.head.identifyWith(null)) {
            self.head = ListItem<T>(item, null, null);
            self.tail = self.head;
        }
        else {
            new_item:ListItem<T> = ListItem<T>(item, self.tail, null);

            self.tail.next = new_item;
            self.tail = new_item;
        }

        self.number++;

        return self;
    }

    def add(right:SELF<T>):SELF<T> {
        result := self.clone();
        right.each {
            result.add(it);
        }
        return result;
    }

    def push(item:T):SELF<T> {
        return self.add(item);
    }

    def pop():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_tail :ListItem<T>? = self.tail.prev;
            item :T = self.tail.item;

            if(new_tail.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_tail.next = null;
                self.tail = new_tail;

                self.number--;

                return item;
            }
        }
    }

    def shift():T? {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_head :ListItem<T>? = self.head.next;
            item :T = self.head.item;

            if(new_head.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_head.prev = null;
                self.head = new_head;

                self.number--;

                return item;
            }
        }
    }

    def insert(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number + 1;
        }
        if(index < 0) {
            index = 0;
        }
        if(index > self.number) {
            index = self.number;
        }

        if(self.number == 0 || index == self.number) {
            self.add(item);
            return self;
        }

        if(index == 0) {
            new_item:ListItem<T> = ListItem<T>(item, null, self.head);
            self.head.prev = new_item;
            self.head = new_item;

            self.number++;
        }
        else {
            it:ListItem<T>? = self.head;

            i:int= 0;

            while(!it.identifyWith(null)) {
                if(i == index-1) {
                    new_item:ListItem<T> = ListItem<T>(item, it, it.next);
                    if(!it.next.identifyWith(null)) {
                        it.next.prev = new_item;
                    }
                    it.next = new_item;

                    self.number++;
                    break;
                }

                it = it.next;
                i++;
            }
        }

        return self;
    }

    def insert(index:int, list_:SELF<T>):SELF<T> {
        i := index;
        list_.each {
            self.insert(i, it);
            i++;
        }
        return self;
    }

    def deleteAt(index:int):SELF<T> {
        it:ListItem<T>? = self.head;
        it2:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                # one item is contained in list
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                # two item is contained in list
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                # other
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }

            count++;
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def each(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            try {
                block_(it.item);
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }
            it = it.next;
        }

        return self;
    }

    def eachReverse(block_:lambda(T)):SELF<T> {
        it:ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            try {
                block_(it.item);
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }
            it = it.prev;
        }

        return self;
    }

    def replace(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number;
        }
        if(index < 0) {
            index = 0;
        }
        if(index >= self.number) {
            index = self.number-1;
        }

        it:ListItem<T>? = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                it.item = item;
                break;
            }
            count++;

            it = it.next;
        }

        return self;
    }
    def sample():T {
        return self.items(System.rand() % self.number);
    }

    def append(list:SELF<T>):SELF<T> {
        list.each { |item:T| 
            self.add(item);
        }

        return self;
    }

    def deleteWithRange(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return SELF<T>();
        }

        new_list: SELF<T> = SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        self.setValue(new_list);

        return self;
    }

    def multiply(n:int):SELF<T> {
        result:SELF<T> = SELF<T>();

        for(i:int = 0; i<n; i++) {
            result.append(self);
        }

        return result;
    }

    def multiplyWithSelf(n:int):SELF<T> {
        result := multiply(n);
        setValue(result);
        return self;
    }

    def select(block_:lambda(T):bool):SELF<T> {
        new_list: SELF<T> = SELF<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            try {
                if(block_(it.item)) {
                    new_list.add(it.item);
                }
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }
            it = it.next;
        }

        return new_list;
    }

    def selectWithSelf(block_:lambda(T):bool):SELF<T> {
        result := select(block_);
        setValue(result);
        return self;
    }

    def subList(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return SELF<T>();
        }

        new_list: SELF<T> = SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count >= start && count < end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def subListWithSelf(start:int, end:int):SELF<T> {
        result := subList(start, end);
        self.setValue(result);
        return self;
    }

    def fill(start:int, end:int, item:T):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return SELF<T>();
        }

        new_list: SELF<T> = SELF<T>();

        it :ListItem<T>? = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            else {
                new_list.add(item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }
    def fill(item:T):SELF<T> {
        return self.fill(0,-1,item);
    }
    def fillWithSelf(start:int, end:int, item:T):SELF<T> {
        result := fill(start, end, item);
        setValue(result);
        return result;
    }
    def fillWithSelf(item:T):SELF<T> {
        result := fill(item);
        setValue(result);
        return self;
    }

    def reverse():SELF<T> {
        result:SELF<T> = SELF<T>();

        it :ListItem<T>? = self.tail;

        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.prev;
        }

        return result;
    }

    def reverseWithSelf():SELF<T> {
        result := reverse();
        self.setValue(result);
        return self;
    }

    def shuffle():SELF<T> {
        result:SELF<T> = self.clone();

        for(i:int =0; i<50; i++) {
            n :int = System.rand() % self.number;
            m :int = System.rand() % self.number;

            item :T = result.items(n);
            item2 :T = result.items(m);

            result.replace(m, item);
            result.replace(n, item2);
        }

        return result;
    }
    def shuffleWithSelf():SELF<T> {
        result := shuffle();
        self.setValue(result);
        return self;
    }

    def find(item:T): bool {
        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item == item) {
                return true;
            }
            it = it.next;
        }

        return false;
    }
}

module MEqualableList
{
    def equals(right:SELF<T>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            if(self.number != right.number) {
                return false;
            }
            for(i:int =0; i<self.number; i++) {
                if(!self.items(i).equals(right.items(i))) {
                    return false;
                }
            }

            return true;
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }

    def delete(item:T):SELF<T> {
        it:ListItem<T>? = self.head;
        it2:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                # one item is contained in list
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                # two item is contained in list
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                # other
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def indexOf(item:T):int {
        result:int = 0;

        it:ListItem<T>? = self.head;
        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }

            result++;

            it = it.next;
        }

        return -1;
    }
    def toString():String {
        if(self.number == 0) {
            return "elist {}";
        }

        result:String = "elist {";

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            result.append(",");

            it = it.next;
        }

        result.replace(-1, '}');

        return result;
    }
    def join(separator:String):String {
        result:String = String("");
        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            it = it.next;

            if(!it.identifyWith(null)) {
                result.append(separator);
            }
        }

        return result;
    }

    def join():String {
        return self.join("");
    }

    def count(item:T):int {
        result:int = 0;

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                result++;
            }

            it = it.next;
        }

        return result;
    }

    def indexOf(item:T):int {
        result:int = 0;
        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }
            result++;
            it = it.next;
        }

        return -1;
    }

    def uniq():SELF<T> {
        result := SELF<T>();

        it :ListItem<T>? = self.head;

        if(self.head == null) {
            return result;
        }

        item_before :T = self.head.item;

        while(it != null) {
            if(it == self.head) {
                result.add(it.item);
            }
            else {
                if(it.item != null && item_before != null && !it.item.equals(item_before)) {
                    result.add(it.item);
                }
            }
            item_before = it.item;
            it = it.next;
        }

        return result;
    }
}

class List <T:Object>
{
    include MObjectBase;

    include MList;

    def <R:Object> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = SELF<R>();

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            try {
                result.push(trans(it.item));
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }

            it = it.next;
        }

        return result;
    }
}

class EqualableList<T:IEqualable>
{
    include MObjectBase;

    include MList;
    include MEqualableList;

    def <R:IEqualable> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = SELF<R>();

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            try {
                result.push(trans(it.item));
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }

            it = it.next;
        }

        return result;
    }

    def toList():List<T> throws Exception {
        result:List<T> = List<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            item :T = it.item;

            result.add(item);

            it = it.next;
        }

        return result;
    }
}

class SortableList<T:ISortable>
{
    include MObjectBase;

    include MList;
    include MEqualableList;

    def clone():SortableList<T> {
        result := SortableList<T>();

        it := self.head;

        while(!it.identifyWith(null)) {
            item := it.item.clone();
            result.add(item);
            it = it.next;
        }

        return result;
    }

    def <R:ISortable> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = SELF<R>();

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            try {
                result.push(trans(it.item));
            } catch(e:Exception) {
                if(e.message.equals("break")) {
                    break;
                }
            }

            it = it.next;
        }

        return result;
    }

    def quickSort(list:SortableList<T>, left:int, right:int, fun:lambda(T, T):int) {
        l_hold:int = left;
        r_hold:int = right;

        pivot:T = list.items(left);
        pivot_num:int = left;

        while(left < right) {
            while((fun(list.items(right), pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                list.replace(left, list.items(right));
                left++;
            }

            while((fun(list.items(left), pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                list.replace(right, list.items(left));
                right--;
            }
        }

        list.replace(left, pivot);

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(list, left, pivot_num-1, fun);
        }

        if(right > pivot_num) {
            self.quickSort(list, pivot_num+1, right, fun);
        }
    }

    def mergeList(left:SortableList<T>, right:SortableList<T>, fun:lambda(T,T):int):static SortableList<T> {
        list: SortableList<T> = SortableList<T>();

        it:ListItem<T>? = left.head;

        it2:ListItem<T>? = right.head;

        while(true) {
            if(fun(it.item, it2.item) <= 0) {
                list.add(it.item);

                it = it.next;
            }
            else {
                list.add(it2.item);

                it2 = it2.next;
            }

            if(it.identifyWith(null)) {
                if(!it2.identifyWith(null)) {
                    while(!it2.identifyWith(null)) {
                        list.add(it2.item);

                        it2 = it2.next;
                    }
                }
                break;
            }
            elif(it2.identifyWith(null)) {
                if(!it.identifyWith(null)) {
                    while(!it.identifyWith(null)) {
                        list.add(it.item);

                        it = it.next;
                    }
                }
                break;
            }
        }

        return list;
    }

    def mergeSort(fun:lambda(T,T):int):SortableList<T> {
        if(self.head.identifyWith(null)) {
            return self;
        }
        if(self.head.next.identifyWith(null)) {
            return self;
        }

        list1:SortableList<T> = SortableList<T>();
        list2:SortableList<T> = SortableList<T>();

        it:ListItem<T> = self.head;

        while(true) {
            list1.add(it.item);
            list2.add(it.next.item);

            if(it.next.next.identifyWith(null)) {
                break;
            }

            it = it.next.next;

            if(it.next.identifyWith(null)) {
                list1.add(it.item);
                break;
            }
        }

        return SortableList<T>.mergeList(list1.mergeSort(fun), list2.mergeSort(fun), fun);
    }

    def sort():SortableList<T> {
        return sort(lambda(left:T, right:T):int { left.compare(right) });
    }

    def sort(fun:lambda(T, T):int): SortableList<T> {
        list:SortableList<T> = self.mergeSort(fun);
        self.setValue(list);
        return self;
    }
    def toString():String {
        if(self.number == 0) {
            return "slist {}";
        }

        result:String = "slist {";

        it:ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            result.append(",");

            it = it.next;
        }

        result.replace(-1, '}');

        return result;
    }

    def sum():T throws Exception {
        if(self.head == null || self.number == 0) {
            throw Exception("Null pointer exception");
        }

        result := items(0).clone();

        n := 0;

        self.each {
            if(n > 0) {
                result = result.add(it);
            }
            n++;
        }

        return result;
    }

    def compare(right:SortableList<T>):int {
        if(self.length() == 0 && right.length() == 0) {
            return 0;
        }
        elif(self.length() == 0) {
            return -1;
        }
        elif(right.length() == 0) {
            return 1;
        }
        else {
            litem := items(0);
            ritem := right.items(0);

            if(litem == null && ritem == null) {
                return 0;
            }
            elif(litem == null) {
                return -1;
            }
            elif(ritem == null) {
                return 1;
            }
            else {
                return litem.compare(ritem);
            }
        }
    }

    def toList():List<T> throws Exception {
        result:List<T> = List<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            item :T = it.item;

            result.add(item);

            it = it.next;
        }

        return result;
    }

    def toEqualableList():EqualableList<T> {
        result := EqualableList<T>();

        it :ListItem<T>? = self.head;

        while(!it.identifyWith(null)) {
            item :T = it.item;

            result.add(item);

            it = it.next;
        }

        return result;
    }
}

class HashItem <T:IHashKey, T2:IEqualable>
{
    include MObjectBase;

    key:T?;
    item:T2?;
    include MObjectBase;

    def initialize() {
        self.key = null;
        self.item = null;
    }

    def initialize(key:T, item:T2) {
        self.key = key;
        self.item = item;
    }

    def clone():HashItem<T,T2> {
        result := HashItem<T,T2>();

        if(!self.key.identifyWith(null) && !self.item.identifyWith(null)) {
            result.key = self.key.clone();
            result.item = self.item.clone();
        }

        return result;
    }
}

class Hash <T:IHashKey, T2:IEqualable>
{
    include MObjectBase;

    hashSizeDefault: static int;

    def initialize():static {
        Hash.hashSizeDefault = 128;
    }

    table: HashItem<T,T2>[]?;
    itemNumber: uint;
    tableSize: uint;

    def initialize() {
        self.table = HashItem<T,T2>[Hash.hashSizeDefault];
        self.tableSize = Hash.hashSizeDefault;
        self.itemNumber = 0;
    }

    def initialize(keys: T[], items:T2[], num_elements:uint) {
        hash_size:uint = num_elements * 2;

        self.table = HashItem<T,T2>[hash_size];
        self.tableSize = hash_size;
        self.itemNumber = num_elements;

        for(i:int =0; i<num_elements; i++) {
            self.put(keys[i], items[i]);
        }
    }
    
    def clone(): Hash<T,T2> {
        result := Hash<T,T2>();

        result.table = HashItem<T,T2>[self.tableSize];
        result.tableSize = self.tableSize;

        for(i:=0; i<self.table.length; i++) {
            if(!self.table[i].identifyWith(null)) {
                result.table[i] = self.table[i].clone();
            }
        }
        result.itemNumber = self.itemNumber;

        return result;
    }

    def equals(right:Hash<T,T2>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            if(self.itemNumber != right.itemNumber) {
                return false;
            }
            result:bool = true;
            self.each(closure(key:T, item:T2) {
                if(!self.containes(key, item)) {
                    result = false;
                    return;
                }
            });

            return result;
        }
    }

    def equals(right:WildCard):bool {
        return true;
    }

    def length(): int {
        return self.itemNumber;
    }
    
    def clear(): Hash<T,T2> {
        self.table = HashItem<T,T2>[Hash.hashSizeDefault];
        self.tableSize = Hash.hashSizeDefault;
        self.itemNumber = 0;

        return self;
    }

    def put(key:T, item:T2):Hash<T,T2> {
        if(self.itemNumber * 2 >= self.tableSize) {
            self.rehash();
        }

        hash_key:uint = key.getHashKey() % self.tableSize;
        n:uint = hash_key;

        while(true) {
            if(self.table[n].identifyWith(null)) {
                self.table[n] = HashItem<T, T2>(key,item);
                self.itemNumber++;
                break;
            }
            else {
                if(self.table[n].key.equals(key)) {
                    self.table[n].item = item;
                    break;
                }
            }

            n++;

            if(n == self.tableSize) {
                n = 0;
            }
            elif(n == hash_key) {
                self.rehash();
                self.put(key, item);
                break;
            }
        }

        return self;
    }

    def rehash() {
        table :HashItem<T,T2>[] = self.table;
        itemNumber :uint = self.itemNumber;

        self.tableSize *= 2;
        self.table = HashItem<T,T2>[self.tableSize];
        self.itemNumber = 0;

        for(i:int= 0; i<itemNumber; i++) {
            if(!table[i].identifyWith(null)) {
                self.put(self.table[i].key, self.table[i].item);
            }
        }
    }

    def get(key:T): T2? {
        hash_key:uint = key.getHashKey() % self.tableSize;

        n:uint = hash_key;

        while(true) {
            if(!self.table[n].identifyWith(null)) {
                if(self.table[n].key.equals(key)) {
                    return self.table[n].item;
                }
            }

            n++;

            if(n == self.tableSize) {
                n = 0;
            }
            elif(n == hash_key) {
                return null;
            }
        }
    }

    def getKey(item:T2):T? {
        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                if(self.table[i].item.equals(item)) {
                    return self.table[i].key;
                }
            }
        }

        return null;
    }

    def containes(key:T, item:T2):bool {
        return self.get(key).equals(item);
    }

    def each(block_:lambda(T,T2)):Hash<T,T2> {
        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                try {
                    block_(self.table[i].key, self.table[i].item);
                } catch(e:Exception) {
                    if(e.message.equals("break")) {
                        break;
                    }
                }
            }
        }

        return self;
    }

    def toString():String {
        if(self.itemNumber == 0) {
            return "hash {}";
        }

        result:String = "hash {";

        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                result.append(self.table[i].key.toString());
                result.append(":");
                result.append(self.table[i].item.toString());
                result.append(",");
            }
        }

        result.replace(-1, '}');

        return result;
    }

    def <R:ISortable> map(trans:lambda(T,T2):R): SortableList<R> {
        result:SortableList<R> = SortableList<R>();

        for(i:uint =0; i<self.tableSize; i++) {
            if(self.table[i] != null) {
                try {
                    result.add(trans(self.table[i].key, self.table[i].item));
                } catch(e:Exception) {
                    if(e.message.equals("break")) {
                        break;
                    }
                }
            }
        }

        return result;
    }

    def selectKeys(block_:lambda(T):bool):Hash<T,T2> {
        var result = Hash<T, T2>();

        for(i:uint =0; i<self.tableSize; i++) {
            if(self.table[i] != null) {
                try {
                    block_(self.table[i].key).if { result.put(self.table[i].key, self.table[i].item) }
                } catch(e:Exception) {
                    if(e.message.equals("break")) {
                        break;
                    }
                }
            }
        }

        return result;
    }

    def selectValues(block_:lambda(T2):bool):Hash<T,T2> {
        var result = Hash<T, T2>();

        for(i:uint =0; i<self.tableSize; i++) {
            if(self.table[i] != null) {
                try {
                    block_(self.table[i].item).if { result.put(self.table[i].key, self.table[i].item) }
                } catch(e:Exception) {
                    if(e.message.equals("break")) {
                        break;
                    }
                }
            }
        }

        return result;
    }
}

class Tuple1 <T:IEqualable>
{
    include MObjectBase;

    value1: T;

    def initialize() {}

    def initialize(value1:T) {
        self.value1 = value1;
    }

    def clone(): Tuple1<T> {
        result := Tuple1<T>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }

        return result;
    }

    def equals(right:Tuple1<T>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append("}");
    }
}

class Tuple2 <T:IEqualable, T2:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;

    def initialize() {}

    def initialize(value1:T, value2:T2) {
        self.value1 = value1;
        self.value2 = value2;
    }

    def clone(): Tuple2<T, T2> {
        result := Tuple2<T, T2>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }

        return result;
    }

    def equals(right:Tuple2<T,T2>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append("}");
    }
}

class Tuple3 <T:IEqualable, T2:IEqualable, T3:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
    }

    def clone(): Tuple3<T,T2,T3> {
        result := Tuple3<T,T2,T3>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }

        return result;
    }

    def equals(right:Tuple3<T,T2,T3>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append("}");
    }
}

class Tuple4 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
    }

    def equals(right:Tuple4<T,T2,T3,T4>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4);
        }
    }

    def clone(): Tuple4<T,T2,T3,T4> {
        result := Tuple4<T,T2,T3,T4>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }

        return result;
    }

    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append("}");
    }
}

class Tuple5 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
    }

    def clone(): Tuple5<T,T2,T3,T4,T5> {
        result := Tuple5<T,T2,T3,T4,T5>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }

        return result;
    }

    def equals(right:Tuple5<T,T2,T3,T4,T5>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5);
        }
    }
    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append("}");
    }
}

class Tuple6 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
    }

    def clone(): Tuple6<T,T2,T3,T4,T5,T6> {
        result := Tuple6<T,T2,T3,T4,T5,T6>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }
        if(!self.value6.identifyWith(null)) {
            result.value6 = self.value6.clone();
        }

        return result;
    }

    def equals(right:Tuple6<T,T2,T3,T4,T5,T6>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append("}");
    }
}

class Tuple7 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
    }

    def clone(): Tuple7<T,T2,T3,T4,T5,T6,T7> {
        result := Tuple7<T,T2,T3,T4,T5,T6,T7>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }
        if(!self.value6.identifyWith(null)) {
            result.value6 = self.value6.clone();
        }
        if(!self.value7.identifyWith(null)) {
            result.value7 = self.value7.clone();
        }

        return result;
    }

    def equals(right:Tuple7<T,T2,T3,T4,T5,T6,T7>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7);
        }
    }

    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append("}");
    }
}

class Tuple8 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
    }

    def clone(): Tuple8<T,T2,T3,T4,T5,T6,T7,T8> {
        result := Tuple8<T,T2,T3,T4,T5,T6,T7,T8>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }
        if(!self.value6.identifyWith(null)) {
            result.value6 = self.value6.clone();
        }
        if(!self.value7.identifyWith(null)) {
            result.value7 = self.value7.clone();
        }
        if(!self.value8.identifyWith(null)) {
            result.value8 = self.value8.clone();
        }

        return result;
    }

    def equals(right:Tuple8<T,T2,T3,T4,T5,T6,T7,T8>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8);
        }
    }
    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append("}");
    }
}

class Tuple9 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable, T9:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;
    value9: T9;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8, value9:T9) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
        self.value9 = value9;
    }

    def clone(): Tuple9<T,T2,T3,T4,T5,T6,T7,T8,T9> {
        result := Tuple9<T,T2,T3,T4,T5,T6,T7,T8,T9>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }
        if(!self.value6.identifyWith(null)) {
            result.value6 = self.value6.clone();
        }
        if(!self.value7.identifyWith(null)) {
            result.value7 = self.value7.clone();
        }
        if(!self.value8.identifyWith(null)) {
            result.value8 = self.value8.clone();
        }
        if(!self.value9.identifyWith(null)) {
            result.value9 = self.value9.clone();
        }

        return result;
    }

    def equals(right:Tuple9<T,T2,T3,T4,T5,T6,T7,T8,T9>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8) && self.value9.equals(right.value9);
        }
    }
    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append(",").append(self.value9.toString()).append("}");
    }
}

class Tuple10 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable, T9:IEqualable, T10:IEqualable>
{
    include MObjectBase;

    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;
    value9: T9;
    value10: T10;

    def initialize() {}

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8, value9:T9, value10:T10) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
        self.value9 = value9;
        self.value10 = value10;
    }

    def clone(): Tuple10<T,T2,T3,T4,T5,T6,T7,T8,T9,T10> {
        result := Tuple10<T,T2,T3,T4,T5,T6,T7,T8,T9,T10>();

        if(!self.value1.identifyWith(null)) {
            result.value1 = self.value1.clone();
        }
        if(!self.value2.identifyWith(null)) {
            result.value2 = self.value2.clone();
        }
        if(!self.value3.identifyWith(null)) {
            result.value3 = self.value3.clone();
        }
        if(!self.value4.identifyWith(null)) {
            result.value4 = self.value4.clone();
        }
        if(!self.value5.identifyWith(null)) {
            result.value5 = self.value5.clone();
        }
        if(!self.value6.identifyWith(null)) {
            result.value6 = self.value6.clone();
        }
        if(!self.value7.identifyWith(null)) {
            result.value7 = self.value7.clone();
        }
        if(!self.value8.identifyWith(null)) {
            result.value8 = self.value8.clone();
        }
        if(!self.value9.identifyWith(null)) {
            result.value9 = self.value9.clone();
        }
        if(!self.value10.identifyWith(null)) {
            result.value10 = self.value10.clone();
        }

        return result;
    }

    def equals(right:Tuple10<T,T2,T3,T4,T5,T6,T7,T8,T9,T10>):bool {
        if(right.is("WildCard")) {
            return true;
        }
        else {
            return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8) && self.value9.equals(right.value9) && self.value10.equals(right.value10);
        }
    }
    def equals(right:WildCard): bool {
        return true;
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append(",").append(self.value9.toString()).append(",").append(self.value10.toString()).append("}");
    }
}

module MInclude
{
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
}

inherit Byte 
{
    include MInclude;
}

inherit UByte 
{
    include MInclude;
}

inherit Short 
{
    include MInclude;
}

inherit UShort 
{
    include MInclude;
}

inherit Integer 
{
    include MInclude;
}

inherit UInteger 
{
    include MInclude;
}

inherit Long 
{
    include MInclude;
}

inherit ULong 
{
    include MInclude;
}

inherit Float 
{
    include MInclude;
}

inherit Double
{
    include MInclude;
}

inherit Pointer
{
    include MInclude;
}

inherit Char
{
    include MInclude;
}

inherit Bool
{
    include MInclude;
}

inherit Global
{
    def printf(str:String, params:List<Object>): static {
        str2 := sprintf(str, params);
        System.print(str2);
    }
    def printf(str:String, params:EqualableList<IEqualable>): static {
        str2 := sprintf(str, params);
        System.print(str2);
    }
    def printf(str:String, params:SortableList<ISortable>): static {
        str2 := sprintf(str, params);
        System.print(str2);
    }
    def printfToError(str:String, params:List<Object>): static {
        str2 := sprintf(str, params);
        System.printToError(str2);
    }
    def printfToError(str:String, params:EqualableList<IEqualable>): static {
        str2 := sprintf(str, params);
        System.printToError(str2);
    }
    def printfToError(str:String, params:SortableList<ISortable>): static {
        str2 := sprintf(str, params);
        System.printToError(str2);
    }
    def sprintf(str:String, params:List<Object>): static String {
        return System.sprintf(str, params.toArray());
    }
    def sprintf(str:String, params:EqualableList<IEqualable>): static String {
        return System.sprintf(str, params.toArray());
    }
    def sprintf(str:String, params:SortableList<ISortable>): static String {
        return System.sprintf(str, params.toArray());
    }
}

inherit String 
{
    def match(regex_:regex, group_strings:SortableList<String>?):  bool {
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        buffer:Buffer = self.toBuffer();

        offset:int = 0;
        regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

        ### match and no group strings ###
        if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
            return true;
        }
        ### group strings ###
        elif(regex_result > 1) {
            for(i:int = 1; i<regex_result; i++) {
                match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                group_strings.add(match_string);
            }

            return true;
        }
        ### no match ###
        else {
            return false;
        }
    }

    def sub(regex_:regex, replace:String, group_strings:SortableList<String>?):  String {
        result: String = String();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);
                result.append(replace);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);
                result.append(replace);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    group_strings.clear();
                }

                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    group_strings.add(match_string);
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### no match ###
            else {
                str:String = buffer.subBuffer(offset, -1).toString();
                result.append(str);
                break;
            }
        }

        return result;
    }

    def sub(regex_:regex, replace:String):  String {
        return self.sub(regex_, replace, SortableList<String>());
    }

    def sub(regex_:regex, group_strings:SortableList<String>?, replace_:lambda(String,SortableList<String>):String):  String 
    {
        result: String = String();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);

                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                replace_string:String = replace_(match_string, SortableList<String>());
                result.append(replace_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);

                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                if(!regex_.global) {
                    group_strings.clear();
                }

                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    group_strings.add(match_string);
                }

                replace_string:String = replace_(match_string, group_strings);
                result.append(replace_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### no match ###
            else {
                str:String = buffer.subBuffer(offset, -1).toString();
                result.append(str);
                break;
            }
        }

        return result;
    }

    def sub(regex_:regex, group_strings:SortableList<String>?, replace_:lambda(String):String):  String 
    {
        result: String = String();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);

                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                replace_string:String = replace_(match_string);
                result.append(replace_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.append(str);

                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                if(!regex_.global) {
                    group_strings.clear();
                }

                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    group_strings.add(match_string);
                }

                replace_string:String = replace_(match_string);
                result.append(replace_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = buffer.subBuffer(offset, -1).toString();
                    result.append(str);
                    break;
                }
            }
            ### no match ###
            else {
                str:String = buffer.subBuffer(offset, -1).toString();
                result.append(str);
                break;
            }
        }

        return result;
    }
    
    def sub(regex_:regex, replace_:lambda(String,SortableList<String>):String):  String {
        return self.sub(regex_, SortableList<String>()@group_strings, replace_);
    }

    def sub(regex_:regex, replace_:lambda(String):String): String
    {
        return self.sub(regex_, SortableList<String>()@group_strings, replace_);
    }

    def scan(regex_:regex): SortableList<String> {
        result: SortableList<String> = SortableList<String>();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();
                result.add(match_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();
                result.add(match_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    result.add(match_string);
                }
            }
            ### no match ###
            else {
                break;
            }
        }

        return result;
    }

    def scan(regex_:regex, block_:lambda(String,SortableList<String>):String):  SortableList<String> {
        result: SortableList<String> = SortableList<String>();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                group_strings: SortableList<String> = SortableList<String>();
                result.add(block_(match_string, group_strings));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                group_strings: SortableList<String> = SortableList<String>();
                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    group_strings.add(match_string);
                }

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                result.add(block_(match_string, group_strings));
            }
            ### no match ###
            else {
                break;
            }
        }

        return result;
    }
    def scan(regex_:regex, block_:lambda(String):String):  SortableList<String> {
        result: SortableList<String> = SortableList<String>();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(regex_, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                result.add(block_(match_string));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                match_string:String = buffer.subBuffer(ovec.start[0], ovec.end[0]).toString();

                group_strings: SortableList<String> = SortableList<String>();
                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    group_strings.add(match_string);
                }

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                result.add(block_(match_string));
            }
            ### no match ###
            else {
                break;
            }
        }

        return result;
    }

    def split(c:char):  SortableList<String> {
        result:SortableList<String> = SortableList<String>();
        offset:int = 0;
        str:String = "";

        for(i:=0; i<self.len; i++) {
            if(self.buffer[i] == c) {
                result.add(str);
                str = "";
            }
            else {
                str.append(self.buffer[i]);
            }
        }
        if(str.length() != 0) {
            result.add(str);
        }

        return result;
    }

    def split(separator:regex): SortableList<String> {
        result:SortableList<String> = SortableList<String>();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(separator, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.add(str);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.add(str);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                for(i:int = 1; i<regex_result; i++) {
                    str:String = buffer.subBuffer(ovec.start[i], ovec.end[i]).toString();
                    result.add(str);
                }
            }
            ### no match ###
            else {
                break;
            }
        }

        if(offset < buffer.length()) {
            str:String = buffer.subBuffer(offset, -1).toString();
            result.add(str);
        }

        return result;
    }

    def split(separator:regex, block_:lambda(String):String):  SortableList<String> {
        result:SortableList<String> = SortableList<String>();
        offset:int = 0;

        buffer:Buffer = self.toBuffer();
        ovec_max:int = 16;
        ovec:PcreOVec = PcreOVec(ovec_max);

        while(true) {
            regex_result:int = pcre_exec(separator, buffer, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();
                result.add(block_(str));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                str:String = buffer.subBuffer(offset, ovec.start[0]).toString();

                result.add(block_(str));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }
            }
            ### no match ###
            else {
                str:String = buffer.subBuffer(offset, -1).toString();
                result.add(block_(str));
                break;
            }
        }

        return result;
    }

    def count(regex_:regex): int {
        return scan(regex_).length();
    }
}

inherit Buffer 
{
/*
    def split(c:byte): SortableList<Buffer> {
        result := SortableList<Buffer>();

        head := self.head();
        p := self.head();

        buf_head := self.head();

        while(p - head < self.len) {
            if(p->byte == c) {
                buf := Buffer(buf_head, p-buf_head, false);
                result.add(buf);
                p++;

                buf_head = p;
            }
            else {
                p++;
            }
        }

        if(p-buf_head > 0) {
            buf := Buffer(buf_head, p-buf_head, false);
            result.add(buf);
        }

        return result;
    }
*/
    def split(c:byte): SortableList<Buffer> {
        result := SortableList<Buffer>();

        head := self.head();
        p := self.head();

        buf := b"";

        while(p - head < self.len) {
            if(p->byte == c) {
                result.add(buf);
                p++;

                buf = b"";
            }
            else {
                buf.append(p->byte);
                p++;
            }
        }

        if(buf.len > 0) {
            result.add(buf);
        }

        return result;
    }
}
