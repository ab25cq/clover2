include "Fundamental.clcl"

interface IEqualable
{
    def equals(right:Self): bool;
    def toString(): String;
}

interface ISortable
{
    def equals(right:Self): bool;
    def toString(): String;
    def compare(item:Self): int;
}

interface IHashKey
{
    def getHashKey(): uint;
    def equals(right:Self): bool;
    def toString(): String;
}

module MArrayImplement
{
    items:T[];

    def initialize() {
        self.items = null;
    }

    def initialize(items:T[]) {
        self.items = items;
    }

    def length():int {
        return self.items.length;
    }

    def items(index:int):T throws Exception {
        if(index < 0) {
            index += self.items.length;
        }

        return self.items[index];
    }

    def each(block_:lambda(T)) {
        for(i:int = 0; i<self.items.length; i++) {
            block_(self.items[i]);
        }
    }
}

module MEqualableArrayImplement
{
    def toString():String {
        if(self.items.length == 0) {
            return "earray {}";
        }

        result:String = "earray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }

    def equals(right:T[]): bool {
        return self.equals(right.toArray);
    }

    def equals(right:Array<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }

    def equals(right:EqualableArray<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }
}

class Array<T:Object>
{
    include MArrayImplement;

    def toEqualableArray():EqualableArray<IEqualable> throws Exception {
        result:EqualableArray<IEqualable>  = new EqualableArray<IEqualable>(self.items.toAnonymous());

        for(i:int = 0; i<result.items.length; i++) {
            if(!(result.items[i] implements IEqualable)) {
                throw new Exception("An elements doesn't implement IEqualable");
            }
        }

        return result;
    }

    def toSortableArray():SortableArray<ISortable> throws Exception {
        result:SortableArray<ISortable>  = new SortableArray<ISortable>(self.items.toAnonymous());

        for(i:int = 0; i<result.items.length; i++) {
            if(!(result.items[i] implements ISortable)) {
                throw new Exception("An elements doesn't implement ISortable");
            }
        }

        return result;
    }

    def toList(): List<T> {
        result:List<T> = new List<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }

    def toString(): String {
        if(self.items.identifyWith(null)) {
            return "Null array";
        }
        else {
            result:String = "";
            result.append(self.items.length.toString);
            result.append(" length array of ");
            result.append(self.items.className());
            return result;
        }
    }
}

class EqualableArray <T:IEqualable>
{
    include MArrayImplement;
    include MEqualableArrayImplement;

    def toArray():Array<T> {
        return new Array<T>(self.items.toAnonymous());
    }

    def toSortableArray():SortableArray<ISortable> throws Exception {
        result:SortableArray<ISortable>  = new SortableArray<ISortable>(self.items.toAnonymous());

        for(i:int = 0; i<result.items.length; i++) {
            if(!(result.items[i] implements ISortable)) {
                throw new Exception("An elements doesn't implement ISortable");
            }
        }

        return result;
    }

    def toEqualableList(): EqualableList<T> {
        result:EqualableList<T> = new EqualableList<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }
}

class SortableArray <T:ISortable>
{
    include MArrayImplement;
    include MEqualableArrayImplement;

    def equals(right:SortableArray<T>):bool {
        if(self.items.length != right.items.length) {
            return false;
        }

        for(i:int = 0; i<self.items.length; i++) {
            if(!self.items[i].equals(right.items[i])) {
                return false;
            }
        }

        return true;
    }

    def toArray():Array<T> {
        return new Array<T>(self.items.toAnonymous());
    }

    def toEqualableArray():EqualableArray<T> {
        return new EqualableArray<T>(self.items.toAnonymous());
    }

    def toSortableList(): SortableList<T> {
        result:SortableList<T> = new SortableList<T>();

        for(i:int = 0; i<self.items.length; i++) {
            result.add(self.items[i]);
        }

        return result;
    }

    def quickSort(left:int, right:int):SortableArray<T> {
        l_hold:int = left;
        r_hold:int = right;

        pivot:T = self.items[left];
        pivot_num:int = left;

        while(left < right) {
            while((self.items[right].compare(pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                self.items[left] = self.items[right];
                left++;
            }

            while((self.items[left].compare(pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                self.items[right] = self.items[left];
                right--;
            }
        }

        self.items[left] = pivot;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(pivot_num+1, right);

        }

        return self;
    }

    def sort():SortableArray<T>  {
        return self.quickSort(0, self.length()-1);
    }

    def toString():String {
        if(self.items.length == 0) {
            return "sarray {}";
        }

        result:String = "sarray {";

        for(i:int = 0; i<self.items.length; i++) {
            result.append(self.items[i].toString());
            result.append(",");
        }

        result.replace(-1, '}');

        return result;
    }
}

class ListItem <T:Object>
{
    item: T;
    next: ListItem<T>;
    prev: ListItem<T>;

    def initialize() {
        self.item = null;
        self.next = null;
        self.prev = null;
    }

    def initialize(item:T, prev:ListItem<T>, next:ListItem<T>) {
        self.item = item;
        self.prev = prev;
        self.next = next;
    }
}

module MListImplementation
{
    head: ListItem<T>;
    tail: ListItem<T>;
    number: int;

    def initialize() {
        self.head = null;
        self.tail = null;
        self.number = 0;
    }

    def initialize(items:T[], num_elements:uint) {
        self.head = null;
        self.tail = null;
        self.number = 0;

        for(i:int = 0; i<num_elements; i++) {
            self.add(items[i]);
        }
    }

    def setValue(list:SELF<T>) {
        self.head = list.head;
        self.tail = list.tail;
        self.number = list.number;
    }

    def length():int {
        return self.number;
    }

    def toString(): String {
        if(self.head.identifyWith(null)) {
            return "Null list";
        }
        else {
            result:String = "";
            result.append(self.number.toString);
            result.append(" length list of ");
            result.append(self.head.item.className());
            return result;
        }
    }

    def items(index:int):T {
        if(index < 0) {
            index += self.number;
        }

        it:ListItem<T> = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                return it.item
            }
            count++;

            it = it.next;
        }

        return null;
    }
    
    def clear(): SELF<T> {
        self.head = null;
        self.tail = null;
        self.number = 0;

        return self;
    }

    def add(item:T):SELF<T> {
        if(self.head.identifyWith(null)) {
            self.head = new ListItem<T>(item, null, null);
            self.tail = self.head;
        }
        else {
            new_item:ListItem<T> = new ListItem<T>(item, self.tail, null);

            self.tail.next = new_item;
            self.tail = new_item;
        }

        self.number++;

        return self;
    }

    def push(item:T):SELF<T> {
        return self.add(item);
    }

    def pop():T {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_tail :ListItem<T> = self.tail.prev;
            item :T = self.tail.item;

            if(new_tail.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_tail.next = null;
                self.tail = new_tail;

                self.number--;

                return item;
            }
        }
    }

    def shift():T {
        if(self.head.identifyWith(null)) {
            return null;
        }
        else {
            new_head :ListItem<T> = self.head.next;
            item :T = self.head.item;

            if(new_head.identifyWith(null)) {
                self.head = null;
                self.tail = null;
                self.number = 0;

                return item;
            }
            else {
                new_head.prev = null;
                self.head = new_head;

                self.number--;

                return item;
            }
        }
    }

    def insert(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number + 1;
        }
        if(index < 0) {
            index = 0;
        }
        if(index > self.number) {
            index = self.number;
        }

        if(self.number == 0 || index == self.number) {
            self.add(item);
            return self;
        }

        if(index == 0) {
            new_item:ListItem<T> = new ListItem<T>(item, null, self.head);
            self.head.prev = new_item;
            self.head = new_item;

            self.number++;
        }
        else {
            it:ListItem<T> = self.head;

            i:int= 0;

            while(!it.identifyWith(null)) {
                if(i == index-1) {
                    new_item:ListItem<T> = new ListItem<T>(item, it, it.next);
                    if(!it.next.identifyWith(null)) {
                        it.next.prev = new_item;
                    }
                    it.next = new_item;

                    self.number++;
                    break;
                }

                it = it.next;
                i++;
            }
        }

        return self;
    }

    def deleteAt(index:int):SELF<T> {
        it:ListItem<T> = self.head;
        it2:ListItem<T> = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                # one item is contained in list
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                # two item is contained in list
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                # other
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }

            count++;
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def each(block_:lambda(T)):SELF<T> {
        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.next;
        }

        return self;
    }

    def eachReverse(block_:lambda(T)):SELF<T> {
        it:ListItem<T> = self.tail;

        while(!it.identifyWith(null)) {
            block_(it.item);
            it = it.prev;
        }

        return self;
    }

    def replace(index:int, item:T):SELF<T> {
        if(index < 0) {
            index += self.number;
        }
        if(index < 0) {
            index = 0;
        }
        if(index >= self.number) {
            index = self.number-1;
        }

        it:ListItem<T> = self.head;

        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count == index) {
                it.item = item;
                break;
            }
            count++;

            it = it.next;
        }

        return self;
    }
    def sample():T {
        return self.items(System.rand() % self.number);
    }

    def append(list:SELF<T>):SELF<T> {
        list.each(closure(item:T) {
            self.add(item);
        });

        return self;
    }

    def multiply(n:int):SELF<T> {
        result:SELF<T> = new SELF<T>();

        for(i:int = 0; i<n; i++) {
            result.append(self);
        }

        return result;
    }

    def select(block_:lambda(T):bool):SELF<T> {
        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            if(block_(it.item)) {
                new_list.add(it.item);
            }
            it = it.next;
        }

        return new_list;
    }

    def clone():SELF<T> {
        result:SELF<T> = new SELF<T>();
        it :ListItem<T> = self.head;
        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.next;
        }
        return result;
    }

    def subList(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T> = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count >= start && count < end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def deleteWithRange(start:int, end:int):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T> = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }

    def fill(start:int, end:int, item:T):SELF<T> {
        if(start < 0) {
            start += self.number;
        }
        if(end < 0) {
            end += self.number + 1;
        }
        if(start < 0) {
            start = 0;
        }
        if(end > self.number) {
            end = self.number;
        }

        if(start >= end || start >= self.number || end < 0) {
            return new SELF<T>();
        }

        new_list: SELF<T> = new SELF<T>();

        it :ListItem<T> = self.head;
        count:int = 0;

        while(!it.identifyWith(null)) {
            if(count < start || count >= end) {
                new_list.add(it.item);
            }
            else {
                new_list.add(item);
            }
            count++;
            it = it.next;
        }

        return new_list;
    }
    def fill(item:T):SELF<T> {
        return self.fill(0,-1,item);
    }

    def reverse():SELF<T> {
        result:SELF<T> = new SELF<T>();

        it :ListItem<T> = self.tail;

        while(!it.identifyWith(null)) {
            result.add(it.item);
            it = it.prev;
        }

        return result;
    }

    def shuffle():SELF<T> {
        result:SELF<T> = self.clone();

        for(i:int =0; i<50; i++) {
            n :int = System.rand() % self.number;
            m :int = System.rand() % self.number;

            item :T = result.items(n);
            item2 :T = result.items(m);

            result.replace(m, item);
            result.replace(n, item2);
        }

        return result;
    }
}

module MEqualableListImplementation
{
    def equals(right:SELF<T>):bool {
        if(self.number != right.number) {
            return false;
        }
        for(i:int =0; i<self.number; i++) {
            if(!self.items(i).equals(right.items(i))) {
                return false;
            }
        }

        return true;
    }

    def delete(item:T):SELF<T> {
        it:ListItem<T> = self.head;
        it2:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                # one item is contained in list
                if(it.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = null;
                    self.tail = null;
                    self.number = 0;
                }
                # two item is contained in list
                elif(it2.identifyWith(self.head) && it.identifyWith(self.tail)) {
                    self.head = it2;
                    self.tail = it2;
                    it2.prev = null;
                    it2.next = null;
                    self.number = 1;
                }
                # other
                else {
                    if(it.identifyWith(self.head)) {
                        self.head = self.head.next;
                        self.head.prev = null;
                        self.number--;
                    }
                    elif(it.identifyWith(self.tail)) {
                        self.tail = self.tail.prev;
                        self.tail.next = null;
                        self.number--;
                    }
                    else {
                        it2.next = it.next;
                        it.next.prev = it2;
                        self.number--;
                    }
                }
                break;
            }
            
            it2 = it;
            it = it.next;
        }

        return self;
    }

    def indexOf(item:T):int {
        result:int = 0;

        it:ListItem<T> = self.head;
        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }

            result++;

            it = it.next;
        }

        return -1;
    }
    def toString():String {
        if(self.number == 0) {
            return "elist {}";
        }

        result:String = "elist {";

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            result.append(",");

            it = it.next;
        }

        result.replace(-1, '}');

        return result;
    }
    def join(separator:String):String {
        result:String = new String("");
        it :ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            it = it.next;

            if(!it.identifyWith(null)) {
                result.append(separator);
            }
        }

        return result;
    }

    def join():String {
        return self.join("");
    }

    def count(item:T):int {
        result:int = 0;

        it :ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                result++;
            }

            it = it.next;
        }

        return result;
    }

    def indexOf(item:T):int {
        result:int = 0;
        it :ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            if(it.item.equals(item)) {
                return result;
            }
            result++;
            it = it.next;
        }

        return -1;
    }
}

class List <T:Object>
{
    include MListImplementation;

    def <R:Object> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = new SELF<R>();

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.add(trans(it.item));

            it = it.next;
        }

        return result;
    }

    def toEqualableList():EqualableList<IEqualable> throws Exception {
        result:EqualableList<IEqualable>  = new EqualableList<IEqualable>();

        it :ListItem<IEqualable> = result.head;

        while(!it.identifyWith(null)) {
            item :IEqualable = it.item;

            if(item implements IEqualable) {
                result.add(item);
            }

            it = it.next;
        }

        return result;
    }

    def toSortableList():SortableList<ISortable> throws Exception {
        result:SortableList<ISortable>  = new SortableList<ISortable>();

        it :ListItem<ISortable>= result.head;

        while(!it.identifyWith(null)) {
            item :ISortable = it.item;

            if(item implements ISortable) {
                result.add(item);
            }

            it = it.next;
        }

        return result;
    }
}

class EqualableList<T:IEqualable>
{
    include MListImplementation;
    include MEqualableListImplementation;

    def <R:IEqualable> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = new SELF<R>();

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.add(trans(it.item));

            it = it.next;
        }

        return result;
    }

    def toSortableList():SortableList<ISortable> throws Exception {
        result:SortableList<ISortable>  = new SortableList<ISortable>();

        it :ListItem<ISortable> = result.head;

        while(!it.identifyWith(null)) {
            item :ISortable = it.item;

            if(item implements ISortable) {
                result.add(item);
            }

            it = it.next;
        }

        return result;
    }
}

class SortableList<T:ISortable>
{
    include MListImplementation;
    include MEqualableListImplementation;

    def <R:ISortable> map(trans:lambda(T):R): SELF<R> {
        result:SELF<R> = new SELF<R>();

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.add(trans(it.item));

            it = it.next;
        }

        return result;
    }

    def quickSort(list:SortableList<T>, left:int, right:int) {
        l_hold:int = left;
        r_hold:int = right;

        pivot:T = list.items(left);
        pivot_num:int = left;

        while(left < right) {
            while((list.items(right).compare(pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                list.replace(left, list.items(right));
                left++;
            }

            while((list.items(left).compare(pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                list.replace(right, list.items(left));
                right--;
            }
        }

        list.replace(left, pivot);

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(list, left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(list, pivot_num+1, right);
        }
    }

    def mergeList(left:SortableList<T>, right:SortableList<T>):static SortableList<T> {
        list: SortableList<T> = new SortableList<T>();

        it:ListItem<T> = left.head;
        it2:ListItem<T> = right.head;

        while(true) {
            if(it.item.compare(it2.item) <= 0) {
                list.add(it.item);

                it = it.next;
            }
            else {
                list.add(it2.item);

                it2 = it2.next;
            }

            if(it.identifyWith(null)) {
                if(!it2.identifyWith(null)) {
                    while(!it2.identifyWith(null)) {
                        list.add(it2.item);

                        it2 = it2.next;
                    }
                }
                break;
            }
            elif(it2.identifyWith(null)) {
                if(!it.identifyWith(null)) {
                    while(!it.identifyWith(null)) {
                        list.add(it.item);

                        it = it.next;
                    }
                }
                break;
            }
        }

        return list;
    }

    def mergeSort():SortableList<T> {
        if(self.head.identifyWith(null)) {
            return self;
        }
        if(self.head.next.identifyWith(null)) {
            return self;
        }

        list1:SortableList<T> = new SortableList<T>();
        list2:SortableList<T> = new SortableList<T>();

        it:ListItem<T> = self.head;

        while(true) {
            list1.add(it.item);
            list2.add(it.next.item);

            if(it.next.next.identifyWith(null)) {
                break;
            }

            it = it.next.next;

            if(it.next.identifyWith(null)) {
                list1.add(it.item);
                break;
            }
        }

        return SortableList<T>.mergeList(list1.mergeSort(), list2.mergeSort());
    }

    def sort(): SortableList<T> {
        list:SortableList<T> = self.mergeSort();
        self.setValue(list);
        return self;
    }
    def toString():String {
        if(self.number == 0) {
            return "slist {}";
        }

        result:String = "slist {";

        it:ListItem<T> = self.head;

        while(!it.identifyWith(null)) {
            result.append(it.item.toString());
            result.append(",");

            it = it.next;
        }

        result.replace(-1, '}');

        return result;
    }
}

class HashItem <T:IHashKey, T2:IEqualable>
{
    key:T;
    item:T2;

    def initialize() {
        self.key = null;
        self.item = null;
    }

    def initialize(key:T, item:T2) {
        self.key = key;
        self.item = item;
    }
}

class Hash <T:IHashKey, T2:IEqualable>
{
    hashSizeDefault: static int;

    def initialize():static {
        Hash.hashSizeDefault = 128;
    }

    table: HashItem<T,T2>[];
    itemNumber: uint;
    tableSize: uint;

    def initialize() {
        self.table = new HashItem<T,T2>[Hash.hashSizeDefault];
        self.tableSize = Hash.hashSizeDefault;
        self.itemNumber = 0;
    }

    def initialize(keys: T[], items:T2[], num_elements:uint) {
        hash_size:uint = num_elements * 2;

        self.table = new HashItem<T,T2>[hash_size];
        self.tableSize = hash_size;
        self.itemNumber = num_elements;

        for(i:int =0; i<num_elements; i++) {
            self.put(keys[i], items[i]);
        }
    }

    def equals(right:Hash<T,T2>):bool {
        if(self.itemNumber != right.itemNumber) {
            return false;
        }
        result:bool = true;
        self.each(closure(key:T, item:T2) {
            if(!self.containes(key, item)) {
                result = false;
                return;
            }
        });

        return result;
    }

    def length(): int {
        return self.itemNumber;
    }
    
    def clear(): Hash<T,T2> {
        self.table = new HashItem<T,T2>[Hash.hashSizeDefault];
        self.tableSize = Hash.hashSizeDefault;
        self.itemNumber = 0;

        return self;
    }

    def put(key:T, item:T2):Hash<T,T2> {
        if(self.itemNumber * 2 >= self.tableSize) {
            self.rehash();
        }

        hash_key:uint = key.getHashKey() % self.tableSize;
        n:uint = hash_key;

        while(true) {
            if(self.table[n].identifyWith(null)) {
                self.table[n] = new HashItem<T, T2>(key,item);
                self.itemNumber++;
                break;
            }
            else {
                if(self.table[n].key.equals(key)) {
                    self.table[n].item = item;
                    break;
                }
            }

            n++;

            if(n == self.tableSize) {
                n = 0;
            }
            elif(n == hash_key) {
                self.rehash();
                self.put(key, item);
                break;
            }
        }

        return self;
    }

    def rehash() {
        table :HashItem<T,T2>[] = self.table;
        itemNumber :uint = self.itemNumber;

        self.tableSize *= 2;
        self.table = new HashItem<T,T2>[self.tableSize];
        self.itemNumber = 0;

        for(i:int= 0; i<itemNumber; i++) {
            if(!table[i].identifyWith(null)) {
                self.put(table[i].key, table[i].item);
            }
        }
    }

    def get(key:T): T2 {
        hash_key:uint = key.getHashKey() % self.tableSize;

        n:uint = hash_key;

        while(true) {
            if(!self.table[n].identifyWith(null)) {
                if(self.table[n].key.equals(key)) {
                    return self.table[n].item;
                }
            }

            n++;

            if(n == self.tableSize) {
                n = 0;
            }
            elif(n == hash_key) {
                return null;
            }
        }
    }

    def getKey(item:T2):T {
        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                if(self.table[i].item.equals(item)) {
                    return self.table[i].key;
                }
            }
        }

        return null;
    }

    def containes(key:T, item:T2):bool {
        return self.get(key).equals(item);
    }

    def each(block_:lambda(T,T2)):Hash<T,T2> {
        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                block_(self.table[i].key, self.table[i].item);
            }
        }

        return self;
    }

    def toString():String {
        if(self.itemNumber == 0) {
            return "hash {}";
        }

        result:String = "hash {";

        for(i:uint =0; i<self.tableSize; i++) {
            if(!self.table[i].identifyWith(null)) {
                result.append(self.table[i].key.toString());
                result.append(":");
                result.append(self.table[i].item.toString());
                result.append(",");
            }
        }

        result.replace(-1, '}');

        return result;
    }
}

class Tuple1 <T:IEqualable>
{
    value1: T;

    def initialize(value1:T) {
        self.value1 = value1;
    }

    def equals(right:Tuple1<T>):bool {
        return self.value1.equals(right.value1);
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append("}");
    }
}

class Tuple2 <T:IEqualable, T2:IEqualable>
{
    value1: T;
    value2: T2;

    def initialize(value1:T, value2:T2) {
        self.value1 = value1;
        self.value2 = value2;
    }

    def equals(right:Tuple2<T,T2>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2);
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append("}");
    }
}

class Tuple3 <T:IEqualable, T2:IEqualable, T3:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;

    def initialize(value1:T, value2:T2, value3:T3) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
    }

    def equals(right:Tuple3<T,T2,T3>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3);
    }

    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append("}");
    }
}

class Tuple4 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
    }

    def equals(right:Tuple4<T,T2,T3,T4>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append("}");
    }
}

class Tuple5 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
    }

    def equals(right:Tuple5<T,T2,T3,T4,T5>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append("}");
    }
}

class Tuple6 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
    }

    def equals(right:Tuple6<T,T2,T3,T4,T5,T6>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append("}");
    }
}

class Tuple7 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
    }

    def equals(right:Tuple7<T,T2,T3,T4,T5,T6,T7>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append("}");
    }
}

class Tuple8 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
    }

    def equals(right:Tuple8<T,T2,T3,T4,T5,T6,T7,T8>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append("}");
    }
}

class Tuple9 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable, T9:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;
    value9: T9;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8, value9:T9) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
        self.value9 = value9;
    }

    def equals(right:Tuple9<T,T2,T3,T4,T5,T6,T7,T8,T9>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8) && self.value9.equals(right.value9);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append(",").append(self.value9.toString()).append("}");
    }
}

class Tuple10 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable, T9:IEqualable, T10:IEqualable>
{
    value1: T;
    value2: T2;
    value3: T3;
    value4: T4;
    value5: T5;
    value6: T6;
    value7: T7;
    value8: T8;
    value9: T9;
    value10: T10;

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8, value9:T9, value10:T10) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
        self.value9 = value9;
        self.value10 = value10;
    }

    def equals(right:Tuple10<T,T2,T3,T4,T5,T6,T7,T8,T9,T10>):bool {
        return self.value1.equals(right.value1) && self.value2.equals(right.value2) && self.value3.equals(right.value3) && self.value4.equals(right.value4) && self.value5.equals(right.value5) && self.value6.equals(right.value6) && self.value7.equals(right.value7) && self.value8.equals(right.value8) && self.value9.equals(right.value9) && self.value10.equals(right.value10);
    }
    def toString():String {
        return "tuple {".append(self.value1.toString()).append(",").append(self.value2.toString()).append(",").append(self.value3.toString()).append(",").append(self.value4.toString()).append(",").append(self.value5.toString()).append(",").append(self.value6.toString()).append(",").append(self.value7.toString()).append(",").append(self.value8.toString()).append(",").append(self.value9.toString()).append(",").append(self.value10.toString()).append("}");
    }
}

module MInclude
{
    def include(list:EqualableList<SELF>):bool {
        return list.indexOf(self) != -1;
    }
}

class Byte 
{
    include MInclude;
}

class UByte 
{
    include MInclude;
}

class Short 
{
    include MInclude;
}

class UShort 
{
    include MInclude;
}

class Integer 
{
    include MInclude;
}

class UInteger 
{
    include MInclude;
}

class Long 
{
    include MInclude;
}

class ULong 
{
    include MInclude;
}

class Float 
{
    include MInclude;
}

class Double
{
    include MInclude;
}

class Pointer
{
    include MInclude;
}

class Char
{
    include MInclude;
}

class Bool
{
    include MInclude;
}

