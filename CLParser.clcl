
class CLNodeType
{
    className:String;
    genericsTypes:CLNodeType[];
    numGenericsTypes: int;

/*
    array:bool;
    nullabyle:bool;
    blockType:CLBlockType;
*/

    def initialize(class_name:String) {
        self.className = class_name;
        self.genericsTypes = new CLNodeType[CLParser.GENERICS_TYPES_MAX]();
        self.numGenericsTypes = 0;
    }

    def toString(): String {
        result := "";
        result.append(self.className);

        if(self.numGenericsTypes > 0) {
            result.append("<");

            for(i := 0; i<self.numGenericsTypes; i++) {
                result.append(self.genericsTypes[i].toString());
                if(i != self.numGenericsTypes-1) {
                    result.append(",");
                }
            }

            result.append(">");
        }

        result;
    }

    def show() {
        println("Type is \{toString()}");
    }
}

interface CLNodeTree
{
    def kind():int;
    def kind(value:int);

    def left(value:CLNodeTree);
    def left():CLNodeTree;

    def right(value:CLNodeTree);
    def right():CLNodeTree;

    def middle(value:CLNodeTree);
    def middle():CLNodeTree;

    def sourceName():String;
    def sourceName(sname:String);

    def sourceLine():int;
    def sourceLine(line:int);

    def type():CLNodeType;
    def type(type: CLNodeType);

    def show();

    enum {
        IntType, PlusExp, StringType
    }
}

class CLNodeTreeBase
{
    kind:int;

    left:CLNodeTree;
    right:CLNodeTree;
    middle:CLNodeTree;

    sourceName:String;
    sourceLine:int;

    type:CLNodeType;

    def initialize() {}
}

class CLNodeTreeInt
{
    base:delegate CLNodeTreeBase;
    value:int;

    def initialize(value:int, sname:String, sline:int) {
        self.base = new CLNodeTreeBase();

        kind(CLNodeTree.IntType);

        sourceName(sname);
        sourceLine(sline);

        base.type(new CLNodeType("int"));

        self.value = value;
    }

    def show() {
        println("int value \{self.value}");
    }
}

class CLNodeTreePlus
{
    base:delegate CLNodeTreeBase;

    def initialize(left:CLNodeTree, right:CLNodeTree, sname:String, sline:int) {
        self.base = new CLNodeTreeBase();

        kind(CLNodeTree.PlusExp);

        left(left);
        right(right);

        base.type(left().type());

        sourceName(sname);
        sourceLine(sline);
    }

    def show() {
        println("plus tree");
        println("<-- left -->");
        if(!left().identifyWith(null)) {
            left().show();
        }
        else {
            println("null");
        }

        println("<-- right -->");
        if(!right().identifyWith(null)) {
            right().show();
        }
        else {
            println("null");
        }
    }
}

class CLNodeTreeString
{
    base:delegate CLNodeTreeBase;
    value:String;

    def initialize(value:String, sname:String, sline:int) {
        self.base = new CLNodeTreeBase();

        kind(CLNodeTree.StringType);

        sourceName(sname);
        sourceLine(sline);

        base.type(new CLNodeType("String"));

        self.value = value;
    }

    def show() {
        println("string value \{self.value}");
    }
}

class CLParser
{
    sourceBuffer:Buffer;
    p:pointer;
    type:CLNodeType;

    GENERICS_TYPES_MAX:static int;
    PARAMS_MAX:static int;

    sourceName:String;
    sourceLine:int;

    def initialize(): native static;

    def initialize(sname:String) {
        self.sourceName = sname;
    }

    def skipSpacesAndLF() {
        while(self.p->byte == ' ' || self.p->byte == '\t' || self.p->byte == '\n') {
            self.p++;
        }
    }

    def expressionNode():CLNodeTree? {
        result:CLNodeTree? = null;

        if(self.p->byte >= '0' && self.p->byte <= '9') {
            value:int = 0;
            while(self.p->byte >= '0' && self.p->byte <= '9') {
                value = value * 10 + self.p->byte - '0';
                self.p++;
            }
            skipSpacesAndLF();

            result = new CLNodeTreeInt(value, self.sourceName, self.sourceLine);
        }
        elif(self.p->byte == '"') {
            self.p++;
            str:String = "";

            while(true) {
                if(self.p->byte == '"') {
                    self.p++;
                    skipSpacesAndLF();
                    break;
                }
                elif(self.p->byte == '\0') {
                    throw new Exception("Unexpected the source end");
                }
                elif(self.p->byte == '\\') {
                    self.p++;

                    when(self.p->byte.to_char) {
                        case 'n': {
                            self.p++;
                            str.append("\n");
                        }
                        case 'r': {
                            self.p++;
                            str.append("\r");
                        }
                        case '0': {
                            self.p++;
                            str.append("\0");
                        }
                        case '{': {
                            expression();

                            if(self.p->byte == '}') {
                                self.p++;
                            }
                            else {
                                throw new Exception("require }");
                            }
                        }
                        case 't': {
                            self.p++;
                            str.append("\t");
                        }
                        case 'a': {
                            self.p++;
                            str.append("\a");
                        }
                        case '\\': {
                            self.p++;
                            str.append("\\");
                        }
                    }
                }
                else {
                    str.append(self.p->byte.to_char);
                    self.p++;
                }
            }

            result = new CLNodeTreeString(str, self.sourceName, self.sourceLine);
        }

        return result;
    }

    def plusAndMinus(): CLNodeTree? throws Exception {
        result:CLNodeTree? = expressionNode();

        while(true) {
            if(self.p->byte == '+') {
                self.p++;
                skipSpacesAndLF();

                right := expressionNode();

                if(right.identifyWith(null)) {
                    throw new Exception("\{self.sourceName} \{self.sourceLine}: Right expression is null.");
                }

                result = new CLNodeTreePlus(result, right, self.sourceName, self.sourceLine);
            }
            else {
                break;
            }
        }

        return result;
    }

    def expression(): CLNodeTree? throws Exception {
        result :CLNodeTree? = plusAndMinus();

        return result;
    }

    def parse() {
        self.sourceBuffer = File.read(self.sourceName);
        self.sourceBuffer.append(0y);

        self.p = self.sourceBuffer.buffer;
        self.sourceLine = 1;

        while(self.p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(!exp.identifyWith(null)) {
                exp.show();
                exp.type().show();
            }
        }
    }
}
