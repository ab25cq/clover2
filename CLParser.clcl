
class CLNodeType
{
    className:String;
    genericsTypes:CLNodeType[];
    numGenericsTypes: int;

/*
    array:bool;
    nullabyle:bool;
    blockType:CLBlockType;
*/

    def initialize(class_name:String) {
        className = class_name;
        genericsTypes = new CLNodeType[CLParser.GENERICS_TYPES_MAX]();
        numGenericsTypes = 0;
    }

    def toString(): String {
        result := "";
        result.append(className);

        if(numGenericsTypes > 0) {
            result.append("<");

            for(i := 0; i<numGenericsTypes; i++) {
                result.append(genericsTypes[i].toString());
                if(i != numGenericsTypes-1) {
                    result.append(",");
                }
            }

            result.append(">");
        }

        result;
    }

    def show() {
        println("Type is \{toString()}");
    }
}

interface CLNodeTree
{
    def kind():int;
    def kind(value:int);

    def left(value:CLNodeTree);
    def left():CLNodeTree;

    def right(value:CLNodeTree);
    def right():CLNodeTree;

    def middle(value:CLNodeTree);
    def middle():CLNodeTree;

    def sourceName():String;
    def sourceName(sname:String);

    def sourceLine():int;
    def sourceLine(line:int);

    def type():CLNodeType;
    def type(type: CLNodeType);

    def show();

    enum {
        IntType, PlusExp, MinusExp, StringType
    }
}

class CLNodeTreeBase
{
    kind:int;
    left:CLNodeTree;
    right:CLNodeTree;
    middle:CLNodeTree;

    sourceName:String;
    sourceLine:int;

    type:CLNodeType;
}

class CLNodeTreeInt
{
    base:delegate CLNodeTreeBase;
    value:int;

    def initialize(value:int, sname:String, sline:int) {
        base = CLNodeTreeBase();

        kind(CLNodeTree.IntType);

        sourceName(sname);
        sourceLine(sline);

        base.type(new CLNodeType("int"));

        value = value;
    }

    def show() {
        println("int value \{value}");
    }
}

class CLNodeTreePlus
{
    base:delegate CLNodeTreeBase;

    def initialize(left:CLNodeTree, right:CLNodeTree, sname:String, sline:int) {
        base = CLNodeTreeBase();

        kind(CLNodeTree.PlusExp);

        self.left(left);
        self.right(right);

        self.base.type(self.left().type());

        sourceName(sname);
        sourceLine(sline);
    }

    def show() {
        println("plus tree");
        println("<-- left -->");
        if(!left().identifyWith(null)) {
            left().show();
        }
        else {
            println("null");
        }

        println("<-- right -->");
        if(!right().identifyWith(null)) {
            right().show();
        }
        else {
            println("null");
        }
    }
}

class CLNodeTreeMinus
{
    base:delegate CLNodeTreeBase;

    def initialize(left:CLNodeTree, right:CLNodeTree, sname:String, sline:int) 
    {
        base = CLNodeTreeBase();

        kind(CLNodeTree.MinusExp);

        self.left(left);
        self.right(right);

        self.base.type(self.left().type());

        sourceName(sname);
        sourceLine(sline);
    }

    def show() {
        println("minus tree");
        println("<-- left -->");
        if(!left().identifyWith(null)) {
            left().show();
        }
        else {
            println("null");
        }

        println("<-- right -->");
        if(!right().identifyWith(null)) {
            right().show();
        }
        else {
            println("null");
        }
    }
}

class CLNodeTreeString
{
    base:delegate CLNodeTreeBase;
    value:String;

    def initialize(str:String, sname:String, sline:int) {
        base = CLNodeTreeBase();

        kind(CLNodeTree.StringType);

        sourceName(sname);
        sourceLine(sline);

        base.type(CLNodeType("String"));

        value = str;
    }

    def show() {
        println("string value \{value}");
    }
}

class CLParser
{
    sourceBuffer:Buffer;
    p:pointer;
    type:CLNodeType;

    GENERICS_TYPES_MAX:static int;
    PARAMS_MAX:static int;

    sourceName:String;
    sourceLine:int;

    def initialize(): native static;

    def initialize(sname:String) {
        sourceName = sname;
    }

    def skipSpacesAndLF() {
        while(p->byte == ' ' || p->byte == '\t' || p->byte == '\n') {
            p++;
        }
    }

    def expressionNode():CLNodeTree? {
        result:CLNodeTree? = null;

        if(p->byte >= '0' && p->byte <= '9') {
            value:int = 0;
            while(p->byte >= '0' && p->byte <= '9') {
                value = value * 10 + p->byte - '0';
                p++;
            }
            skipSpacesAndLF();

            result = CLNodeTreeInt(value, sourceName, sourceLine);
        }
        elif(p->byte == '"') {
            p++;
            str:String = "";

            while(true) {
                if(p->byte == '"') {
                    p++;
                    skipSpacesAndLF();
                    break;
                }
                elif(p->byte == '\0') {
                    throw new Exception("Unexpected the source end");
                }
                elif(p->byte == '\\') {
                    p++;

                    when(p->byte.to_char) {
                        case('n') {
                            p++;
                            str.append("\n");
                        }
                        case('r') {
                            p++;
                            str.append("\r");
                        }
                        case('0') {
                            p++;
                            str.append("\0");
                        }
                        case('{') {
                            expression();

                            if(p->byte == '}') {
                                p++;
                            }
                            else {
                                throw new Exception("require }");
                            }
                        }
                        case('t') {
                            p++;
                            str.append("\t");
                        }
                        case('a') {
                            p++;
                            str.append("\a");
                        }
                        case('\\') {
                            p++;
                            str.append("\\");
                        }
                    }
                }
                else {
                    str.append(p->byte.to_char);
                    p++;
                }
            }

            result = CLNodeTreeString(str, sourceName, sourceLine);
        }

        return result;
    }

    def plusAndMinus(): CLNodeTree? throws Exception {
        result:CLNodeTree? = expressionNode();

        while(true) {
            if(p->byte == '+') {
                p++;
                skipSpacesAndLF();

                right := expressionNode();

                if(right.identifyWith(null)) {
                    throw new Exception("\{sourceName} \{sourceLine}: Right expression is null.");
                }

                result = CLNodeTreePlus(result, right, sourceName, sourceLine);
            }
            elif(p->byte == '-') {
                p++;
                skipSpacesAndLF();

                right := expressionNode();

                if(right.identifyWith(null)) {
                    throw new Exception("\{sourceName} \{sourceLine}: Right expression is null.");
                }

                result = CLNodeTreeMinus(result, right, sourceName, sourceLine);
            }
            else {
                break;
            }
        }

        return result;
    }

    def expression(): CLNodeTree? throws Exception {
        result :CLNodeTree? = plusAndMinus();

        return result;
    }

    def parse() {
        sourceBuffer = File.read(sourceName);
        sourceBuffer.append(0y);

        p = sourceBuffer.buffer;
        sourceLine = 1;

        while(p->byte != '\0') {
            exp:CLNodeTree? = expression();

            if(!exp.identifyWith(null)) {
                exp.show();
                exp.type().show();
            }
        }
    }
}
