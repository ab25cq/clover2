
/*
class CLNodeType
{
    className:String;

    genericsTypes:CLNodeType[];

    array:bpool;
    nullabyle:bool;
    blockType:CLBlockType;

    def initialize(class_name:String) {
        self.className = class_name;
        self.genericsTypes = new CLNodeType[CLParser.GENERICS_TYPES_MAX]();
    }
}

interface CLNodeTree
{
    def type():int;
    def setType(value:int);

    def source
}

class CLNodeTreeBase
{
    type:int;

    left:CLNodeTree;
    right:CLNodeTree;
    middle:CLNodeTree;

    sourceName:String;
    sourceLine:int;
}

class CLNodeTreeInt
{
    parent:delegate CLNodeTreeBase;
    value:int;

    def initialize(value:int, left:CLNodeTree, right:CLNodeTree, middle:CLNodeTree) {
    }
}

class CLParser
{
    sourceBuffer:Buffer;
    p:pointer;

    GENERICS_TYPES_MAX:static int;
    PARAMS_MAX:static int;

    def initialize(): native static;

    def initialize(sname:String) {
        self.sourceBuffer = File.read(sname);
    }

    def expressionNode(node:CLNodeTree):bool {
        if(self.p->byte >= '0' && self.p->byte <= '9') {
            node = new NodeTreeInt
        }

        return true;
    }

    def expresion(node:CLNodeTree):bool {
    }

    def parse() {
        self.sourceBuffer.append(0y);
        self.p = self.sourceBuffer.buffer;

        while(self.p->byte != '\0') {
            printf("p %d\n", array { self.p->byte });
            self.p++;
        }
    }

    def expression() {
    }
}
*/
