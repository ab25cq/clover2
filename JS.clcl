class System:js
{
    typedef Any Anonymous;

    def println(obj:Anonymous):static native {
        console.log(obj);
    }
    def println(str:String):static native {
        console.log(str);
    }
    def print(str:String):static native {
        process.stdout.write(str);
    }
    def println(num:Number):static native {
        console.log(num);
    }
    def typeOf(obj:Anonymous): static native String {
        return typeOf(obj);
    }
    def typeOfNativeObject(obj:Anonymous): static native bool {
        return typeOfNativeObject(obj);
    }
    def assert(exp:bool): static native {
        console.assert(exp);
    }

    def alert(obj:Any): static native {
        alert(obj);
    }

    var document:static Document;

    def initialize():native static {
        if(typeof document !== 'undefined') {
            System.document = document;
        }
    }
}

class Clover:js
{
    def test(str:String, exp:bool):static native {
        process.stdout.write(str + "...");
        console.log(exp);
        console.assert(exp);
    }
}

interface IEqualable:js
{
    def equals(right:Self): pure_native bool;
    def toString(): native String;
    def clone(): pure_native Self;
}

interface ISortable:js
{
    def equals(right:Self): pure_native bool;
    def compare(item:Self): pure_native Number;
    def toString(): native String;
    def clone(): pure_native Self;
    def add(right:Self):pure_native Self;
}

interface IIteratorable:js
{
    def equals(right:Self): pure_native bool;
    def compare(item:Self): pure_native Number;
    def toString(): native String;
    def clone(): pure_native Self;
    def add(right:Self):pure_native Self;
    def next(): Self;
    def prev(): Self;
}

interface IHashKey:js
{
    def equals(right:Self): pure_native bool;
    def toString(): native String;
    def clone(): pure_native Self;
}

class Array<T:ISortable>:native js
{
    var length: Number;

    def constructor(num:Number):pure_native Array<T>;
    def items(n:Number): native T {
        return this[n];
    }
    def slice(n:Number): pure_native Array<T>;
    def slice(n:Number, n2:Number): pure_native Array<T>;
    def includes(item:T):native bool {
        for(var i=0; i<this.length; i++) {
            if(this[i].equals(item)) {
                return true;
            }
        }

        return false;
    }
    def copyWithin(index:Number, start:Number=0): native Array<T> {
        var end = this.length;
        this.copyWithin(index, start, end);

        return this;
    }
    def copyWithin(index:Number, start:Number, end:Number): native Array<T> {
        this.copyWithin(index, start, end);

        return this;
    }
    def fill(data:T, start:Number=0): native Array<T> {
        var end = this.length;
        this.fill(data, start, end);

        return this;
    }
    def fill(data:T, start:Number, end:Number): native Array<T> {
        this.fill(data, start, end);

        return this;
    }

    def equals(array_:Array<T>): pure_native bool {
        if(this.length == array_.length) {
            for(var i=0; i<this.length; i++) {
                if(!this[i].equals(array_[i])) {
                    return false;
                }
            }

            return true;
        }
        else {
            return false;
        }
    }

    def pop(): pure_native T;
    def push(item:T): pure_native Number;
    def reverse(): pure_native Array<T>;
    def shift(): pure_native T;

    def replace(n:Number, item:T): native T {
        var item = this[n];
        this[n] = item;
        return item;
    }

    def toString(): native String {
        var result = "Array {";

        for(var i= 0; i<this.length; i++) {
            result = result + this[i].toString__();

            if(i < this.length-1) {
                result = result + ",";
            }
        }
        
        result = result + "}";

        return result;
    }

    def quickSort(left:Number, right:Number, fun:lambda(T, T):Number):pure_native Array<T> {
        var l_hold = left;
        var r_hold = right;

        var pivot = this[left];
        var pivot_num = left;

        while(left < right) {
            while((fun(this[right], pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                this[left] = this[right];
                left++;
            }

            while((fun(this[left], pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                this[right] = this[left];
                right--;
            }
        }

        this[left] = pivot;

        pivot_num = left;

        var left2 = l_hold;
        var right2 = r_hold;

        if(left2 < pivot_num) {
            this.quickSort(left2, pivot_num-1, fun);
        }

        if(right2 > pivot_num) {
            this.quickSort(pivot_num+1, right2, fun);
        }

        return this;
    }

    def sort():native Array<T> {
        if(this.length > 0) {
            return this.quickSort(0, this.length-1, function(left, right) { return left.compare(right); });
        }
    }

    def sort(fun:lambda(T, T):Number):native Array<T> {
        if(this.length > 0) {
            return this.quickSort(0, this.length-1, fun.function_);
        }
    }

    def splice(index:Number): pure_native Array<T>;
    def splice(index:Number, len:Number): pure_native Array<T>;
    def splice(index:Number, len:Number, item1:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T, item5:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T, item5:T, item6:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T): pure_native Array<T>;
    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T, item8:T): pure_native Array<T>;

    def splice(index:Number, len:Number, item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T, item8:T, item9:T): pure_native Array<T>;

    def concat(array_:Array<T>):pure_native Array<T>;

    def every(block_:lambda(T):bool):bool {
        len := self.length;
        for(i:=0; i<len; i++) {
            if(!block_(self.items(i))) {
                return false;
            }
        }
        return true;
    }
    def some(block_:lambda(T):bool):bool {
        len := self.length;
        for(i:=0; i<len; i++) {
            if(block_(self.items(i))) {
                return true;
            }
        }
        return false;
    }

    def unshift(item1:T): pure_native Number;
    def unshift(item1:T, item2:T): pure_native Number;
    def unshift(item1:T, item2:T, item3:T): pure_native Number;
    def unshift(item1:T, item2:T, item3:T, item4:T): pure_native Number;

    def unshift(item1:T, item2:T, item3:T, item4:T, item5:T): pure_native Number;

    def unshift(item1:T, item2:T, item3:T, item4:T, item5:T, item6:T): pure_native Number;

    def unshift(item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T): pure_native Number;

    def unshift(item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T, item8:T): pure_native Number;

    def unshift(item1:T, item2:T, item3:T, item4:T, item5:T, item6:T, item7:T, item8:T, item9:T): pure_native Number;

    def filter(block_:lambda(T):bool):Array<T> {
        result := Array<T>(0);

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                result.push(items(i));
            }
        }

        return result;
    }

    def find(block_:lambda(T):bool):T? {
        result := Array<T>(0);

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                return items(i);
            }
        }

        return null;
    }

    def findIndex(block_:lambda(T):bool):Number {
        result := Array<T>(0);

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                return i;
            }
        }

        return -1;
    }

    def forEach(block_:lambda(T)) {
        for(i:=0; i<self.length; i++) {
            block_(items(i))
        }
    }

    def indexOf(item:T, count:Number=1):native Number {
        var n = 0;
        for(var i= 0; i<this.length; i++) {
            if(this[i].equals(item)) {
                n++;

                if(n == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    def join(): native String {
        return this.join();
    }

    def join(str:String): native String {
        return this.join(str);
    }

    def lastIndexOf(item:T): native Number {
        for(var i= this.length-1; i>=0; i--) {
            if(this[i].equals(item)) {
                return i;
            }
        }

        return -1;
    }
    def lastIndexOf(item:T, fromIndex:Number): native Number {
        if(fromIndex < 0) {
            fromIndex += this.length;
        }

        if(fromIndex >= this.length) {
            fromIndex = this.length - 1;
        }

        for(var i = fromIndex; i>=0; i--) {
            if(this[i].equals(item)) {
                return i;
            }
        }

        return -1;
    }

    def entries(): pure_native Iterator;

    def keys(): pure_native Iterator;
    def values(): pure_native Iterator;

    def <R:ISortable> map(trans:lambda(T):R): Array<R> {
        result:Array<R> = Array<R>(0);

        for(i:=0; i<self.length; i++) {
            result.push(trans(items(i)));
        }

        return result;
    }
}

class Tuple1 <T:IEqualable>: js
{
    value1: T?;

    def initialize() {
        self.value1 = null;
    }

    def initialize(value1:T) {
        self.value1 = value1;
    }

    def clone(): pure_native Tuple1<T> {
        var result = new Tuple1();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }

        return result;
    }

    def equals(right:Tuple1<T>):pure_native bool {
        return this.value1.equals(right.value1);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "}";
    }
}

class Tuple2 <T:IEqualable, T2:IEqualable>: js
{
    value1: T?;
    value2: T2?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
    }

    def initialize(value1:T, value2:T2) {
        self.value1 = value1;
        self.value2 = value2;
    }

    def clone(): pure_native Tuple2<T, T2> {
        var result = new Tuple2();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }

        return result;
    }

    def equals(right:Tuple2<T,T2>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "}";
    }
}

class Tuple3 <T:IEqualable, T2:IEqualable, T3:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
    }

    def clone(): pure_native Tuple3<T, T2, T3> {
        var result = new Tuple3();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }

        return result;
    }

    def equals(right:Tuple3<T,T2,T3>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "," + this.value3.toString__() + "}";
    }
}

class Tuple4 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
    }

    def clone(): pure_native Tuple4<T, T2, T3, T4> {
        var result = new Tuple4();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }

        return result;
    }

    def equals(right:Tuple4<T,T2,T3,T4>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "," + this.value3.toString__() + "," + this.value4.toString__() + "}";
    }
}

class Tuple5 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;
    value5: T5?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
        self.value5 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
    }

    def clone(): pure_native Tuple5<T, T2, T3, T4, T5> {
        var result = new Tuple5();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }
        if(this.value5 != null) {
            result.value5 = this.value5.clone();
        }

        return result;
    }

    def equals(right:Tuple5<T,T2,T3,T4,T5>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4) && this.value5.equals(right.value5);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + ","+ this.value2.toString__() + "," + this.value3.toString__() + "," + this.value4.toString__() + "," + this.value5.toString__() + "}";
    }
}

class Tuple6 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;
    value5: T5?;
    value6: T6?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
        self.value5 = null;
        self.value6 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
    }

    def clone(): pure_native Tuple6<T, T2, T3, T4, T5, T6> {
        var result = new Tuple6();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }
        if(this.value5 != null) {
            result.value5 = this.value5.clone();
        }
        if(this.value6 != null) {
            result.value6 = this.value6.clone();
        }

        return result;
    }

    def equals(right:Tuple6<T,T2,T3,T4,T5,T6>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4) && this.value5.equals(right.value5) && this.value6.equals(right.value6);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "," + this.value3.toString__() + "," + this.value4.toString__() + "," + this.value5.toString__() + "," + this.value6.toString__() + "}";
    }
}

class Tuple7 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;
    value5: T5?;
    value6: T6?;
    value7: T7?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
        self.value5 = null;
        self.value6 = null;
        self.value7 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
    }

    def clone(): pure_native Tuple7<T, T2, T3, T4, T5, T6, T7> {
        var result = new Tuple7();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }
        if(this.value5 != null) {
            result.value5 = this.value5.clone();
        }
        if(this.value6 != null) {
            result.value6 = this.value6.clone();
        }
        if(this.value7 != null) {
            result.value7 = this.value7.clone();
        }

        return result;
    }

    def equals(right:Tuple7<T,T2,T3,T4,T5,T6,T7>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4) && this.value5.equals(right.value5) && this.value6.equals(right.value6) && this.value7.equals(right.value7);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "," + this.value3.toString__() + "," + this.value4.toString__() + "," + this.value5.toString__() + "," + this.value6.toString__() + "," + this.value7.toString__() + "}";
    }
}

class Tuple8 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;
    value5: T5?;
    value6: T6?;
    value7: T7?;
    value8: T8?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
        self.value5 = null;
        self.value6 = null;
        self.value7 = null;
        self.value8 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
    }

    def clone(): pure_native Tuple8<T, T2, T3, T4, T5, T6, T7, T8> {
        var result = new Tuple8();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }
        if(this.value5 != null) {
            result.value5 = this.value5.clone();
        }
        if(this.value6 != null) {
            result.value6 = this.value6.clone();
        }
        if(this.value7 != null) {
            result.value7 = this.value7.clone();
        }
        if(this.value8 != null) {
            result.value8 = this.value8.clone();
        }

        return result;
    }

    def equals(right:Tuple8<T,T2,T3,T4,T5,T6,T7,T8>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4) && this.value5.equals(right.value5) && this.value6.equals(right.value6) && this.value7.equals(right.value7) && this.value8.equals(right.value8);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + ","+ this.value3.toString__() + "," + this.value4.toString__() + ","+ this.value5.toString__() + "," + this.value6.toString__() + "," + this.value7.toString__() + "," + this.value8.toString__() + "}";
    }
}

class Tuple9 <T:IEqualable, T2:IEqualable, T3:IEqualable, T4:IEqualable, T5:IEqualable, T6:IEqualable, T7:IEqualable, T8:IEqualable, T9:IEqualable>: js
{
    value1: T?;
    value2: T2?;
    value3: T3?;
    value4: T4?;
    value5: T5?;
    value6: T6?;
    value7: T7?;
    value8: T8?;
    value9: T9?;

    def initialize() {
        self.value1 = null;
        self.value2 = null;
        self.value3 = null;
        self.value4 = null;
        self.value5 = null;
        self.value6 = null;
        self.value7 = null;
        self.value8 = null;
        self.value9 = null;
    }

    def initialize(value1:T, value2:T2, value3:T3, value4:T4, value5:T5, value6:T6, value7:T7, value8:T8, value9:T9) {
        self.value1 = value1;
        self.value2 = value2;
        self.value3 = value3;
        self.value4 = value4;
        self.value5 = value5;
        self.value6 = value6;
        self.value7 = value7;
        self.value8 = value8;
        self.value9 = value9;
    }

    def clone(): pure_native Tuple9<T, T2, T3, T4, T5, T6, T7, T8, T9> {
        var result = Tuple9();

        if(this.value1 != null) {
            result.value1 = this.value1.clone();
        }
        if(this.value2 != null) {
            result.value2 = this.value2.clone();
        }
        if(this.value3 != null) {
            result.value3 = this.value3.clone();
        }
        if(this.value4 != null) {
            result.value4 = this.value4.clone();
        }
        if(this.value5 != null) {
            result.value5 = this.value5.clone();
        }
        if(this.value6 != null) {
            result.value6 = this.value6.clone();
        }
        if(this.value7 != null) {
            result.value7 = this.value7.clone();
        }
        if(this.value8 != null) {
            result.value8 = this.value8.clone();
        }
        if(this.value9 != null) {
            result.value9 = this.value9.clone();
        }

        return result;
    }

    def equals(right:Tuple9<T,T2,T3,T4,T5,T6,T7,T8,T9>):pure_native bool {
        return this.value1.equals(right.value1) && this.value2.equals(right.value2) && this.value3.equals(right.value3) && this.value4.equals(right.value4) && this.value5.equals(right.value5) && this.value6.equals(right.value6) && this.value7.equals(right.value7) && this.value8.equals(right.value8) && this.value9.equals(right.value9);
    }

    def toString():native String {
        return "tuple {" + this.value1.toString__() + "," + this.value2.toString__() + "," + this.value3.toString__() + "," + this.value4.toString__() + "," + this.value5.toString__() + "," + this.value6.toString__() + "," + this.value7.toString__() + "," + this.value8.toString__() + "," + this.value9.toString__() + "}";
    }
}

class IteratorResult:js
{
    var value:Array<Any>;
    var done:bool;
}

interface Iterator:js
{
    def next(): pure_native IteratorResult;
}

class Map<T:IHashKey, T2:IEqualable>:native js
{
    var size:Number;

    def constructor():pure_native Map<T, T2>;

    def entries(): pure_native Iterator;

    def get(key:T): native T2? {
        for(var [key2, value] of this.entries()) {
            if(key2.equals(key)) {
                return value;
            }
        }

        return null;
    }

    def set(key:T, item:T2): pure_native;

    def clear(): pure_native;

    def delete(key:T): native bool {
        for(var [key2, value] of this.entries()) {
            if(key2.equals(key)) {
                this.delete(key);
                return true;
            }
        }

        return false;
    }

    def has(key:T): native bool {
        for(var [key2, value] of this.entries()) {
            if(key2.equals(key)) {
                return true;
            }
        }

        return false;
    }

    def forEach(block_:lambda(T, T2)) {
        var it = self.entries();

        while(true) {
            var it_res = it.next();

            if(it_res.done) {
                break;
            }

            block_(it_res.value.items(0), it_res.value.items(1));
        }
    }
}

class Function:native js
{
}

class Lambda:js
{
    var function_:Function;
    var lambda_:bool;
    var parentVarNum:Number;
    var funcName:String;
    var numParams:Number;
    var stackPoint:Number;
    var lvar:Number;
    var listener:bool;

    def constructor(function_:Function, lambda_:bool, parent_var_num:Number, func_name:String, num_params:Number, lvar:Number):native Lambda 
    {
        this.function_ = function_;
        this.lambda_ = lambda_;
        this.parentVarNum = parent_var_num;
        this.funcName = func_name;
        this.numParams = num_params;
        this.lvar = lvar;
        this.listener = true;

        return this;
    }

    def copyParentStack(lvar:Number): pure_native {
        for(var i=0; i<this.parentVarNum; i++) { 
            clover2Stack[lvar+i] = clover2Stack[this.lvar+i];
        }
    }

    def copyBackParentStack(lvar:Number):pure_native {
        for(var i=0; i<this.parentVarNum; i++) { 
            clover2Stack[this.lvar+i] = clover2Stack[lvar+i];
        }
    }
}

class String:native js
{
    def constructor(str:String):pure_native String;
    def toString(): native String {
        return new String(this);
    }

    def match(regex_:regex): native bool {
        return regex_.test(this);
    }
    def clone(): pure_native String {
        return `${this}`;
    }

    def equals(str:String):pure_native bool {
        return this == str;
    }
    def compare(right:String): pure_native Number {
        if(this == right) {
            return 0;
        }
        else if(this < right) {
            return -1;
        }
        else {
            return 1;
        }
    }
    def add(right:String):native String {
        return this + right;
    }
    def charAt(index:Number):pure_native String;
    def charCodeAt(index:Number):pure_native Number;
    #def charPointAt(index:Number):pure_native Number;
    def concat(str:String):pure_native String;
    def includes(str:String):pure_native bool;
    def includes(str:String, index:Number):pure_native bool;
    def endsWith(str:String):pure_native bool;
    def endsWith(str:String, index:Number):pure_native bool;
    def indexOf(str:String):pure_native Number;
    def lastIndexOf(str:String):pure_native Number;
    def localeCompare(str:String):pure_native Number;
    def normalize(str:String): pure_native String;
    def padEnd(num:Number): pure_native String;
    def padEnd(num:Number, str:String): pure_native String;
    def padStart(num:Number): pure_native String;
    def padStart(num:Number, str:String): pure_native String;
    def repeat(num:Number): pure_native String;
    def replace(regex_:regex, str:String): pure_native String;
    def search(regex_:regex): pure_native Number;
    def slice(index:Number): pure_native String;
    def slice(index:Number, index2:Number): pure_native String;
    def split(str:String):pure_native Array<String>;
    def split(str:String, limit:Number):pure_native Array<String>;
    def split(regex_:regex):pure_native Array<String>;
    def split(regex_:regex, limit:Number):pure_native Array<String>;
    def startsWith(str:String):pure_native bool;
    def startsWith(str:String, index:Number):pure_native bool;
    def substring(indexStart:Number):pure_native String;
    def substring(indexStart:Number, indexEnd:Number):pure_native String;
    def toLowerCase():pure_native String;
    def toUpperCase():pure_native String;
    def trim():pure_native String;
    def trimEnd():pure_native String;
    def trimStart():pure_native String;
}

class Set<T:ISortable>:native js
{
    size: Number;

    def constructor(array:Array<T>):pure_native Set<T> {
        for(var i=0; i<array.length; i++) {
            this.add__GenericsParametorClass0(array[i]);
        }
        return this;
    }

    def entries(): pure_native Iterator;
    def keys(): pure_native Iterator;
    def values(): pure_native Iterator;

    def add(value:T):native Set<T> {
        var it = this.entries();

        var found = false;

        while(true) {
            var it_res = it.next();

            if(it_res.done) {
                break;
            }

            if(it_res.value[0].equals(value)) {
                found = true;
            }
        }

        if(!found) {
            this.add(value);
        }
        
        return this;
    }

    def has(value:T): pure_native bool;

    def clear(): pure_native;

    def delete(value:T): pure_native bool;

    def equals(right:Set<T>): pure_native bool {
        if(this.size != right.size) {
            return false;
        }

        var it = this.entries();
        var it2 = right.entries();

        while(true) {
            var it_res = it.next();
            var it_res2 = it2.next();

            if(it_res.done) {
                break;
            }

            if(!it_res.value[0].equals(it_res2.value[0])) {
                return false;
            }
        }

        return true;
    }

    def forEach(block_:lambda(T)) {
        var it = self.entries();

        while(true) {
            var it_res = it.next();

            if(it_res.done) {
                break;
            }

            block_(it_res.value.items(0));
        }
    }
}

class Number:native js
{
    def constructor():pure_native Number;

    def compare(item:Number): pure_native Number {
        if(this < item) {
            return -1;
        }
        else if(this > item) {
            return 1;
        }
        else {
            return 0;
        }
    }
    def equals(right:Number): pure_native bool {
        return this == right;
    }
    def toString(): native String {
        return new String(this);
    }
    def clone(): pure_native Number {
        return this;
    }
    def add(right:Number):native Number {
        return this + right;
    }

    def println() {
        System.println(self);
    }
}

class Bool:js unboxing bool
{
    var num:bool;

    def constructor(num:bool):native Bool {
        this.num = num;

        return this;
    }

    def initialize(num:bool): native Bool {
        this.num = num;

        return this;
    }

    def toString():native String {
        if(self.num) {
            return "true";
        }
        else {
            return "false";
        }
    }
}

interface Object:js
{
}

class Null:js
{
}

class Error:js
{
}

class Exception:js
{
    message:String;

    def initialize(message:String) {
        self.message = message;
    }
}

class DOMString:native js
{
}

module MElement
{
    var innerHTML:String;
}

class Element:native js
{
    include MElement;
}

class Node:native js
{
    include MElement;

    var childNodes:NodeList;
    var children:NodeList;
}

class NodeList:native js
{
    var length:Number;

    def item(n:Number): pure_native Node {
        retuurn this[n];
    }
    def entries(): pure_native Iterator;
    def keys(): pure_native Iterator;
    def values(): pure_native Iterator;

    def forEach(block_:lambda(Node)) {
        for(i:=0; i<self.length; i++) {
            block_(item(i))
        }
    }
}

class Document:js
{
    def write(str:String):pure_native;

    def getElementById(str:String): pure_native Element;
    def getElementsByTagName(str:String): pure_native NodeList;
}

class EventListnerOpetion:native js
{
    var capture:bool;
    var once:bool;
    var passive:bool;

    def initialize(capture:bool, once:bool, passive:bool):native EventListnerOpetion {
        this.capture = capture;
        this.once = once;
        this.passive = passive

        return this;
    }
}

class Event:native js
{
    def contructor(): pure_native;

    type:String;
    data:String;
}

class ArrayBuffer:native js 
{
    var byteLength:Number;
    var length:Number;

    def isView(any:Any):pure_native bool;
    def constructor(len:Number): pure_native;
}

class Blob:native js
{
    val size:Number;
    val type:String;

#    def constructor(array:Array<ArrayBuffer>): pure_native;
#    def constructor(array:Array<ArrayBufferView>): pure_native;
#    def constructor(array:Array<Blob>): pure_native;
    def constructor(array:Array<String>): pure_native;
#    def constructor(array:Array<ArrayBuffer>, type:String): pure_native;
#    def constructor(array:Array<ArrayBufferView>, type:String): pure_native;
#    def constructor(array:Array<Blob>, type:String): pure_native;
    def constructor(array:Array<String>, type:String): pure_native;
}

module MTypedArray
{
    var length:Number;

    def constructor(len:Number): pure_native;
    def constructor(array_:Array<Number>): pure_native;

    def items(n:Number): native Number {
        return this[n];
    }
    def put(index:Number, n:Number):native {
        this[index] = n;
    }
    def equals(right:SELF): native bool {
        if(this.length == right.length) {
            for(var i = 0; i < this.length; i++) {
                if(this[i] != right[i]) {
                    return false;
                }
            }

            return true;
        }
        else {
            return fasel;
        }
    }

    def copyWithin(index:Number, start:Number=0): native SELF {
        var end = this.length;
        this.copyWithin(index, start, end);

        return this;
    }
    def copyWithin(index:Number, start:Number, end:Number): native SELF {
        this.copyWithin(index, start, end);

        return this;
    }
    def entries(): pure_native Iterator;
    def every(block_:lambda(Number):bool):bool {
        len := self.length;
        for(i:=0; i<len; i++) {
            if(!block_(self.items(i))) {
                return false;
            }
        }
        return true;
    }
    def fill(data:Number, start:Number=0): native SELF {
        var end = this.length;
        this.fill(data, start, end);

        return this;
    }
    def fill(data:Number, start:Number, end:Number): native SELF {
        this.fill(data, start, end);

        return this;
    }
    def filter(block_:lambda(Number):bool):SELF {
        result := SELF(self.length);

        n := 0;

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                result.put(n++, items(i));
            }
        }

        return result;
    }
    def find(block_:lambda(Number):bool):Number? {
        result := SELF(0);

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                return items(i);
            }
        }

        return null;
    }
    def findIndex(block_:lambda(Number):bool):Number {
        result := SELF(0);

        for(i:=0; i<self.length; i++) {
            if(block_(items(i))) {
                return i;
            }
        }

        return -1;
    }
    def forEach(block_:lambda(Number)) {
        for(i:=0; i<self.length; i++) {
            block_(items(i))
        }
    }
    def includes(item:Number):native bool {
        for(var i=0; i<this.length; i++) {
            if(this[i] == item) {
                return true;
            }
        }

        return false;
    }
    def indexOf(item:Number, count:Number=1):native Number {
        var n = 0;
        for(var i= 0; i<this.length; i++) {
            if(this[i] == item) {
                n++;

                if(n == count) {
                    return i;
                }
            }
        }

        return -1;
    }
    def join(): native String {
        return this.join();
    }
    def join(str:String): native String {
        return this.join(str);
    }
    def keys(): pure_native Iterator;
    def values(): pure_native Iterator;
    def lastIndexOf(item:Number): native Number {
        for(var i= this.length-1; i>=0; i--) {
            if(this[i] == item) {
                return i;
            }
        }

        return -1;
    }
    def lastIndexOf(item:Number, fromIndex:Number): native Number {
        if(fromIndex < 0) {
            fromIndex += this.length;
        }

        if(fromIndex >= this.length) {
            fromIndex = this.length - 1;
        }

        for(var i = fromIndex; i>=0; i--) {
            if(this[i] == item) {
                return i;
            }
        }

        return -1;
    }
    def map(trans:lambda(Number):Number): SELF {
        result := SELF(self.length);

        n := 0;

        for(i:=0; i<self.length; i++) {
            result.put(n++, trans(items(i)));
        }

        return result;
    }
    def reverse(): pure_native SELF;
    def slice(n:Number): pure_native SELF;
    def slice(n:Number, n2:Number): pure_native SELF;
    def some(block_:lambda(Number):bool):bool {
        len := self.length;
        for(i:=0; i<len; i++) {
            if(block_(self.items(i))) {
                return true;
            }
        }
        return false;
    }
    def sort(): native SELF {
        return this.sort();
    }

    def sort(block_:lambda(Number, Number):Number): native SELF {
        return this.sort(block_.function_);
    }

    def subarray(begin:Number): native SELF {
        return this.subarray(begin);
    }
    def subarray(begin:Number, end:Number): native SELF {
        return this.subarray(begin, end);
    }

    def toString(): pure_native String;
}

class Int8Array:native js
{
    include MTypedArray;
}

class Uint8Array:native js
{
    include MTypedArray;
}

class Uint8ClampedArray:native js
{
    include MTypedArray;
}

class Int16Array:native js
{
    include MTypedArray;
}

class Uint16Array:native js
{
    include MTypedArray;
}

class Int32Array:native js
{
    include MTypedArray;
}

class Uint32Array:native js
{
    include MTypedArray;
}

class Float32Array:native js
{
    include MTypedArray;
}

class Float64Array:native js
{
    include MTypedArray;
}

class DataView:native js
{
    var length:Number;

    def constructor(len:Number): pure_native;
}

class WebSocket:native js
{
    var binaryType:String;
    var buffferAmount: Number;
    var extensions:String;
    var protocol:String;
    var readyState:Number;
    var url:String;

    def constructor(str:String): pure_native;
    def constructor(str:String, protocol:String): pure_native;
    def constructor(str:String, protocol:Array<String>): pure_native;

    var onopen:lambda(Event);
    var onerror:lambda(Event);
    var onmessage:lambda(Event);
    var onclose:lambda(Event);

    def onopen(block_:lambda(Event)):native {
        this.onopen = block_.function_;
    }

    def onerror(block_:lambda(Event)):native {
        this.onerror = block_.function_;
    }

    def onmessage(block_:lambda(Event)):native {
        this.onmessage = block_.function_;
    }

    def onclose(block_:lambda(Event)):native {
        this.onclose = block_.function_;
    }

    def close(): pure_native;
    def close(code:Number, reason:String): pure_native;

    def send(str:String): pure_native;
    def send(buffer:ArrayBuffer): pure_native;
    def send(blob:Blob):pure_native;
    def send(buf:Int8Array): pure_native;
    def send(buf:Uint8Array): pure_native;
    def send(buf:Uint8ClampedArray): pure_native;
    def send(buf:Int16Array): pure_native;
    def send(buf:Uint16Array): pure_native;
    def send(buf:Int32Array): pure_native;
    def send(buf:Uint32Array): pure_native;
    def send(buf:Float32Array): pure_native;
    def send(buf:Float64Array): pure_native;
    def send(buf:DataView): pure_native;
}

