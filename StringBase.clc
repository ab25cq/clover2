include "Fundamental.clc"

class PcreOVec
{
    start:int[];
    end:int[];

    def initialize(max:int) {
        self.start = new int[max]();
        self.end = new int[max]();
    }
}

class System
{
    def pcre_exec(regex:regex, str:String, offset:int, ovec_max:int, ovec:PcreOVec): native static int;
}

class String
{
    def subString(start:int, end:int): String {
        if(start < 0) {
            start += self.length();
        }
        if(end < 0) {
            end += self.length() + 1;
        }

        if(start < 0 || end < 0 || start >= end) {
            return "";
        }

        result: String = new String(end-start+1);

        for(i:int = 0; i<end-start; i++) {
            result.buffer[i] = self.chars(i+start);
        }
        result.buffer[i] = '\0';

        result.len = end-start;
        result.size = end-start+1;

        return result;
    }

    def println() {
        println(self);
    }

    def printf(format:String) {
        printf(format, array { self });
    }

    def sub(regex_:regex, replace:String, group_strings:List<String>): String {
        result: String = new String();
        offset:int = 0;

        while(true) {
            ovec_max:int = 16;
            ovec:PcreOVec = new PcreOVec(ovec_max);

            regex_result:int = System.pcre_exec(regex_, self, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
                match_string:String = self.subString(ovec.start[0], ovec.end[0]);
                result.append(self.subString(offset, ovec.start[0]));
                result.append(replace);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = self.subString(offset, -1);
                    result.append(str);
                    break;
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                match_string:String = self.subString(ovec.start[0], ovec.end[0]);
                result.append(self.subString(offset, ovec.start[0]));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                group_strings.clear();
                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = self.subString(ovec.start[i], ovec.end[i]);
                    group_strings.add(match_string);
                }

                result.append(replace);

                if(!regex_.global) {
                    str:String = self.subString(offset, -1);
                    result.append(str);
                    break;
                }
            }
            ### no match ###
            else {
                str:String = self.subString(offset, -1);
                result.append(str);
                break;
            }
        }

        return result;
    }

    def sub(regex_:regex, replace:lambda(String,List<String>):String, group_strings:List<String>): String {
        result: String = new String();
        offset:int = 0;

        while(true) {
            ovec_max:int = 16;
            ovec:PcreOVec = new PcreOVec(ovec_max);

            regex_result:int = System.pcre_exec(regex_, self, offset, ovec_max, ovec);

            ### match and no group strings ###
            if(regex_result == 1 || group_strings.identifyWith(null) && regex_result > 0) {
                match_string:String = self.subString(ovec.start[0], ovec.end[0]);
                result.append(self.subString(offset, ovec.start[0]));
                replace_string:String = replace(match_string, new List<String>());
                result.append(replace_string);

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                if(!regex_.global) {
                    str:String = self.subString(offset, -1);
                    result.append(str);
                    break;
                }
            }
            ### group strings ###
            elif(regex_result > 1) {
                match_string:String = self.subString(ovec.start[0], ovec.end[0]);
                result.append(self.subString(offset, ovec.start[0]));

                if(offset == ovec.end[0]) {
                    offset++;
                }
                else {
                    offset = ovec.end[0];
                }

                group_strings.clear();
                for(i:int = 1; i<regex_result; i++) {
                    match_string:String = self.subString(ovec.start[i], ovec.end[i]);
                    group_strings.add(match_string);
                }

                replace_string:String = replace(match_string, group_strings);
                result.append(replace_string);

                if(!regex_.global) {
                    str:String = self.subString(offset, -1);
                    result.append(str);
                    break;
                }
            }
            ### no match ###
            else {
                str:String = self.subString(offset, -1);
                result.append(str);
                break;
            }
        }

        return result;
    }
}
